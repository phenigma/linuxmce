/*
    This file is part of QOrbiter for use with the LinuxMCE project found at http://www.linuxmce.org
   Langston Ball  golgoj4@gmail.com
    QOrbiter is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    QOrbiter is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with QOrbiter.  If not, see <http://www.gnu.org/licenses/>.

    This is the combination of Autogenerated DCE code in conjunction with QT code for creating the hybrid software device.
*/


//<-dceag-d-b->
#include "qOrbiter.h"
#include "DCE/Logger.h"
#include "PlutoUtils/FileUtils.h"
#include "PlutoUtils/StringUtils.h"
#include "PlutoUtils/Other.h"
#include "../pluto_media/Define_AttributeType.h"

#include <iostream>
using namespace std;
using namespace DCE;

//<-dceag-d-e->
#include "Gen_Devices/AllScreens.h"
#include "Gen_Devices/AllCommandsRequests.h"
#include <QDebug>
#include <iostream>
#include <pthread.h>
#ifdef QT5
#include <QtWidgets/QApplication>
#else
#if !defined(Q_OS_ANDROID)
#include <QX11EmbedWidget>
#endif
#endif

#include "pluto_main/Define_DataGrid.h"
#include "qOrbiter/qOrbiter_src/datamodels/ActiveMediaStreams.h"
#include "datamodels/DataGridHandler.h"
#include "QVariantMap"
#include "qmap.h"
//<-dceag-const-b->
// The primary constructor when the class is created as a stand-alone device
qOrbiter::qOrbiter(QString name, int DeviceID, string ServerAddress,bool bConnectEventHandler,bool bLocalMode,class Router *pRouter, QObject*parent)
    : qOrbiter_Command(DeviceID, ServerAddress,bConnectEventHandler,bLocalMode,pRouter)
    //<-dceag-const-e->
{
    deviceName = name;

    QObject::connect(this, SIGNAL(dceIPChanged()), this, SLOT(pingCore()));
    QObject::connect(this, SIGNAL(transmitDceCommand(PreformedCommand)), this, SLOT(sendDCECommand(PreformedCommand)), Qt::DirectConnection);
    QObject::connect(this, SIGNAL(transmitDceCommandResp(DCECommand*)), this, SLOT(sendDCECommandResp(DCECommand*)), Qt::DirectConnection);

    qRegisterMetaType< QMap<long, std::string> >("QMap<long, std::string>");

}

bool qOrbiter::GetConfig()
{
    if(!qOrbiter_Command::GetConfig()){
        return false;
    }

    bool useQueue = DATA_Get_Queue_Instead_of_Instant_Play();

    qDebug() << "Queue or instant play " << useQueue;

    emit useQueueInsteadOfInstantPlayChanged(useQueue);

    int dt = m_pData->m_dwPK_DeviceTemplate;
    if( dt ==DEVICETEMPLATE_OnScreen_qOrbiter_CONST){
      //  m_bIsOSD=true;
    } else{
       // m_bIsOSD = false;
    }

    emit deviceTemplateChanged(dt);
    PurgeInterceptors();
#ifndef Q_OS_IOS
    RegisterMsgInterceptor((MessageInterceptorFn) (&qOrbiter::timeCodeInterceptor), 0,0,0,0,MESSAGETYPE_EVENT, EVENT_Media_Position_Changed_CONST );
#endif
    return true;

}
//<-dceag-const2-b->
// The constructor when the class is created as an embedded instance within another stand-alone device
qOrbiter::qOrbiter(Command_Impl *pPrimaryDeviceCommand, DeviceData_Impl *pData, Event_Impl *pEvent, Router *pRouter)
    : qOrbiter_Command(pPrimaryDeviceCommand, pData, pEvent, pRouter)
    //<-dceag-const2-e->
{

}

//<-dceag-reg-b->
// This function will only be used if this device is loaded into the DCE Router's memory space as a plug-in.  Otherwise Connect() will be called from the main()
bool qOrbiter::Register()
//<-dceag-reg-e->
{

    return Connect(PK_DeviceTemplate_get());
}

/*!  Since several parents can share the same child class, and each has it's own implementation, the base class in Gen_Devices
 cannot include the actual implementation.  Instead there's an extern function declared, and the actual new exists here.  You
 can safely remove this block (put a ! after the dceag-createinst-b block) if this device is not embedded within other devices. */
//<-dceag-createinst-b->
qOrbiter_Command *Create_qOrbiter(Command_Impl *pPrimaryDeviceCommand, DeviceData_Impl *pData, Event_Impl *pEvent, Router *pRouter)
{
    return new qOrbiter(pPrimaryDeviceCommand, pData, pEvent, pRouter);
}
//<-dceag-createinst-e->

/*
 When you receive commands that are destined to one of your children,
 then if that child implements DCE then there will already be a separate class
 created for the child that will get the message.  If the child does not, then you will
 get all	commands for your children in ReceivedCommandForChild, where
 pDeviceData_Base is the child device.  If you handle the message, you
 should change the sCMD_Result to OK
*/
//<-dceag-cmdch-b->
void qOrbiter::ReceivedCommandForChild(DeviceData_Impl *pDeviceData_Impl,string &sCMD_Result,Message *pMessage)
//<-dceag-cmdch-e->
{
    SetStatus("unhandled child");
    sCMD_Result = "UNHANDLED CHILD";
}

/*!
 When you received a valid command, but it wasn't for one of your children,
 then ReceivedUnknownCommand gets called.  If you handle the message, you
 should change the sCMD_Result to OK
*/
//<-dceag-cmduk-b->
void qOrbiter::ReceivedUnknownCommand(string &sCMD_Result,Message *pMessage)
//<-dceag-cmduk-e->
{
    sCMD_Result = "UNKNOWN COMMAND";
}

//<-dceag-sample-b->
/*		**** SAMPLE ILLUSTRATING HOW TO USE THE BASE CLASSES ****

**** IF YOU DON'T WANT DCEGENERATOR TO KEEP PUTTING THIS AUTO-GENERATED SECTION ****
**** ADD AN ! AFTER THE BEGINNING OF THE AUTO-GENERATE TAG, LIKE //<=dceag-sample-b->! ****
Without the !, everything between <=dceag-sometag-b-> and <=dceag-sometag-e->
will be replaced by DCEGenerator each time it is run with the normal merge selection.
The above blocks are actually <- not <=.  We don't want a substitution here

void qOrbiter::SomeFunction()
{
    // If this is going to be loaded into the router as a plug-in, you can implement: 	virtual bool Register();
    // to do all your registration, such as creating message interceptors

    // If you use an IDE with auto-complete, after you type DCE:: it should give you a list of all
    // commands and requests, including the parameters.  See "AllCommandsRequests.h"

    // Examples:

    // Send a specific the "CMD_Simulate_Mouse_Click" command, which takes an X and Y parameter.  We'll use 55,77 for X and Y.
    DCE::CMD_Simulate_Mouse_Click CMD_Simulate_Mouse_Click(m_dwPK_Device,OrbiterID,55,77);
    SendCommand(CMD_Simulate_Mouse_Click);

    // Send the message to orbiters 32898 and 27283 (ie a device list, hence the _DL)
    // And we want a response, which will be "OK" if the command was successfull
    string sResponse;
    DCE::CMD_Simulate_Mouse_Click_DL CMD_Simulate_Mouse_Click_DL(m_dwPK_Device,"32898,27283",55,77)
    SendCommand(CMD_Simulate_Mouse_Click_DL,&sResponse);

    // Send the message to all orbiters within the house, which is all devices with the category DEVICECATEGORY_Orbiter_CONST (see pluto_main/Define_DeviceCategory.h)
    // Note the _Cat for category
    DCE::CMD_Simulate_Mouse_Click_Cat CMD_Simulate_Mouse_Click_Cat(m_dwPK_Device,DEVICECATEGORY_Orbiter_CONST,true,BL_SameHouse,55,77)
    SendCommand(CMD_Simulate_Mouse_Click_Cat);

    // Send the message to all "DeviceTemplate_Orbiter_CONST" devices within the room (see pluto_main/Define_DeviceTemplate.h)
    // Note the _DT.
    DCE::CMD_Simulate_Mouse_Click_DT CMD_Simulate_Mouse_Click_DT(m_dwPK_Device,DeviceTemplate_Orbiter_CONST,true,BL_SameRoom,55,77);
    SendCommand(CMD_Simulate_Mouse_Click_DT);

    // This command has a normal string parameter, but also an int as an out parameter
    int iValue;
    DCE::CMD_Get_Signal_Strength CMD_Get_Signal_Strength(m_dwDeviceID, DestDevice, sMac_address,&iValue);
    // This send command will wait for the destination device to respond since there is
    // an out parameter
    SendCommand(CMD_Get_Signal_Strength);

    // This time we don't care about the out parameter.  We just want the command to
    // get through, and don't want to wait for the round trip.  The out parameter, iValue,
    // will not get set
    SendCommandNoResponse(CMD_Get_Signal_Strength);

    // This command has an out parameter of a data block.  Any parameter that is a binary
    // data block is a pair of int and char *
    // We'll also want to see the response, so we'll pass a string for that too

    int iFileSize;
    char *pFileContents
    string sResponse;
    DCE::CMD_Request_File CMD_Request_File(m_dwDeviceID, DestDevice, "filename",&pFileContents,&iFileSize,&sResponse);
    SendCommand(CMD_Request_File);

    // If the device processed the command (in this case retrieved the file),
    // sResponse will be "OK", and iFileSize will be the size of the file
    // and pFileContents will be the file contents.  **NOTE**  We are responsible
    // free deleting pFileContents.


    // To access our data and events below, you can type this-> if your IDE supports auto complete to see all the data and events you can access

    // Get our IP address from our data
    string sIP = DATA_Get_IP_Address();

    // Set our data "Filename" to "myfile"
    DATA_Set_Filename("myfile");

    // Fire the "Finished with file" event, which takes no parameters
    EVENT_Finished_with_file();
    // Fire the "Touch or click" which takes an X and Y parameter
    EVENT_Touch_or_click(10,150);
}
*/
//<-dceag-sample-e->

/*

 COMMANDS TO IMPLEMENT

*/

//<-dceag-c1-b->

/** @brief COMMAND: #1 - Capture Keyboard To Variable */
/** As the user types, using either the keyboard or simulate keypress commands, what he types will be stored in a variable and/or put into a text object. */
/** @param #3 PK_DesignObj */
/** The Design Object which contains the text Object */
/** @param #4 PK_Variable */
/** The variable in which to store the input */
/** @param #8 On/Off */
/** If 0, this stops capturing */
/** @param #14 Type */
/** 1=normal, 2=pin, 3=phone number */
/** @param #24 Reset */
/** if true, the next keypress will clear the variable and start new */
/** @param #25 PK_Text */
/** The text object in which to store the current input */
/** @param #55 DataGrid */
/** If 1, we'll scroll the data grid too when typing keys. */

void qOrbiter::CMD_Capture_Keyboard_To_Variable(string sPK_DesignObj,int iPK_Variable,string sOnOff,string sType,string sReset,int iPK_Text,bool bDataGrid,string &sCMD_Result,Message *pMessage)
//<-dceag-c1-e->
{
    cout << "Need to implement command #1 - Capture Keyboard To Variable" << endl;
    cout << "Parm #3 - PK_DesignObj=" << sPK_DesignObj << endl;
    cout << "Parm #4 - PK_Variable=" << iPK_Variable << endl;
    cout << "Parm #8 - OnOff=" << sOnOff << endl;
    cout << "Parm #14 - Type=" << sType << endl;
    cout << "Parm #24 - Reset=" << sReset << endl;
    cout << "Parm #25 - PK_Text=" << iPK_Text << endl;
    cout << "Parm #55 - DataGrid=" << bDataGrid << endl;
}

//<-dceag-c2-b->

/** @brief COMMAND: #2 - Orbiter Beep */
/** Make the orbiter beep */

void qOrbiter::CMD_Orbiter_Beep(string &sCMD_Result,Message *pMessage)
//<-dceag-c2-e->
{
    cout << "Need to implement command #2 - Orbiter Beep" << endl;
}

//<-dceag-c3-b->

/** @brief COMMAND: #3 - Display On/Off */
/** Turn the display on or off */
/** @param #8 On/Off */
/** 0=Off, 1=On */
/** @param #125 Already processed */
/** Normally Orbiter will forward the on/off through DCE so the other devices can turn on/off.  If this is true, it won't. */

void qOrbiter::CMD_Display_OnOff(string sOnOff,bool bAlready_processed,string &sCMD_Result,Message *pMessage)
//<-dceag-c3-e->
{
    cout << "Need to implement command #3 - Display On/Off" << endl;
    cout << "Parm #8 - OnOff=" << sOnOff << endl;
    cout << "Parm #125 - Already_processed=" << bAlready_processed << endl;

}

//<-dceag-c4-b->

/** @brief COMMAND: #4 - Go back */
/** Make the orbiter go back to the prior screen, like the back button in a web browser */
/** @param #16 PK_DesignObj_CurrentScreen */
/** If this is specified, the orbiter will ignore the command unless this is the current screen */
/** @param #21 Force */
/** Screens can be flagged, "Cant go back", meaning the go back will skip over them.  If Force=1, the Orbiter returns to the prior screen regardless */

void qOrbiter::CMD_Go_back(string sPK_DesignObj_CurrentScreen,string sForce,string &sCMD_Result,Message *pMessage)
//<-dceag-c4-e->
{
    cout << "Need to implement command #4 - Go back" << endl;
    cout << "Parm #16 - PK_DesignObj_CurrentScreen=" << sPK_DesignObj_CurrentScreen << endl;
    cout << "Parm #21 - Force=" << sForce << endl;

}

//<-dceag-c5-b->

/** @brief COMMAND: #5 - Goto DesignObj */
/** Goto a specific design obj */
/** @param #2 PK_Device */
/** For this screen only, override the normal "control device" stored in variable #1, and treat this device as the control screen.  When the screen changes, it will be reset */
/** @param #3 PK_DesignObj */
/** The screen to go to.  Can be be fully qualified (x.y.z), or just contain the screen # */
/** @param #10 ID */
/** Assigns an optional ID to this particular "viewing" of the screen, used with Kill Screen.  There can be lots of instances of the same screen in the history queue (such as call in progress).  This allows a program to pop a particular one out of the queue. */
/** @param #16 PK_DesignObj_CurrentScreen */
/** If this is specified, the orbiter will ignore the command unless this is the current screen.  If this is -1, that will match a main menu or screen saver (ie the Orbiter is not in use). */
/** @param #22 Store Variables */
/** If 1, the Orbiter will store the current variable values, and restore them if a 'go back' causes it to return to this screen */
/** @param #114 Cant Go Back */
/** If true, then when this screen goes away the user won't be able to return to it -- it will be skipped over, unless Go Back with Force=1 is used.  This prevents layers of popup screens. */

void qOrbiter::CMD_Goto_DesignObj(int iPK_Device,string sPK_DesignObj,string sID,string sPK_DesignObj_CurrentScreen,bool bStore_Variables,bool bCant_Go_Back,string &sCMD_Result,Message *pMessage)
//<-dceag-c5-e->
{
    cout << "Need to implement command #5 - Goto DesignObj" << endl;
    cout << "Parm #2 - PK_Device=" << iPK_Device << endl;
    cout << "Parm #3 - PK_DesignObj=" << sPK_DesignObj << endl;
    cout << "Parm #10 - ID=" << sID << endl;
    cout << "Parm #16 - PK_DesignObj_CurrentScreen=" << sPK_DesignObj_CurrentScreen << endl;
    cout << "Parm #22 - Store_Variables=" << bStore_Variables << endl;
    cout << "Parm #114 - Cant_Go_Back=" << bCant_Go_Back << endl;
}

//<-dceag-c6-b->

/** @brief COMMAND: #6 - Show Object */
/** Change an objects visible state. */
/** @param #3 PK_DesignObj */
/** The object to show or hide */
/** @param #4 PK_Variable */
/** The variable to use in the comparisson.  See Comparisson Value. */
/** @param #6 Comparisson Operator */
/** A type of comparisson: =  <  <>  !=  > */
/** @param #7 Comparisson Value */
/** If a Variable, Comparisson Type, and Comparisson Value are specified, the command will be ignored if the comparisson is not true */
/** @param #8 On/Off */
/** 1=show object, 0=hide object */

void qOrbiter::CMD_Show_Object(string sPK_DesignObj,int iPK_Variable,string sComparisson_Operator,string sComparisson_Value,string sOnOff,string &sCMD_Result,Message *pMessage)
//<-dceag-c6-e->
{
    cout << "Need to implement command #6 - Show Object" << endl;
    cout << "Parm #3 - PK_DesignObj=" << sPK_DesignObj << endl;
    cout << "Parm #4 - PK_Variable=" << iPK_Variable << endl;
    cout << "Parm #6 - Comparisson_Operator=" << sComparisson_Operator << endl;
    cout << "Parm #7 - Comparisson_Value=" << sComparisson_Value << endl;
    cout << "Parm #8 - OnOff=" << sOnOff << endl;
}

//<-dceag-c7-b->

/** @brief COMMAND: #7 - Terminate Orbiter */
/** Causes the Orbiter application to exit */

void qOrbiter::CMD_Terminate_Orbiter(string &sCMD_Result,Message *pMessage)
//<-dceag-c7-e->
{
    cout << "Need to implement command #7 - Terminate Orbiter" << endl;
}

//<-dceag-c8-b->

/** @brief COMMAND: #8 - Remove Screen From History */
/** The orbiter keeps a history of visible screens, allowing the user to go back.  See Go_Back.  This removes screens from the queue that should not available anymore.  An example is when a call comes in, the controllers are sent to an incoming call screen. */
/** @param #10 ID */
/** If specified, only screens that match this ID will be removed */
/** @param #159 PK_Screen */
/** The screen to remove */

void qOrbiter::CMD_Remove_Screen_From_History(string sID,int iPK_Screen,string &sCMD_Result,Message *pMessage)
//<-dceag-c8-e->
{
    cout << "Need to implement command #8 - Remove Screen From History" << endl;
    cout << "Parm #10 - ID=" << sID << endl;
    cout << "Parm #159 - PK_Screen=" << iPK_Screen << endl;

}

//<-dceag-c9-b->

/** @brief COMMAND: #9 - Scroll Grid */
/** Scroll a datagrid */
/** @param #1 Relative Level */
/** The grid will scroll this many lines.  If prefaced with a P, it will scroll this many pages.  If not specified, it will scroll 1 page. */
/** @param #3 PK_DesignObj */
/** The grid to scroll.  If not specified, any currently visible grids will scroll */
/** @param #30 PK_Direction */
/** The direction to scroll the grid */

void qOrbiter::CMD_Scroll_Grid(string sRelative_Level,string sPK_DesignObj,int iPK_Direction,string &sCMD_Result,Message *pMessage)
//<-dceag-c9-e->
{
    cout << "Need to implement command #9 - Scroll Grid" << endl;
    cout << "Parm #1 - Relative_Level=" << sRelative_Level << endl;
    cout << "Parm #3 - PK_DesignObj=" << sPK_DesignObj << endl;
    cout << "Parm #30 - PK_Direction=" << iPK_Direction << endl;

}

//<-dceag-c10-b->

/** @brief COMMAND: #10 - Move Highlight */
/** Move the current highlight pointer */
/** @param #1 Relative Level */
/** The grid will scroll this many lines.  If prefaced with a P, it will scroll this many pages.  If not specified, it will scroll 1 page. */
/** @param #3 PK_DesignObj */
/** The grid to scroll.  If not specified, any currently visible grids will scroll */
/** @param #30 PK_Direction */
/** The direction to move the highlight */

void qOrbiter::CMD_Move_Highlight(string sRelative_Level,string sPK_DesignObj,int iPK_Direction,string &sCMD_Result,Message *pMessage)
//<-dceag-c10-e->
{
    cout << "Need to implement command #10 - Move Highlight" << endl;
    cout << "Parm #1 - Relative_Level=" << sRelative_Level << endl;
    cout << "Parm #3 - PK_DesignObj=" << sPK_DesignObj << endl;
    cout << "Parm #30 - PK_Direction=" << iPK_Direction << endl;
}

//<-dceag-c13-b->

/** @brief COMMAND: #13 - Play Sound */
/** Plays a sound file on the orbiter */
/** @param #19 Data */
/** A pointer to a block of memory representing the sound file to play */
/** @param #20 Format */
/** Indicates what type of data is in the memory block.  1=wav, 2=mp3 */

void qOrbiter::CMD_Play_Sound(char *pData,int iData_Size,string sFormat,string &sCMD_Result,Message *pMessage)
//<-dceag-c13-e->
{
    cout << "Need to implement command #13 - Play Sound" << endl;
    cout << "Parm #19 - Data  (data value)" << endl;
    cout << "Parm #20 - Format=" << sFormat << endl;
}

//<-dceag-c14-b->

/** @brief COMMAND: #14 - Refresh */
/** Invalidates and redraws the current screen, optionally re-requesting data from a datagrid.  The OnLoad commands are not fired.  See Regen Screen. */
/** @param #15 DataGrid ID */
/** Normally refresh does not cause the orbiter to re-request data.  But if a specific grid ID is specified, that grid will be refreshed.  Specify * to re-request all grids on the current screen */

void qOrbiter::CMD_Refresh(string sDataGrid_ID,string &sCMD_Result,Message *pMessage)
//<-dceag-c14-e->
{
    cout << "Need to implement command #14 - Refresh" << endl;
    cout << "Parm #15 - DataGrid_ID=" << sDataGrid_ID << endl;
}

//<-dceag-c15-b->

/** @brief COMMAND: #15 - Regen Screen */
/** The screen is reloaded like the user was going to it for the first time.  The OnUnload and OnLoad commands are fired. */

void qOrbiter::CMD_Regen_Screen(string &sCMD_Result,Message *pMessage)
//<-dceag-c15-e->
{
    cout << "Need to implement command #15 - Regen Screen" << endl;
}

//<-dceag-c16-b->

/** @brief COMMAND: #16 - Requires Special Handling */
/** When a button needs to do something too sophisticated for a normal command, attach this command.  When the controller sees it, it will pass execution to a local handler that must be added to the Orbiter's code. */

void qOrbiter::CMD_Requires_Special_Handling(string &sCMD_Result,Message *pMessage)
//<-dceag-c16-e->
{
    cout << "Need to implement command #16 - Requires Special Handling" << endl;
}

//<-dceag-c17-b->

/** @brief COMMAND: #17 - Seek Data Grid */
/** Causes a datagrid to seek to a particular position. */
/** @param #9 Text */
/** If specified, the orbiter will jump to the first row which has a cell that starts with this text.  Specify Position X to use a column other than the first one. */
/** @param #11 Position X */
/** The column to jump to.  If Text is not blank, the column to search. */
/** @param #12 Position Y */
/** The row to jump to.  Ignored if Text is not blank */
/** @param #15 DataGrid ID */
/** The datagrid to scroll.  If not specified, the first visible one will be used */

void qOrbiter::CMD_Seek_Data_Grid(string sText,int iPosition_X,int iPosition_Y,string sDataGrid_ID,string &sCMD_Result,Message *pMessage)
//<-dceag-c17-e->
{
    cout << "Need to implement command #17 - Seek Data Grid" << endl;
    cout << "Parm #9 - Text=" << sText << endl;
    cout << "Parm #11 - Position_X=" << iPosition_X << endl;
    cout << "Parm #12 - Position_Y=" << iPosition_Y << endl;
    cout << "Parm #15 - DataGrid_ID=" << sDataGrid_ID << endl;
}

//<-dceag-c18-b->

/** @brief COMMAND: #18 - Set Graphic To Display */
/** All objects on screen can be either in "Normal" mode, "Selected mode", "Highlighted mode", or any number of "Alternate modes".  These are like "views".  A Selected mode may appear depressed, for example.  All children of this object will also be set. */
/** @param #3 PK_DesignObj */
/** The object to set */
/** @param #10 ID */
/** 0=standard mode, -1=selected -2=highlight a positive number is one of the alternates */

void qOrbiter::CMD_Set_Graphic_To_Display(string sPK_DesignObj,string sID,string &sCMD_Result,Message *pMessage)
//<-dceag-c18-e->
{
    cout << "Need to implement command #18 - Set Graphic To Display" << endl;
    cout << "Parm #3 - PK_DesignObj=" << sPK_DesignObj << endl;
    cout << "Parm #10 - ID=" << sID << endl;
}

//<-dceag-c20-b->

/** @brief COMMAND: #20 - Set Object Parameter */
/** changes one of the object's DesignObjParameters */
/** @param #3 PK_DesignObj */
/** The object to change */
/** @param #5 Value To Assign */
/** The value to assign */
/** @param #27 PK_DesignObjParameter */
/** The parameter */

void qOrbiter::CMD_Set_Object_Parameter(string sPK_DesignObj,string sValue_To_Assign,int iPK_DesignObjParameter,string &sCMD_Result,Message *pMessage)
//<-dceag-c20-e->
{
    cout << "Need to implement command #20 - Set Object Parameter" << endl;
    cout << "Parm #3 - PK_DesignObj=" << sPK_DesignObj << endl;
    cout << "Parm #5 - Value_To_Assign=" << sValue_To_Assign << endl;
    cout << "Parm #27 - PK_DesignObjParameter=" << iPK_DesignObjParameter << endl;
}

//<-dceag-c21-b->

/** @brief COMMAND: #21 - Set Object Position */
/** Change an objects's position on the screen */
/** @param #3 PK_DesignObj */
/** The object to move.  Can be a fully qualified object (x.y.z), or just the object ID, in which case the orbiter will find all such objects currently on screen. */
/** @param #11 Position X */
/**  */
/** @param #12 Position Y */
/**  */

void qOrbiter::CMD_Set_Object_Position(string sPK_DesignObj,int iPosition_X,int iPosition_Y,string &sCMD_Result,Message *pMessage)
//<-dceag-c21-e->
{
    cout << "Need to implement command #21 - Set Object Position" << endl;
    cout << "Parm #3 - PK_DesignObj=" << sPK_DesignObj << endl;
    cout << "Parm #11 - Position_X=" << iPosition_X << endl;
    cout << "Parm #12 - Position_Y=" << iPosition_Y << endl;

}

//<-dceag-c22-b->

/** @brief COMMAND: #22 - Set Object Size */
/** Change an object's size */
/** @param #3 PK_DesignObj */
/** The object to move.  Can be a fully qualified object (x.y.z), or just the object ID, in which case the orbiter will find all such objects currently on screen. */
/** @param #11 Position X */
/**  */
/** @param #12 Position Y */
/**  */

void qOrbiter::CMD_Set_Object_Size(string sPK_DesignObj,int iPosition_X,int iPosition_Y,string &sCMD_Result,Message *pMessage)
//<-dceag-c22-e->
{
    cout << "Need to implement command #22 - Set Object Size" << endl;
    cout << "Parm #3 - PK_DesignObj=" << sPK_DesignObj << endl;
    cout << "Parm #11 - Position_X=" << iPosition_X << endl;
    cout << "Parm #12 - Position_Y=" << iPosition_Y << endl;
}

//<-dceag-c23-b->

/** @brief COMMAND: #23 - Set Pos Rel To Parent */
/** Like Set Object Position, but the X and Y coordinates are assumed to be relative to the parent rather than absolute */
/** @param #3 PK_DesignObj */
/** The object to move.  Can be a fully qualified object (x.y.z), or just the object ID, in which case the orbiter will find all such objects currently on screen. */
/** @param #11 Position X */
/**  */
/** @param #12 Position Y */
/**  */

void qOrbiter::CMD_Set_Pos_Rel_To_Parent(string sPK_DesignObj,int iPosition_X,int iPosition_Y,string &sCMD_Result,Message *pMessage)
//<-dceag-c23-e->
{
    cout << "Need to implement command #23 - Set Pos Rel To Parent" << endl;
    cout << "Parm #3 - PK_DesignObj=" << sPK_DesignObj << endl;
    cout << "Parm #11 - Position_X=" << iPosition_X << endl;
    cout << "Parm #12 - Position_Y=" << iPosition_Y << endl;
}

//<-dceag-c24-b->

/** @brief COMMAND: #24 - Set Size Rel To Parent */
/** Change an object's size, relative to it's parent object */
/** @param #3 PK_DesignObj */
/** The object to move.  Can be a fully qualified object (x.y.z), or just the object ID, in which case the orbiter will find all such objects currently on screen. */
/** @param #11 Position X */
/** The percentage of the parent object's width.  100=the parent's full width. */
/** @param #12 Position Y */
/** The percentage of the parent object's height.  100=the parent's full height. */

void qOrbiter::CMD_Set_Size_Rel_To_Parent(string sPK_DesignObj,int iPosition_X,int iPosition_Y,string &sCMD_Result,Message *pMessage)
//<-dceag-c24-e->
{
    cout << "Need to implement command #24 - Set Size Rel To Parent" << endl;
    cout << "Parm #3 - PK_DesignObj=" << sPK_DesignObj << endl;
    cout << "Parm #11 - Position_X=" << iPosition_X << endl;
    cout << "Parm #12 - Position_Y=" << iPosition_Y << endl;
}

//<-dceag-c25-b->

/** @brief COMMAND: #25 - Set Text */
/** Change the text within a text object on the fly */
/** @param #3 PK_DesignObj */
/** The Design Object which contains the text object.  Can be a fully qualified object (x.y.z), or just the object ID, in which case the orbiter will find all such objects currently on screen. */
/** @param #9 Text */
/** The text to assign */
/** @param #25 PK_Text */
/** The text object in which to store the current input */

void qOrbiter::CMD_Set_Text(string sPK_DesignObj,string sText,int iPK_Text,string &sCMD_Result,Message *pMessage)
//<-dceag-c25-e->
{
    //   cout << "Need to implement command #25 - Set Text" << endl;
    //   cout << "Parm #3 - PK_DesignObj=" << sPK_DesignObj << endl;
    //  cout << "Parm #9 - Text=" << sText << endl;
    //  cout << "Parm #25 - PK_Text=" << iPK_Text << endl;
    emit commandResponseChanged(QString::fromStdString(sText));
    emit setText(QString::fromStdString(sPK_DesignObj),QString::fromStdString(sText), iPK_Text);
}

//<-dceag-c26-b->

/** @brief COMMAND: #26 - Set Bound Icon */
/** Sets an icon that is bound to status.  "Bind Icon" is put in the object's on load commands, and then this command sets the status at runtime. */
/** @param #5 Value To Assign */
/** The value corresponding to an alt graphic. */
/** @param #9 Text */
/** Text for the binding */
/** @param #14 Type */
/** The type of bound icon. */

void qOrbiter::CMD_Set_Bound_Icon(string sValue_To_Assign,string sText,string sType,string &sCMD_Result,Message *pMessage)
//<-dceag-c26-e->
{
    /*
    cout << "Need to implement command #26 - Set Bound Icon" << endl;
    cout << "Parm #5 - Value_To_Assign=" << sValue_To_Assign << endl;
    cout << "Parm #9 - Text=" << sText << endl;
    cout << "Parm #14 - Type=" << sType << endl;
    */

}

//<-dceag-c27-b->

/** @brief COMMAND: #27 - Set Variable */
/** Change the value of a variable */
/** @param #4 PK_Variable */
/** The variable to change */
/** @param #5 Value To Assign */
/** The value to assign */

void qOrbiter::CMD_Set_Variable(int iPK_Variable,string sValue_To_Assign,string &sCMD_Result,Message *pMessage)
//<-dceag-c27-e->
{
    cout << "Need to implement command #27 - Set Variable" << endl;
    cout << "Parm #4 - PK_Variable=" << iPK_Variable << endl;
    cout << "Parm #5 - Value_To_Assign=" << sValue_To_Assign << endl;
    //emit commandResponseChanged(QString::fromStdString(sValue_To_Assign));
}

//<-dceag-c28-b->

/** @brief COMMAND: #28 - Simulate Keypress */
/** Simulates that a key has been touched.  Touchable keys on screen can use this command to allow for simultaneous operation with keyboard or mouse.  Also works with the "Capture Keyboard to Variable" command. */
/** @param #26 PK_Button */
/** What key to simulate being pressed.  If 2 numbers are specified, separated by a comma, the second will be used if the Shift key is specified. */
/** @param #41 StreamID */
/** ID of stream to apply */
/** @param #50 Name */
/** The application to send the keypress to. If not specified, it goes to the DCE device. */

void qOrbiter::CMD_Simulate_Keypress(string sPK_Button,int iStreamID,string sName,string &sCMD_Result,Message *pMessage)
//<-dceag-c28-e->
{
    cout << "Need to implement command #28 - Simulate Keypress" << endl;
    cout << "Parm #26 - PK_Button=" << sPK_Button << endl;
    cout << "Parm #41 - StreamID=" << iStreamID << endl;
    cout << "Parm #50 - Name=" << sName << endl;
}

//<-dceag-c29-b->

/** @brief COMMAND: #29 - Simulate Mouse Click */
/** Simulates a mouse click or touch on the indicated x & y coordinates */
/** @param #11 Position X */
/** position X */
/** @param #12 Position Y */
/** position Y */
/** @param #41 StreamID */
/** ID of stream to apply */

void qOrbiter::CMD_Simulate_Mouse_Click(int iPosition_X,int iPosition_Y,int iStreamID,string &sCMD_Result,Message *pMessage)
//<-dceag-c29-e->
{
    cout << "Need to implement command #29 - Simulate Mouse Click" << endl;
    cout << "Parm #11 - Position_X=" << iPosition_X << endl;
    cout << "Parm #12 - Position_Y=" << iPosition_Y << endl;
    cout << "Parm #41 - StreamID=" << iStreamID << endl;
}

//<-dceag-c30-b->

/** @brief COMMAND: #30 - Stop Sound */
/** If a sound file is being played, it will be stopped. */

void qOrbiter::CMD_Stop_Sound(string &sCMD_Result,Message *pMessage)
//<-dceag-c30-e->
{
    cout << "Need to implement command #30 - Stop Sound" << endl;
}

//<-dceag-c31-b->

/** @brief COMMAND: #31 - Store Variables */
/** The orbiter will store a snapshot of the variables at this moment, and if the user returns to this screen with a go back, it will restore the variables to this value. */

void qOrbiter::CMD_Store_Variables(string &sCMD_Result,Message *pMessage)
//<-dceag-c31-e->
{
    cout << "Need to implement command #31 - Store Variables" << endl;
}

//<-dceag-c32-b->

/** @brief COMMAND: #32 - Update Object Image */
/** Changes the background image within an object */
/** @param #3 PK_DesignObj */
/** The object in which to put the bitmap */
/** @param #14 Type */
/** 1=bmp, 2=jpg, 3=png */
/** @param #19 Data */
/** The contents of the bitmap, like reading from the file into a memory buffer */
/** @param #23 Disable Aspect Lock */
/** If 1, the image will be stretched to fit the object */

void qOrbiter::CMD_Update_Object_Image(string sPK_DesignObj,string sType,char *pData,int iData_Size,string sDisable_Aspect_Lock,string &sCMD_Result,Message *pMessage)
//<-dceag-c32-e->
{

    cout << "Need to implement command #32 - Update Object Image" << endl;
    cout << "Parm #3 - PK_DesignObj=" << sPK_DesignObj << endl;
    cout << "Parm #14 - Type=" << sType << endl;
    cout << "Parm #19 - Data  (data value)" << endl;
    cout << "Parm #23 - Disable_Aspect_Lock=" << sDisable_Aspect_Lock << endl;

    emit objectUpdate(QByteArray(pData, iData_Size));

    //    QByteArray imgData;
    //    qDebug() << iData_Size;
    //    imgData.setRawData(pData,iData_Size);
    //    QImage t;
    //    t.loadFromData(imgData, "4");
    //    if(!t.isNull())

    //    else
    //        emit mediaResponseChanged("Screenshot returned is invalid!");
    //    imgData=NULL;

}

//<-dceag-c58-b->

/** @brief COMMAND: #58 - Set Current User */
/** Sets what user is currently using the orbiter. */
/** @param #17 PK_Users */
/** The user currently using the orbiter. */

void qOrbiter::CMD_Set_Current_User(int iPK_Users,string &sCMD_Result,Message *pMessage)
//<-dceag-c58-e->
{
    cout << "Need to implement command #58 - Set Current User" << endl;
    cout << "Parm #17 - PK_Users=" << iPK_Users << endl;
}

//<-dceag-c59-b->

/** @brief COMMAND: #59 - Set Entertainment Area */
/** If you don't know the location, you can also set just the entertainment area */
/** @param #45 PK_EntertainArea */
/** The current entertainment area where the orbiter is. */

void qOrbiter::CMD_Set_Entertainment_Area(string sPK_EntertainArea,string &sCMD_Result,Message *pMessage)
//<-dceag-c59-e->
{
    cout << "Need to implement command #59 - Set Entertainment Area" << endl;
    cout << "Parm #45 - PK_EntertainArea=" << sPK_EntertainArea << endl;
}

//<-dceag-c66-b->

/** @brief COMMAND: #66 - Select Object */
/** The same as clicking on an object. */
/** @param #3 PK_DesignObj */
/** The object to select. */
/** @param #16 PK_DesignObj_CurrentScreen */
/** Will only happen if this is the current screen. */
/** @param #102 Time */
/** If specified, rather than happening immediately it will happen in x seconds. */

void qOrbiter::CMD_Select_Object(string sPK_DesignObj,string sPK_DesignObj_CurrentScreen,string sTime,string &sCMD_Result,Message *pMessage)
//<-dceag-c66-e->
{
    cout << "Need to implement command #66 - Select Object" << endl;
    cout << "Parm #3 - PK_DesignObj=" << sPK_DesignObj << endl;
    cout << "Parm #16 - PK_DesignObj_CurrentScreen=" << sPK_DesignObj_CurrentScreen << endl;
    cout << "Parm #102 - Time=" << sTime << endl;
}

//<-dceag-c67-b->

/** @brief COMMAND: #67 - Spawn Application */
/** Spawn the given application.  Mainly used for windows orbiters. */
/** @param #13 Filename */
/** The name of the executable file to spawn */
/** @param #50 Name */
/** A name that we'll remember the application by for future kill commands */
/** @param #51 Arguments */
/** Command arguments, tab delimited */
/** @param #94 SendOnFailure */
/** Send this messages if the process exited with failure error code. */
/** @param #95 SendOnSuccess */
/** Send this messages if the process exited with success error code. */
/** @param #115 Show logo */
/** If this is set then we will first select the logo  before spawning the application. */
/** @param #120 Retransmit */
/** If false, and if Exclusive is true and another instance is killed, the 'send messages on termination' will not be sent. */
/** @param #126 Exclusive */
/** If true, then kill other apps with this same name */
/** @param #241 Detach */
/** Detach application after spawning / Don't kill this app on reload. */

void qOrbiter::CMD_Spawn_Application(string sFilename,string sName,string sArguments,string sSendOnFailure,string sSendOnSuccess,bool bShow_logo,bool bRetransmit,bool bExclusive,bool bDetach,string &sCMD_Result,Message *pMessage)
//<-dceag-c67-e->
{
    cout << "Need to implement command #67 - Spawn Application" << endl;
    cout << "Parm #13 - Filename=" << sFilename << endl;
    cout << "Parm #50 - Name=" << sName << endl;
    cout << "Parm #51 - Arguments=" << sArguments << endl;
    cout << "Parm #94 - SendOnFailure=" << sSendOnFailure << endl;
    cout << "Parm #95 - SendOnSuccess=" << sSendOnSuccess << endl;
    cout << "Parm #115 - Show_logo=" << bShow_logo << endl;
    cout << "Parm #120 - Retransmit=" << bRetransmit << endl;
    cout << "Parm #126 - Exclusive=" << bExclusive << endl;
    cout << "Parm #241 - Detach=" << bDetach << endl;
}

//<-dceag-c72-b->

/** @brief COMMAND: #72 - Surrender to OS */
/** Let the O/S take over.  This is useful with the Orbiter running on the media director's desktop as a full screen app, and media is inserted, or the user starts a computer application on the mobile phone.  The orbiter will then let the other application ta */
/** @param #8 On/Off */
/** 1=Hide and let the OS take over.  0=The orbiter comes up again. */
/** @param #54 Fully release keyboard */
/** Only applies if on/off is 1.  If this is false, the orbiter will still filter keystrokes, looking for macros to implement, and only pass on keys that it doesn't catch.  If true, it will pass all keys.  True also releases the mouse. */
/** @param #225 Always */
/** If true, the mouse will always be ignored */

void qOrbiter::CMD_Surrender_to_OS(string sOnOff,bool bFully_release_keyboard,bool bAlways,string &sCMD_Result,Message *pMessage)
//<-dceag-c72-e->
{
    cout << "Need to implement command #72 - Surrender to OS" << endl;
    cout << "Parm #8 - OnOff=" << sOnOff << endl;
    cout << "Parm #54 - Fully_release_keyboard=" << bFully_release_keyboard << endl;
    cout << "Parm #225 - Always=" << bAlways << endl;
}

//<-dceag-c77-b->

/** @brief COMMAND: #77 - Set Current Room */
/** If you don't know the location, you can also set just the room */
/** @param #57 PK_Room */
/** The room */

void qOrbiter::CMD_Set_Current_Room(int iPK_Room,string &sCMD_Result,Message *pMessage)
//<-dceag-c77-e->
{
    cout << "Need to implement command #77 - Set Current Room" << endl;
    cout << "Parm #57 - PK_Room=" << iPK_Room << endl;

    // CMD_Set_Current_Room_DL setRoom((long)m_dwPK_Device, "9", iPK_Room);
    //  SendCommand(setRoom);

}

//<-dceag-c85-b->

/** @brief COMMAND: #85 - Reset Highlight */
/** Resets the currently highlighted object.  Do this when you hide or unhide blocks that have tab stops. */
/** @param #3 PK_DesignObj */
/** If specified, this object will be highlighted.  Otherwise the first detected one. */

void qOrbiter::CMD_Reset_Highlight(string sPK_DesignObj,string &sCMD_Result,Message *pMessage)
//<-dceag-c85-e->
{
    cout << "Need to implement command #85 - Reset Highlight" << endl;
    cout << "Parm #3 - PK_DesignObj=" << sPK_DesignObj << endl;
}

//<-dceag-c88-b->

/** @brief COMMAND: #88 - Set Current Location */
/** Sets the location the orbiter is in.  The location is a combination of room and entertainment area. */
/** @param #65 LocationID */
/** The location ID is a sequential number created by OrbiterGen which defines a combination of room and entertainment area. */

void qOrbiter::CMD_Set_Current_Location(int iLocationID,string &sCMD_Result,Message *pMessage)
//<-dceag-c88-e->
{
    cout << "Need to implement command #88 - Set Current Location" << endl;
    cout << "Parm #65 - LocationID=" << iLocationID << endl;
}

//<-dceag-c192-b->

/** @brief COMMAND: #192 - On */
/** Turn the device on */
/** @param #97 PK_Pipe */
/** Normally when a device is turned on all the inputs and outputs are selected automatically.  If this parameter is specified, only the settings along this pipe will be set. */
/** @param #98 PK_Device_Pipes */
/** Normally when a device is turned on the corresponding "pipes" are enabled by default. if this parameter is blank.  If this parameter is 0, no pipes will be enabled.  This can also be a comma seperated list of devices, meaning only the pipes to those devic */

void qOrbiter::CMD_On(int iPK_Pipe,string sPK_Device_Pipes,string &sCMD_Result,Message *pMessage)
//<-dceag-c192-e->
{
    cout << "Need to implement command #192 - On" << endl;
    cout << "Parm #97 - PK_Pipe=" << iPK_Pipe << endl;
    cout << "Parm #98 - PK_Device_Pipes=" << sPK_Device_Pipes << endl;
    externalOn();
}

//<-dceag-c193-b->

/** @brief COMMAND: #193 - Off */
/** Turn the device off */
/** @param #97 PK_Pipe */
/** Normally when a device is turned on all the inputs and outputs are selected automatically.  If this parameter is specified, only the settings along this pipe will be set. */

void qOrbiter::CMD_Off(int iPK_Pipe,string &sCMD_Result,Message *pMessage)
//<-dceag-c193-e->
{
    cout << "Need to implement command #193 - Off" << endl;
    cout << "Parm #97 - PK_Pipe=" << iPK_Pipe << endl;
    externalOff();
}

//<-dceag-c238-b->

/** @brief COMMAND: #238 - Continuous Refresh */
/** Continuously refresh the current page.  Used when the page contains constantly changing data. */
/** @param #102 Time */
/** The interval time in seconds */

void qOrbiter::CMD_Continuous_Refresh(string sTime,string &sCMD_Result,Message *pMessage)
//<-dceag-c238-e->
{
    cout << "Need to implement command #238 - Continuous Refresh" << endl;
    cout << "Parm #102 - Time=" << sTime << endl;
}

//<-dceag-c242-b->

/** @brief COMMAND: #242 - Set Now Playing */
/** Used by the media engine to set the "now playing" text on an orbiter.  If the orbiter is bound to the remote for an entertainment area it will get more updates than just media,  like cover art, but this is the basic information that is visible on screens */
/** @param #3 PK_DesignObj */
/** 4 comma delimited objects: normal remote, popup remote, file list remote, popup file list remote, guide */
/** @param #5 Value To Assign */
/** The description of the media */
/** @param #9 Text */
/** The description of the current section (ie chapter in a dvd, etc.) */
/** @param #29 PK_MediaType */
/** The type of media playing */
/** @param #41 StreamID */
/** The ID of the current stream */
/** @param #48 Value */
/** The track number or position in the playlist */
/** @param #50 Name */
/** The name of the window for the application to remain in the foreground */
/** @param #103 List PK Device */
/** (comma-delimited list): The current source device, video device, the current audio device, 1/0 if audio device supports discrete volume */
/** @param #120 Retransmit */
/** If true, it will re-request the plist (current playlist) grid */

void qOrbiter::CMD_Set_Now_Playing(string sPK_DesignObj,string sValue_To_Assign,string sText,int iPK_MediaType,int iStreamID,int iValue,string sName,string sList_PK_Device,bool bRetransmit,string &sCMD_Result,Message *pMessage)
//<-dceag-c242-e->
{
    cout << "Need to implement command #242 - Set Now Playing" << endl;
    cout << "Parm #3 - PK_DesignObj=" << sPK_DesignObj << endl;
    cout << "Parm #5 - Value_To_Assign=" << sValue_To_Assign << endl;
    cout << "Parm #9 - Text=" << sText << endl;
    cout << "Parm #29 - PK_MediaType=" << iPK_MediaType << endl;
    cout << "Parm #41 - StreamID=" << iStreamID << endl;
    cout << "Parm #48 - Value=" << iValue << endl;
    cout << "Parm #50 - Name=" << sName << endl;
    cout << "Parm #103 - List_PK_Device=" << sList_PK_Device << endl;
    cout << "Parm #120 - Retransmit=" << bRetransmit << endl;

    if(m_bIsOSD){
        m_sNowPlayingWindow =sName;
        if(m_bContainsVideo)
            CMD_Activate_Window(sName);

    }

    if(i_current_mediaType !=iPK_MediaType){
        emit clearPlaylist();
    }
    i_current_mediaType=iPK_MediaType;

    setMediaType(iPK_MediaType);
    //**TODO - create a function that keeps a running track of the current room. like, the location info class or something.
    // it should unify the current location and media data in to one easily accesible item that update automatically on changes.


    map <int, string> mds;
    map <int, string> qmds;
    GetDevicesByTemplate(DEVICETEMPLATE_OnScreen_Orbiter_CONST, &mds);
    GetDevicesByTemplate(DEVICETEMPLATE_OnScreen_qOrbiter_CONST, &qmds);

    /* string::size_type pos=0;
    m_dwPK_Device_NowPlaying = atoi(StringUtils::Tokenize(sList_PK_Device,",",pos).c_str());
    m_dwPK_Device_NowPlaying_Video = atoi(StringUtils::Tokenize(sList_PK_Device,",",pos).c_str());
    m_dwPK_Device_NowPlaying_Audio = atoi(StringUtils::Tokenize(sList_PK_Device,",",pos).c_str());
    m_dwPK_Device_CaptureCard = atoi(StringUtils::Tokenize(sList_PK_Device,",",pos).c_str());
   m_iStreamID=iStreamID;
    m_iPK_MediaType=iPK_MediaType;
    m_sNowPlaying_Window = sName;
    m_sNowPlaying = SubstituteVariables(sValue_To_Assign, NULL, 0, 0);
    m_sNowPlaying_Section = SubstituteVariables(sText, NULL, 0, 0);
    */
    string::size_type pos=0;
    m_dwPK_Device_NowPlaying = atoi(StringUtils::Tokenize(sList_PK_Device,",",pos).c_str());
    m_dwPK_Device_NowPlaying_Video = atoi(StringUtils::Tokenize(sList_PK_Device,",",pos).c_str());
    m_dwPK_Device_NowPlaying_Audio = atoi(StringUtils::Tokenize(sList_PK_Device,",",pos).c_str());
    m_dwPK_Device_CaptureCard = atoi(StringUtils::Tokenize(sList_PK_Device,",",pos).c_str());

    m_bPK_Device_NowPlaying_Audio_DiscreteVolume = atoi(StringUtils::Tokenize(sList_PK_Device,",",pos).c_str())==1;
    emit discreteAudioChanged(m_bPK_Device_NowPlaying_Audio_DiscreteVolume);

    m_bContainsVideo = atoi(StringUtils::Tokenize(sList_PK_Device,",",pos).c_str())==1;
    emit containsVideo(m_bContainsVideo);

    m_bUsingLiveAVPath = atoi(StringUtils::Tokenize(sList_PK_Device,",",pos).c_str())==1;
    emit liveAvPath(m_bUsingLiveAVPath);
    getVolume();

    pos=0;
    m_iPK_Screen_Remote=atoi(StringUtils::Tokenize(sPK_DesignObj,",",pos).c_str());
    m_iPK_DesignObj_Remote_Popup=atoi(StringUtils::Tokenize(sPK_DesignObj,",",pos).c_str());  // ON UI2 the leftmost popup menu on the main menu
    m_iPK_Screen_FileList=atoi(StringUtils::Tokenize(sPK_DesignObj,",",pos).c_str());
    m_iPK_Screen_RemoteOSD=atoi(StringUtils::Tokenize(sPK_DesignObj,",",pos).c_str());
    m_iPK_Screen_OSD_Speed=atoi(StringUtils::Tokenize(sPK_DesignObj,",",pos).c_str());
    m_iPK_Screen_OSD_Track=atoi(StringUtils::Tokenize(sPK_DesignObj,",",pos).c_str());

    DeviceData_Base *npd = this->m_pData->m_AllDevices.m_mapDeviceData_Base_Find(m_dwPK_Device_NowPlaying);

    QVariantMap infoMap;
    if(npd && iPK_MediaType != 0){
        QVariantMap cmdMap;
        for(std::map<int, std::string>::iterator cmd_it  =npd->m_mapCommands.begin(); cmd_it!=npd->m_mapCommands.end(); cmd_it++){
            cmdMap.insert(QString::fromStdString(cmd_it->second), cmd_it->first);
        }

        int dt = npd->m_dwPK_DeviceTemplate;
        int cat = npd->m_dwPK_DeviceCategory;
        int dv = npd->m_dwPK_Device;
        infoMap.insert("device", dv);
        infoMap.insert("isEmbedded", npd->m_bIsEmbedded);
        infoMap.insert("device_template", dt);
        infoMap.insert("device_category", cat);
        infoMap.insert("name", QString::fromStdString(npd->m_sDescription));
        infoMap.insert("screen_remote", m_iPK_Screen_Remote);
        infoMap.insert("screen_remote_osd", m_iPK_Screen_RemoteOSD);
        infoMap.insert("remote_popup_designobj", m_iPK_DesignObj_Remote_Popup );
        infoMap.insert("screen_file_list", m_iPK_Screen_FileList);
    } else {
        infoMap.insert("isEmbedded",false);
        infoMap.insert("device_template", -1);
        infoMap.insert("category", -1);
        infoMap.insert("name", "");
    }

    QVariantList np_deviceList;
    QVariantMap deviceMap;
    deviceMap.insert("Now Playing", m_dwPK_Device_NowPlaying);
    deviceMap.insert("Video Device", m_dwPK_Device_NowPlaying_Video);
    deviceMap.insert("Now Playing Audio", m_dwPK_Device_NowPlaying_Audio);
    deviceMap.insert("Capture Card", m_dwPK_Device_CaptureCard);
    deviceMap.insert("Now Playing Discreet Audio", m_bPK_Device_NowPlaying_Audio_DiscreteVolume);

    np_deviceList.append(deviceMap);
    np_deviceList.append(infoMap);
    emit nowPlayingDeviceListChanged(np_deviceList);

    qDebug() << np_deviceList;

    if(m_dwPK_Device_CaptureCard != 0)   {emit monitorStatusChanged(true); }


    QString scrn =  QString::number(m_iPK_Screen_Remote);
    QString osdScrn = "Screen_"+QString::number(m_iPK_Screen_RemoteOSD)+".qml";

    internal_streamID = iStreamID;
    emit np_playlistIndexChanged(iValue);
    if (iPK_MediaType == 0){                            //Tell the gui media has stopped on our side.
        emit resetNowPlaying();
        emit setNowPlaying(false);
        emit gotoQml("Screen_1.qml");
        emit gotoOsdQml("Screen_1.qml");
        emit setRemotePopup(0);
        b_mediaPlaying = false;

        currentScreen = "Screen_1.qml";
        internal_streamID = iStreamID;
        emit streamIdChanged(iStreamID);
        emit mediaTypeChanged(iPK_MediaType);
        emit stopTimeCode();
        emit clearPlaylist();
        emit clearTVplaylist();
    } else {

        if(iPK_MediaType ==4|| iPK_MediaType==5){
            QString port = QString::fromStdString(GetCurrentDeviceData(m_dwPK_Device_NowPlaying, 171));
            checkTimeCode(m_dwPK_Device_NowPlaying);
            emit newTCport(port.toInt());
        }

        emit setNowPlaying(true);
        currentScreen = "Screen_"+scrn+".qml";
        emit gotoQml(currentScreen); /*!< \note This line set the command for the actual screen change */
        emit currentScreenChanged(currentScreen); /*!< \note This line sets the media return to screen */
        emit gotoOsdQml(osdScrn);

        qDebug() << "osd " << m_iPK_Screen_RemoteOSD;
        emit setRemotePopup(m_iPK_DesignObj_Remote_Popup);
        internal_streamID = iStreamID;

        emit subtitleChanged((QString::fromStdString(sText)));
        emit streamIdChanged(iStreamID);
        emit mediaTypeChanged(iPK_MediaType);
        emit np_playlistIndexChanged(iValue);

        QString md1 = QString::fromStdString(sValue_To_Assign);
        QStringList mdlist;
        mdlist= md1.split(QRegExp("\\n"), QString::SkipEmptyParts);

        if (mdlist.count() == 2){
            emit np_title1Changed(mdlist.at(0));
            emit np_title2Changed(mdlist.at(1));
            //nowPlayingButton->setTitle(mdlist.at(0));
            // nowPlayingButton->setTitle2(mdlist.at(1));
        } else {
            emit np_title1Changed(QString::fromStdString(sValue_To_Assign));
            emit np_title2Changed("");
        }
    }

    if(iPK_MediaType ==1){
        //channel ID will be sent to the playlist parser to find our position of the current data
        emit np_channelID(QString::number(iValue));
        emit np_network(QString::fromStdString(sValue_To_Assign));
        //the remaining two signals are sent to the now playing class immediatly
        emit np_program(QString::fromStdString(sText));
        emit mythTvUpdate("i"+QString::number(iValue));

        if(bRetransmit == 0 ){
            emit epgDone();
        }
        b_mediaPlaying = true;
    }
    //todo - fix livetv playlist to adjust position from clicking on the grid.
    else if(iPK_MediaType== 11){
        // emit np_channelID(QString::number(iValue));
        // emit np_network(QString::fromStdString(sValue_To_Assign));
        if(bRetransmit == 0){

        }
        b_mediaPlaying = true;

    }  else if(iPK_MediaType == 5) {
        b_mediaPlaying = true;
        emit np_title1Changed(QString::fromStdString(sValue_To_Assign ));
        emit np_title2Changed(QString::fromStdString(sText));
        emit playlistPositionChanged(iValue);
        GetNowPlayingAttributes();
        if(bRetransmit==1){
            emit clearPlaylist();
        }
    }  else if(iPK_MediaType == 4) {
        b_mediaPlaying = true;
        emit playlistPositionChanged(iValue);
        GetNowPlayingAttributes();
        emit clearPlaylist();

    }

}

//<-dceag-c254-b->

/** @brief COMMAND: #254 - Bind Icon */
/** Used to make a button have an icon that reflects a current state, such as the user's status, the house mode, etc.  This is accomplished by creating an object with multiple alternate versions, and then executing a "Set  Bound Icon" to select the right one. */
/** @param #3 PK_DesignObj */
/** The object which contains the icon, or whose child objects contain the icon. */
/** @param #14 Type */
/** The type of binding, like "housemode", "userstatus_39288", etc. */
/** @param #104 Child */
/** If true, it will set the property for the child object(s), rather than the designated object. */

void qOrbiter::CMD_Bind_Icon(string sPK_DesignObj,string sType,bool bChild,string &sCMD_Result,Message *pMessage)
//<-dceag-c254-e->
{

    cout << "Need to implement command #254 - Bind Icon" << endl;
    cout << "Parm #3 - PK_DesignObj=" << sPK_DesignObj << endl;
    cout << "Parm #14 - Type=" << sType << endl;
    cout << "Parm #104 - Child=" << bChild << endl;
    qWarning() << "Bind icon, item #" << sPK_DesignObj.c_str();
    qWarning() << "Bind icon, type: " << sType.c_str();
}

//<-dceag-c258-b->

/** @brief COMMAND: #258 - Clear Selected Devices */
/** Floorplans, in particular, rely on a vector of selected devices, allowing the user to select more than one.  This command clears that list, removing any selected devices.  It can optionally cause the Object passed in as a parameter to be refreshed. */
/** @param #3 PK_DesignObj */
/** If specified, the object referenced here will be invalidated and redrawn. */

void qOrbiter::CMD_Clear_Selected_Devices(string sPK_DesignObj,string &sCMD_Result,Message *pMessage)
//<-dceag-c258-e->
{
    cout << "Need to implement command #258 - Clear Selected Devices" << endl;
    cout << "Parm #3 - PK_DesignObj=" << sPK_DesignObj << endl;
}

//<-dceag-c260-b->

/** @brief COMMAND: #260 - Set Main Menu */
/** Sets the Main Menu to 'Normal', 'Sleeping' or 'Screen Saver', optionally assigning new screens to those values. */
/** @param #9 Text */
/** Can be N, S, or V to set to the Normal, Sleeping, or Screen Saver, optionally followed by an = to assign a new screen to that menu.  e.g. N or N=1872.0.0 */

void qOrbiter::CMD_Set_Main_Menu(string sText,string &sCMD_Result,Message *pMessage)
//<-dceag-c260-e->
{
    cout << "Need to implement command #260 - Set Main Menu" << endl;
    cout << "Parm #9 - Text=" << sText << endl;
}

//<-dceag-c265-b->

/** @brief COMMAND: #265 - Quit */
/** Exits the orbiter application */

void qOrbiter::CMD_Quit(string &sCMD_Result,Message *pMessage)
//<-dceag-c265-e->
{
    cout << "Need to implement command #265 - Quit" << endl;
    deinitialize();
}

//<-dceag-c324-b->

/** @brief COMMAND: #324 - Set Timeout */
/** Specifies when a given screen will timeout, executing the timeout actions.  This will also reset a pending timeout */
/** @param #3 PK_DesignObj */
/** The screen to set the timeout on.  If blank the current screen. */
/** @param #102 Time */
/** The timeout in seconds.  0 or blank means no timeout. */

void qOrbiter::CMD_Set_Timeout(string sPK_DesignObj,string sTime,string &sCMD_Result,Message *pMessage)
//<-dceag-c324-e->
{
    cout << "Need to implement command #324 - Set Timeout" << endl;
    cout << "Parm #3 - PK_DesignObj=" << sPK_DesignObj << endl;
    cout << "Parm #102 - Time=" << sTime << endl;
}

//<-dceag-c325-b->

/** @brief COMMAND: #325 - Keep Screen On */
/** Allow or don't allow the screen to blank with the screen saver. */
/** @param #8 On/Off */
/** If other than "0", the screen saver will be disabled. */

void qOrbiter::CMD_Keep_Screen_On(string sOnOff,string &sCMD_Result,Message *pMessage)
//<-dceag-c325-e->
{
    cout << "Need to implement command #325 - Keep Screen On" << endl;
    cout << "Parm #8 - OnOff=" << sOnOff << endl;
}

//<-dceag-c330-b->

/** @brief COMMAND: #330 - Set Mouse Pointer Over Object */
/** Positions the on-screen mouse pointer centered over a certain object */
/** @param #3 PK_DesignObj */
/** The object to center the mouse over. */

void qOrbiter::CMD_Set_Mouse_Pointer_Over_Object(string sPK_DesignObj,string &sCMD_Result,Message *pMessage)
//<-dceag-c330-e->
{
    cout << "Need to implement command #330 - Set Mouse Pointer Over Object" << endl;
    cout << "Parm #3 - PK_DesignObj=" << sPK_DesignObj << endl;
}

//<-dceag-c354-b->

/** @brief COMMAND: #354 - Show Mouse Pointer */
/** Shows or hides the mouse pointer. */
/** @param #8 On/Off */
/** 1=show it, 0=hide it. */

void qOrbiter::CMD_Show_Mouse_Pointer(string sOnOff,string &sCMD_Result,Message *pMessage)
//<-dceag-c354-e->
{
    cout << "Need to implement command #354 - Show Mouse Pointer" << endl;
    cout << "Parm #8 - OnOff=" << sOnOff << endl;
}

//<-dceag-c366-b->

/** @brief COMMAND: #366 - Activate Window */
/** ActivateApplication - Used by Linux On Screeen Orbiters only */
/** @param #50 Name */
/** Name as known by ratpoison. */

void qOrbiter::CMD_Activate_Window(string sName,string &sCMD_Result,Message *pMessage)
//<-dceag-c366-e->
{
    cout << "Need to implement command #366 - Activate Window" << endl;
    cout << "Parm #50 - Name=" << sName << endl;
}

//<-dceag-c389-b->

/** @brief COMMAND: #389 - Send Message */
/** Sends a message stored in a parameter as a text object. */
/** @param #9 Text */
/** The message in command line-style format */
/** @param #144 Go Back */
/** Go back after sending the command if it does not contain another goto screen or go back */

void qOrbiter::CMD_Send_Message(string sText,bool bGo_Back,string &sCMD_Result,Message *pMessage)
//<-dceag-c389-e->
{
    cout << "Need to implement command #389 - Send Message" << endl;
    cout << "Parm #9 - Text=" << sText << endl;
    cout << "Parm #144 - Go_Back=" << bGo_Back << endl;
}

//<-dceag-c397-b->

/** @brief COMMAND: #397 - Show Popup */
/** Shows a screen as a popup, at position x, y */
/** @param #3 PK_DesignObj */
/** The ID of the screen */
/** @param #11 Position X */
/** X position */
/** @param #12 Position Y */
/** Y position */
/** @param #16 PK_DesignObj_CurrentScreen */
/** If specified the popup will be local to this screen, otherwise it will be global.  Global and local popups are treated separately */
/** @param #50 Name */
/** The popup name */
/** @param #126 Exclusive */
/** Hide any other popups that are also visible, unless don't hide is set. */
/** @param #127 Dont Auto Hide */
/** If true, this popup will not be automatically hidden when the screen changes or another exclusive is shown.  It must be explicitly hidden. */

void qOrbiter::CMD_Show_Popup(string sPK_DesignObj,int iPosition_X,int iPosition_Y,string sPK_DesignObj_CurrentScreen,string sName,bool bExclusive,bool bDont_Auto_Hide,string &sCMD_Result,Message *pMessage)
//<-dceag-c397-e->
{
    cout << "Need to implement command #397 - Show Popup" << endl;
    cout << "Parm #3 - PK_DesignObj=" << sPK_DesignObj << endl;
    cout << "Parm #11 - Position_X=" << iPosition_X << endl;
    cout << "Parm #12 - Position_Y=" << iPosition_Y << endl;
    cout << "Parm #16 - PK_DesignObj_CurrentScreen=" << sPK_DesignObj_CurrentScreen << endl;
    cout << "Parm #50 - Name=" << sName << endl;
    cout << "Parm #126 - Exclusive=" << bExclusive << endl;
    cout << "Parm #127 - Dont_Auto_Hide=" << bDont_Auto_Hide << endl;
}

//<-dceag-c398-b->

/** @brief COMMAND: #398 - Remove Popup */
/** Hides a popup. */
/** @param #16 PK_DesignObj_CurrentScreen */
/** (optional).  The screen on which it's a local popup */
/** @param #50 Name */
/** The name of the popup.  If not specified all popups will be removed */

void qOrbiter::CMD_Remove_Popup(string sPK_DesignObj_CurrentScreen,string sName,string &sCMD_Result,Message *pMessage)
//<-dceag-c398-e->
{
    cout << "Need to implement command #398 - Remove Popup" << endl;
    cout << "Parm #16 - PK_DesignObj_CurrentScreen=" << sPK_DesignObj_CurrentScreen << endl;
    cout << "Parm #50 - Name=" << sName << endl;
}

//<-dceag-c399-b->

/** @brief COMMAND: #399 - Show Shortcuts */
/** Shows keyboard shortcuts for 10 seconds or until the screen changes. */

void qOrbiter::CMD_Show_Shortcuts(string &sCMD_Result,Message *pMessage)
//<-dceag-c399-e->
{
    cout << "Need to implement command #399 - Show Shortcuts" << endl;
    showHelp();
}

//<-dceag-c401-b->

/** @brief COMMAND: #401 - Show File List */
/** Shows the file list */
/** @param #29 PK_MediaType */
/** The type of media the user wants to browse. */

void qOrbiter::CMD_Show_File_List(int iPK_MediaType,string &sCMD_Result,Message *pMessage)
//<-dceag-c401-e->
{

    emit showFileListMediaType(iPK_MediaType);
    requestTypes(iPK_MediaType);
    i_currentGridType=iPK_MediaType;
    gridPaused = false;
    currentScreen= "Screen_47.qml";
    emit gotoQml("Screen_47.qml");
    setGridStatus(true);
    b_cancelRequest = false;

    emit commandComplete();
    emit commandResponseChanged("Show File List Complete, Calling request Media Grid");

}

//<-dceag-c402-b->

/** @brief COMMAND: #402 - Use Popup Remote Controls */
/** If this command is executed the remote controls will be displayed as popups. */
/** @param #11 Position X */
/** The location of the popup */
/** @param #12 Position Y */
/** The location of the popup */
/** @param #16 PK_DesignObj_CurrentScreen */
/** The screen on which to put the popup */

void qOrbiter::CMD_Use_Popup_Remote_Controls(int iPosition_X,int iPosition_Y,string sPK_DesignObj_CurrentScreen,string &sCMD_Result,Message *pMessage)
//<-dceag-c402-e->
{
    cout << "Need to implement command #402 - Use Popup Remote Controls" << endl;
    cout << "Parm #11 - Position_X=" << iPosition_X << endl;
    cout << "Parm #12 - Position_Y=" << iPosition_Y << endl;
    cout << "Parm #16 - PK_DesignObj_CurrentScreen=" << sPK_DesignObj_CurrentScreen << endl;
}

//<-dceag-c403-b->

/** @brief COMMAND: #403 - Use Popup File List */
/** If this command is executed the file lists will be displayed as popups. */
/** @param #11 Position X */
/** The location of the popup */
/** @param #12 Position Y */
/** The location of the popup */
/** @param #16 PK_DesignObj_CurrentScreen */
/** The screen to put the popup on */

void qOrbiter::CMD_Use_Popup_File_List(int iPosition_X,int iPosition_Y,string sPK_DesignObj_CurrentScreen,string &sCMD_Result,Message *pMessage)
//<-dceag-c403-e->
{
    cout << "Need to implement command #403 - Use Popup File List" << endl;
    cout << "Parm #11 - Position_X=" << iPosition_X << endl;
    cout << "Parm #12 - Position_Y=" << iPosition_Y << endl;
    cout << "Parm #16 - PK_DesignObj_CurrentScreen=" << sPK_DesignObj_CurrentScreen << endl;
}

//<-dceag-c405-b->

/** @brief COMMAND: #405 - Scale this object */
/** If you add this command to the startup list of an object it will cause Orbiter Gen to scale this object and all it's children. */
/** @param #48 Value */
/** The value to scale to.  100=full size, 50=half size */

void qOrbiter::CMD_Scale_this_object(int iValue,string &sCMD_Result,Message *pMessage)
//<-dceag-c405-e->
{
    cout << "Need to implement command #405 - Scale this object" << endl;
    cout << "Parm #48 - Value=" << iValue << endl;
}

//<-dceag-c407-b->

/** @brief COMMAND: #407 - Set Floorplan */
/** Sets the object to use for one of the following types:
light, media, climate, security, telecom */
/** @param #3 PK_DesignObj */
/** The screen to use for this floorplan */
/** @param #14 Type */
/** One of the following:
light, climate, media, security, telecom */
/** @param #119 True/False */
/** True if this is a popup.  False if it's full screen */

void qOrbiter::CMD_Set_Floorplan(string sPK_DesignObj,string sType,bool bTrueFalse,string &sCMD_Result,Message *pMessage)
//<-dceag-c407-e->
{
    cout << "Need to implement command #407 - Set Floorplan" << endl;
    cout << "Parm #3 - PK_DesignObj=" << sPK_DesignObj << endl;
    cout << "Parm #14 - Type=" << sType << endl;
    cout << "Parm #119 - TrueFalse=" << bTrueFalse << endl;
}

//<-dceag-c408-b->

/** @brief COMMAND: #408 - Show Floorplan */
/** Shows the floorplan */
/** @param #11 Position X */
/** If the floorplan is not full screen, the location where it should be displayed */
/** @param #12 Position Y */
/** If the floorplan is not full screen, the location where it should be displayed */
/** @param #14 Type */
/** The type of floorplan */

void qOrbiter::CMD_Show_Floorplan(int iPosition_X,int iPosition_Y,string sType,string &sCMD_Result,Message *pMessage)
//<-dceag-c408-e->
{
    cout << "Need to implement command #408 - Show Floorplan" << endl;
    cout << "Parm #11 - Position_X=" << iPosition_X << endl;
    cout << "Parm #12 - Position_Y=" << iPosition_Y << endl;
    cout << "Parm #14 - Type=" << sType << endl;
}

//<-dceag-c413-b->

/** @brief COMMAND: #413 - Forward local k/b to OSD */
/** Means this orbiter's keyboard should be controlling the application running on the media director. */
/** @param #119 True/False */
/** If 1, do it.  It 0, stop */

void qOrbiter::CMD_Forward_local_kb_to_OSD(bool bTrueFalse,string &sCMD_Result,Message *pMessage)
//<-dceag-c413-e->
{
    cout << "Need to implement command #413 - Forward local k/b to OSD" << endl;
    cout << "Parm #119 - TrueFalse=" << bTrueFalse << endl;
}

//<-dceag-c415-b->

/** @brief COMMAND: #415 - Set Mouse Position Relative */
/** Move the mouse relative to its current position */
/** @param #11 Position X */
/** The X Position to move */
/** @param #12 Position Y */
/** The Y Position to move */

void qOrbiter::CMD_Set_Mouse_Position_Relative(int iPosition_X,int iPosition_Y,string &sCMD_Result,Message *pMessage)
//<-dceag-c415-e->
{
    cout << "Need to implement command #415 - Set Mouse Position Relative" << endl;
    cout << "Parm #11 - Position_X=" << iPosition_X << endl;
    cout << "Parm #12 - Position_Y=" << iPosition_Y << endl;
}

//<-dceag-c416-b->

/** @brief COMMAND: #416 - Simulate Mouse Click At Present Pos */
/** Simulates clicking the mouse button */
/** @param #14 Type */
/** If L or empty, the left button.  If R the right button. */

void qOrbiter::CMD_Simulate_Mouse_Click_At_Present_Pos(string sType,string &sCMD_Result,Message *pMessage)
//<-dceag-c416-e->
{
    cout << "Need to implement command #416 - Simulate Mouse Click At Present Pos" << endl;
    cout << "Parm #14 - Type=" << sType << endl;
}

//<-dceag-c689-b->

/** @brief COMMAND: #689 - Update Time Code */
/** Update the time code of the current media */
/** @param #41 StreamID */
/** The Stream to update */
/** @param #102 Time */
/** The current time.  If there is both a section time and total time, they should be \t delimited, like 1:03\t60:30 */
/** @param #132 Total */
/** If there is both a section time and total time, they should be \t delimited, like 1:03\t60:30 */
/** @param #133 Speed */
/** The current speed */
/** @param #134 Title */
/** For DVD's, the title */
/** @param #135 Section */
/** For DVD's, the section */

void qOrbiter::CMD_Update_Time_Code(int iStreamID,string sTime,string sTotal,string sSpeed,string sTitle,string sSection,string &sCMD_Result,Message *pMessage)
//<-dceag-c689-e->
{
    cout << "Need to implement command #689 - Update Time Code" << endl;
    cout << "Parm #41 - StreamID=" << iStreamID << endl;
    cout << "Parm #102 - Time=" << sTime << endl;
    cout << "Parm #132 - Total=" << sTotal << endl;
    cout << "Parm #133 - Speed=" << sSpeed << endl;
    cout << "Parm #134 - Title=" << sTitle << endl;
    cout << "Parm #135 - Section=" << sSection << endl;
}

//<-dceag-c741-b->

/** @brief COMMAND: #741 - Goto Screen */
/** Goto a specific screen. */
/** @param #10 ID */
/** Assigns an optional ID to this particular "viewing" of the screen, used with Kill Screen.  There can be lots of instances of the same screen in the history queue (such as call in progress).  This allows a program to pop a particular one out of the queue. */
/** @param #159 PK_Screen */
/** The screen id. */
/** @param #251 Interruption */
/** Indicates at what times to ignore the screen change if it would interrupt the user.  A value in: enum eInterruption */
/** @param #252 Turn On */
/** If true, turn the display on if it's off. */
/** @param #253 Queue */
/** If true, then if the screen change was ignored so as not to interrpt the user, queue it for when the user is done */

void qOrbiter::CMD_Goto_Screen(string sID,int iPK_Screen,int iInterruption,bool bTurn_On,bool bQueue,string &sCMD_Result,Message *pMessage)
//<-dceag-c741-e->
{

    cout << "Need to implement command #741 - Goto Screen" << endl;
    cout << "Parm #10 - ID=" << sID << endl;
    cout << "Parm #159 - PK_Screen=" << iPK_Screen << endl;
    cout << "Parm #251 - Interruption=" << iInterruption << endl;
    cout << "Parm #252 - Turn_On=" << bTurn_On << endl;
    cout << "Parm #253 - Queue=" << bQueue << endl;
    cout << "scmdresult" << sCMD_Result << endl;
    emit gotoQml(QString("Screen_"+QString::number(iPK_Screen)+".qml"));


    //qDebug() << "Vect msg count" << pMessage->m_vectExtraMessages.size();

    map<long, string >::const_iterator end = pMessage->m_mapParameters.end();
    for (map<long, string >::const_iterator it = pMessage->m_mapParameters.begin(); it != end; ++it)
    {
        long dparam = it->first;
        string dparam2 = it->second;
        // ScreenParameters->addParam( QString::fromStdString(dparam2), dparam );
        emit addScreenParam(QString::fromStdString(dparam2), dparam );
    }
}

//<-dceag-c795-b->

/** @brief COMMAND: #795 - Set Mouse Behavior */
/** Indicates if the mouse should be locked to horizontal or vertical movements, how to handle range of motion, etc. */
/** @param #3 PK_DesignObj */
/** An object to lock the movement to */
/** @param #39 Options */
/** The following letter(s): [r/a]ramp/absolute */
/** @param #126 Exclusive */
/** If true, all existing mouse behavior will be removed */
/** @param #211 Direction */
/** a letter: [h]orizontal, [v]ertical, [b]oth */

void qOrbiter::CMD_Set_Mouse_Behavior(string sPK_DesignObj,string sOptions,bool bExclusive,string sDirection,string &sCMD_Result,Message *pMessage)
//<-dceag-c795-e->
{
    cout << "Need to implement command #795 - Set Mouse Behavior" << endl;
    cout << "Parm #3 - PK_DesignObj=" << sPK_DesignObj << endl;
    cout << "Parm #39 - Options=" << sOptions << endl;
    cout << "Parm #126 - Exclusive=" << bExclusive << endl;
    cout << "Parm #211 - Direction=" << sDirection << endl;
}

//<-dceag-c801-b->

/** @brief COMMAND: #801 - Set Mouse Sensitivity */
/** 1=Sensitive, 3=not sensitive */
/** @param #48 Value */
/** 1=sensitive, 3=least sensitive */

void qOrbiter::CMD_Set_Mouse_Sensitivity(int iValue,string &sCMD_Result,Message *pMessage)
//<-dceag-c801-e->
{
    cout << "Need to implement command #801 - Set Mouse Sensitivity" << endl;
    cout << "Parm #48 - Value=" << iValue << endl;
}

//<-dceag-c809-b->

/** @brief COMMAND: #809 - Display Alert */
/** Displays a short alert that appears on the orbiter as a discrete popup message that goes away automatically. */
/** @param #9 Text */
/** The text in the alert */
/** @param #70 Tokens */
/** File this alert with this token, and if another alert comes in before timeout with the same token, replace it. */
/** @param #182 Timeout */
/** Make the alert go away after this many seconds */
/** @param #251 Interruption */
/** How to interrupt the user if something is happening */

void qOrbiter::CMD_Display_Alert(string sText,string sTokens,string sTimeout,int iInterruption,string &sCMD_Result,Message *pMessage)
//<-dceag-c809-e->
{
    cout << "Need to implement command #809 - Display Alert" << endl;
    cout << "Parm #9 - Text=" << sText << endl;
    cout << "Parm #70 - Tokens=" << sTokens << endl;
    cout << "Parm #182 - Timeout=" << sTimeout << endl;
    cout << "Parm #251 - Interruption=" << iInterruption << endl;

    emit showAlert(QString::fromStdString(sText), QString::fromStdString(sTokens), QString::fromStdString(sTimeout).toInt(), iInterruption);

    sCMD_Result="OK";
}

//<-dceag-c810-b->

/** @brief COMMAND: #810 - Set Active Application */
/** Tells an On screen orbiter what application is currently active */
/** @param #50 Name */
/** A description of the app */
/** @param #159 PK_Screen */
/** The Screen for the OSD */
/** @param #216 Identifier */
/** The window identifier */
/** @param #226 PK_Screen_GoTo */
/** The screen for the orbiter remote */

void qOrbiter::CMD_Set_Active_Application(string sName,int iPK_Screen,string sIdentifier,int iPK_Screen_GoTo,string &sCMD_Result,Message *pMessage)
//<-dceag-c810-e->
{
    cout << "Need to implement command #810 - Set Active Application" << endl;
    cout << "Parm #50 - Name=" << sName << endl;
    cout << "Parm #159 - PK_Screen=" << iPK_Screen << endl;
    cout << "Parm #216 - Identifier=" << sIdentifier << endl;
    cout << "Parm #226 - PK_Screen_GoTo=" << iPK_Screen_GoTo << endl;
}

//<-dceag-c811-b->

/** @brief COMMAND: #811 - Get Active Application */
/** Return the currently active application */
/** @param #50 Name */
/** A description of the app */
/** @param #159 PK_Screen */
/** The Screen for the OSD */
/** @param #216 Identifier */
/** The window identifier */
/** @param #226 PK_Screen_GoTo */
/** The Screen for the orbiter remote */

void qOrbiter::CMD_Get_Active_Application(string *sName,int *iPK_Screen,string *sIdentifier,int *iPK_Screen_GoTo,string &sCMD_Result,Message *pMessage)
//<-dceag-c811-e->
{
    cout << "Need to implement command #811 - Get Active Application" << endl;
    cout << "Parm #50 - Name=" << sName << endl;
    cout << "Parm #159 - PK_Screen=" << iPK_Screen << endl;
    cout << "Parm #216 - Identifier=" << sIdentifier << endl;
    cout << "Parm #226 - PK_Screen_GoTo=" << iPK_Screen_GoTo << endl;
}

//<-dceag-c834-b->

/** @brief COMMAND: #834 - Execute Shortcut */
/** Execute the shortcut associated with a key.  Called when a key is held down. */
/** @param #48 Value */
/** The ascii value of the key (ie 65='A').  Valid are 0-9,*,#,A-Z */

void qOrbiter::CMD_Execute_Shortcut(int iValue,string &sCMD_Result,Message *pMessage)
//<-dceag-c834-e->
{
    cout << "Need to implement command #834 - Execute Shortcut" << endl;
    cout << "Parm #48 - Value=" << iValue << endl;
}

//<-dceag-c838-b->

/** @brief COMMAND: #838 - Bind to Wireless Keyboard */
/** If the USB RF dongle is attached it causes it to do a bind request and add a remote. */

void qOrbiter::CMD_Bind_to_Wireless_Keyboard(string &sCMD_Result,Message *pMessage)
//<-dceag-c838-e->
{
    cout << "Need to implement command #838 - Bind to Wireless Keyboard" << endl;
}


//<-dceag-c912-b->

/** @brief COMMAND: #912 - Activate PC Desktop */
/** Activate or de-activate the PC-desktop */
/** @param #119 True/False */
/** If true, switch to the last PC desktop.  If false, switch to Orbiter's desktop */

void qOrbiter::CMD_Activate_PC_Desktop(bool bTrueFalse,string &sCMD_Result,Message *pMessage)
//<-dceag-c912-e->
{
    cout << "Need to implement command #912 - Activate PC Desktop" << endl;
    cout << "Parm #119 - TrueFalse=" << bTrueFalse << endl;
}

//<-dceag-c923-b->

/** @brief COMMAND: #923 - Assisted Make Call */
/** Send make call command back to Orbiter and let it decide if we are going to make a direct call or a transfer/conference */
/** @param #17 PK_Users */
/** The called user. Only one is supported now. */
/** @param #83 PhoneExtension */
/** The phone number to be called. */
/** @param #184 PK_Device_From */
/** The device which starts the call. */
/** @param #263 PK_Device_To */
/** The called device. */

void qOrbiter::CMD_Assisted_Make_Call(int iPK_Users,string sPhoneExtension,string sPK_Device_From,int iPK_Device_To,string &sCMD_Result,Message *pMessage)
//<-dceag-c923-e->
{
    cout << "Need to implement command #923 - Assisted Make Call" << endl;
    cout << "Parm #17 - PK_Users=" << iPK_Users << endl;
    cout << "Parm #83 - PhoneExtension=" << sPhoneExtension << endl;
    cout << "Parm #184 - PK_Device_From=" << sPK_Device_From << endl;
    cout << "Parm #263 - PK_Device_To=" << iPK_Device_To << endl;
}

void qOrbiter::forceReloadRouter()
{

    DCE::CMD_Restart_DCERouter restart(this->m_dwPK_Device, this->iPK_Device_GeneralInfoPlugin, "Y" );
    SendCommand(restart);
}

void qOrbiter::getHouseState()
{

}

bool DCE::qOrbiter::initDceVars(){


    return true;

}

bool DCE::qOrbiter::initialize(){
    qDebug() << Q_FUNC_INFO;
    emit commandResponseChanged("Connecting to router");
    emit commandResponseChanged("Starting dce initialization");

    if(m_sIPAddress==""){
        m_sIPAddress=dceIP.toStdString();
        m_sHostName=dceIP.toStdString();
    }
    emit commandResponseChanged("Initialization IP::"+ dceIP);


    if ((GetConfig() == true) && (Connect(PK_DeviceTemplate_get()) == true))
    {

        m_dwMaxRetries = 1;
        m_bRouterReloading = false;
        m_bReload = false;
        m_bOrbiterConnected = true;

        emit deviceValid(true);
        emit commandResponseChanged("Starting Manager");
        qDebug() << "Starting Manager for qorbiter with device template " << PK_DeviceTemplate_get();
        emit startManager(QString::number(m_dwPK_Device), dceIP);

        if(!getConfiguration()){
            exit(99);
        }

        emit useQueueInsteadOfInstantPlayChanged(DATA_Get_Queue_Instead_of_Instant_Play() );

        registerDevice(i_user,QString(i_ea), i_room);
        CreateChildren();
        return true;
    } else {
        //QApplication::processEvents(QEventLoop::AllEvents);
        if(  m_pEvent->m_pClientSocket->m_eLastError==ClientSocket::cs_err_CannotConnect ) {
            LoggerWrapper::GetInstance()->Write(LV_CRITICAL, "No Router");
            emit commandResponseChanged("No Connection to Router");
            emit routerInvalid();

            QApplication::processEvents(QEventLoop::AllEvents);
            return false;
        } else if( m_pEvent->m_pClientSocket->m_eLastError==ClientSocket::cs_err_BadDevice ) {

            LoggerWrapper::GetInstance()->Write(LV_CRITICAL, "Bad Device");
            emit commandResponseChanged("Bad Device");
            emit connectionValid(true);
            return false;
        } else if(  m_pEvent->m_pClientSocket->m_eLastError==ClientSocket::cs_err_NeedReload ){
            LoggerWrapper::GetInstance()->Write(LV_CRITICAL, "Router Needs Reload");
            emit commandResponseChanged("Needs Reload");
            QApplication::processEvents(QEventLoop::AllEvents);
            return false;
        } else {

            LoggerWrapper::GetInstance()->Write(LV_CRITICAL, "Connect() Failed");

            emit commandResponseChanged("QOrbiter Connect() Failed for "+QString::number(this->m_dwPK_Device) );
            this->m_bRunning = true;
            Disconnect();
            emit routerConnectionChanged(false);
            return false;
        }

        Disconnect();
        return false;
        QApplication::processEvents(QEventLoop::AllEvents);
    }
}

void qOrbiter::requestConfigData()
{
#ifndef __ANDROID__
#ifndef Q_OS_MAC
    pthread_yield();
#endif
#endif

    QNetworkRequest updateDevice;
    QNetworkAccessManager *ud= new QNetworkAccessManager();

    updateDevice.setUrl("http://"+dceIP+"/lmce-admin/qOrbiterGenerator.php?d="+QString::number(m_dwPK_Device));

    QObject::connect(ud, SIGNAL(finished(QNetworkReply*)), this, SLOT(processConfigData(QNetworkReply*)));
    ud->get(updateDevice);
    DCE::LoggerWrapper::GetInstance()->Write(LV_CRITICAL, "Orbiter Connected, requesting configuration for device %d", m_dwPK_Device);
}

void qOrbiter::processConfigData(QNetworkReply *r)
{
    char *oData;
    oData = NULL;
    int iData_Size;
    iData_Size = 0;
    string *p_sResponse;
    p_sResponse = NULL;
    string filePath = "/var/tmp/"+QString::number(m_dwPK_Device).toStdString()+"conf.xml";
    CMD_Request_File configFileRequest((long)m_dwPK_Device, (long)4 , (string)filePath, &oData, &iData_Size);

    if (SendCommand(configFileRequest))
    {
        emit commandResponseChanged("Requesting remote configuration..");

    }
    else
    {

    }

    //setDceResponse("Idata recieved: " +QString::number(iData_Size)) ; // size of xml file
    QByteArray configData;              //config file put into qbytearray for processing
    configData = oData;
    if (configData.size() == 0)
    {
        emit commandResponseChanged("Invalid config for device: " + QString::number(m_dwPK_Device));
        emit commandResponseChanged("Please run http://dcerouter/lmce-admin/qOrbiterGenerator.php?d=" + QString::number(m_dwPK_Device)) ;
        return;
    }

    emit configReady(configData);

    DeviceData_Base* pDevice = this->m_pData->FindFirstRelatedDeviceOfTemplate(DEVICETEMPLATE_Orbiter_Plugin_CONST);
    CMD_Regen_Orbiter_Finished regenComplete(this->m_dwPK_Device, pDevice->m_dwPK_Device, this->m_dwPK_Device);
    SendCommandNoResponse(regenComplete);
}




void DCE::qOrbiter::deinitialize()
{
    qDebug() << Q_FUNC_INFO;
    char *pData;
    int iSize;
    pData = NULL;
    iSize = 0;

    BindMediaRemote(false);
    DCE::CMD_Orbiter_Registered CMD_OrbiterUnRegistered(m_dwPK_Device, iOrbiterPluginID, StringUtils::itos(m_dwPK_Device) ,i_user, StringUtils::itos(i_ea), i_room, &pData, &iSize);
    SendCommand(CMD_OrbiterUnRegistered);
    emit routerConnectionChanged(false);
    Disconnect();
    emit closeOrbiter();

}




bool qOrbiter::getConfiguration()
{

    httpSettingsRequest->setUrl("http://"+QString::fromStdString(m_sIPAddress).append("/lmce-admin/setEa2.php?d=").append(QString::number(m_dwPK_Device)).append("&label="+deviceName));
    qDebug() << "Ea url::" <<httpSettingsRequest->url();
    httpSettingsReply = httpOrbiterSettings->get(*httpSettingsRequest);

    /*------ScreenSaver-----------*/
    QStringList *t = new QStringList(QString::fromStdString(DATA_Get_Timeout().c_str()).split(","));
    if(!t->isEmpty()){
        QString ik(t->at(0));
        emit screenSaverTimerOutChanged(ik.toInt());
    }

    /*------Skin-------------------*/


    /*Screen Size*/


    /* Type */
#ifdef for_desktop
    //set model here for desktop
#elif for_ios
    //set ios label here
#elif ANDROID
    //set android label
#elif for_windows
    // set windows label
#elif for_mac
    //set mac label here
#else
    //set unknown
#endif

    /* Video Support */

    return true;
}

void qOrbiter::registerDevice(int user, QString ea, int room)
{
    qDebug() << Q_FUNC_INFO;
    emit commandResponseChanged("registering");

    char *pData;
    int iSize;
    i_user = user;
    i_ea = ea.toInt();
    i_room = room;
    pData = NULL;
    iSize = 0;
    string pResponse ="";
    //on-off  PkUsers -int entArea -string  int room

    DCE::CMD_Orbiter_Registered CMD_Orbiter_Registered(m_dwPK_Device, iOrbiterPluginID,  StringUtils::itos(i_room) ,      i_user,         StringUtils::itos(i_ea),          i_room,           &pData, &iSize);
    if (SendCommand(CMD_Orbiter_Registered, &pResponse) && pResponse=="OK")
    {
        emit commandResponseChanged("DCERouter Responded to Register with " + QString::fromStdString(pResponse));
        GetScreenSaverImages();
    }
    else
    {
        qWarning() << "Failed to register orbiter!";
    }
}

void qOrbiter::qmlSetup(int device, QString address)
{
    qDebug() << Q_FUNC_INFO;
    m_dwPK_Device = device;
    m_sHostName = address.toStdString();
    dceIP = address;

    Disconnect();
    pingCore();

}

void qOrbiter::setCurrentScreen(QString s){

    currentScreen = s;
}

void qOrbiter::setOrbiterSetupVars(int users, int room, int skin, int lang, int height, int width, QString name)
{
    httpOrbiterSettings = new QNetworkAccessManager();
    httpSettingsRequest = new QNetworkRequest();
    deviceName=name;

    sPK_Room = room;
    sPK_Users = users;
    sPK_Skin = skin;
    sPK_Lang = lang;
    sHeight = height;
    sWidth = width;

    if (sHeight > 0){
        emit commandResponseChanged("Setting up a new orbiter");

        int t = SetupNewOrbiter();

        if (t == 0){
            statusMessage("Error Setting up orbiter!");
            m_dwPK_Device = -1;
            initialize();
        } else {
            emit commandResponseChanged("New Device ID:" +QString::number(t));
            m_dwPK_Device = t ;
            if(m_dwPK_Device==-1)
                return;

            emit commandResponseChanged("Setting up Ea");
            httpSettingsRequest->setUrl("http://"+QString::fromStdString(m_sIPAddress).append("/lmce-admin/setEa2.php?d=").append(QString::number(m_dwPK_Device)).append("&label="+name));
            qDebug() << "Ea url::" <<httpSettingsRequest->url();
            httpSettingsReply = httpOrbiterSettings->get(*httpSettingsRequest);
            QObject::connect(httpSettingsReply, SIGNAL(finished()), this, SLOT(finishSetup()));

        }
    }
    else
    {

    }
}

void qOrbiter::finishSetup()
{

    httpSettingsReply->disconnect(this, SLOT(finishSetup()));
    emit commandResponseChanged(httpSettingsReply->readAll());
    emit commandResponseChanged("Finishing setup...");

    QString settingsUrl = "http://"+ dceIP;
    settingsUrl.append("/lmce-admin/qOrbiterGenerator.php?d="+QString::number(m_dwPK_Device)) ;
    httpSettingsRequest->setUrl(settingsUrl);

    httpSettingsReply = httpOrbiterSettings->get(*httpSettingsRequest);
    QObject::connect(httpSettingsReply,SIGNAL(finished()), this, SLOT(setupEa())); //server side code should be set to spit out JSON to provide proper replies.
    emit commandResponseChanged("Setup Complete, restarting");
    emit creationComplete(true);
}

void qOrbiter::setupEa()
{
    httpSettingsReply->disconnect(this,SLOT(setupEa()));
    httpSettingsRequest->setUrl("http://"+QString::fromStdString(m_sIPAddress).append("/lmce-admin/setEa2.php?d=").append(QString::number(m_dwPK_Device)).append("&label="+deviceName));
    qDebug() << "Ea url::" <<httpSettingsRequest->url();
    httpSettingsReply = httpOrbiterSettings->get(*httpSettingsRequest);
    QObject::connect(httpSettingsReply, SIGNAL(finished()), this, SLOT(initialize()));
}

void qOrbiter::getMountDevices()
{
    QVariantList storageDevices;

}

void qOrbiter::connectionError()
{


}

void qOrbiter::requestAttributeTypes(int type)
{
    string sName="";
    emit commandResponseChanged("Requesting Subtypes");
    string pResponse;
    CMD_Get_Attributes_For_Type reqSubtype(m_dwPK_Device, iMediaPluginID, type, &sName );

    if(SendCommand(reqSubtype, &pResponse) && pResponse=="OK"){
        emit commandResponseChanged("Got subtype for media");
#ifdef debug
        emit commandResponseChanged(QString::fromStdString(sName.c_str()));
#endif
    }
    else
    {
        emit commandResponseChanged("Command to get subtypes failed!");
    }


}

void qOrbiter::requestMediaSubtypes(int type)
{
    string pResponse = "";
    string sText = "";

    CMD_Get_Media_Sub_Type getTypesCmd(m_dwPK_Device, iMediaPluginID, type, &sText);
    // CMD_Get_Attributes_For_Type getTypesCmd(m_dwPK_Device, iMediaPluginID, 3 , &sText );
    if(SendCommand(getTypesCmd, &pResponse) && pResponse=="OK"){
        emit commandResponseChanged("Got subtypes for attribute");
        QStringList data;
        data = QString::fromStdString(sText.c_str()).split("\n");
        for(int i=0; i < data.count(); i++)
        {
            QStringList subSplit = data.at(i).split(":");
            if(subSplit.count()>1){
                emit newMediaSubtype(new AttributeSortItem( subSplit.last(),subSplit.first(), "",false,  0));
            }
        }
    }
    else
    {
        emit commandResponseChanged("Command to get types for attribute failed!");
    }
    requestFileFormats(type);

}

void qOrbiter::requestTypes(int type)
{
    string pResponse = "";  string sText = "";

    CMD_Get_Attribute_Types getTypesCmd(m_dwPK_Device, iMediaPluginID, type, &sText);
    if(SendCommand(getTypesCmd, &pResponse) && pResponse=="OK"){
        emit commandResponseChanged("Got types for attribute");
        emit newAttributeSort( new AttributeSortItem( "Recently Viewed","-1", "",false,  0));
        //  emit newAttributeSort( new AttributeSortItem( "Just Added","-2", "",false,  0));
        emit newAttributeSort( new AttributeSortItem( "File","0", "",false,  0));
        QStringList data;
        data = QString::fromStdString(sText.c_str()).split("\n");
        if(data.count() < 1)
            data.removeLast();

        for(int i=0; i < data.count(); i++)
        {
            QStringList subSplit = data.at(i).split(":");
            if(subSplit.count() > 1){
                emit newAttributeSort( new AttributeSortItem( subSplit.last(),subSplit.first(), "",false,  0));
            }

        }
    }
    else{
        emit commandResponseChanged("Command to get types for attribute failed!");
    }
    requestMediaSubtypes(type);


}

void qOrbiter::requestGenres(int type)
{
    string pResponse = "";
    string sText = "";

    CMD_Get_Attributes_For_Type getTypesCmd(m_dwPK_Device, iMediaPluginID,type , &sText);
    // CMD_Get_Attributes_For_Type getTypesCmd(m_dwPK_Device, iMediaPluginID, 3 , &sText );
    if(SendCommand(getTypesCmd, &pResponse) && pResponse=="OK"){
        emit commandResponseChanged("Got types for genres");
        QStringList data;
        data = QString::fromStdString(sText.c_str()).split("\n");
        for(int i=0; i < data.count(); i++)
        {
            QStringList subSplit = data.at(i).split(":");
#ifdef debug
            qDebug() << data.at(i).split(":");
#endif
            //  emit newFileFormatSort(new AttributeSortItem( subSplit.last(),subSplit.first(), QImage(),false,  0));
        }
    }
    else
    {
        emit commandResponseChanged("Command to get types for attribute failed!");
    }
}

void qOrbiter::requestFileFormats(int type)
{
    string pResponse = "";
    string sText = "";

    CMD_Get_File_Formats getTypesCmd(m_dwPK_Device, iMediaPluginID,type , &sText);
    if(SendCommand(getTypesCmd, &pResponse) && pResponse=="OK"){
        emit commandResponseChanged("Got File Formats for attribute");
        QStringList data;
        data = QString::fromStdString(sText.c_str()).split("\n");
        for(int i=0; i < data.count(); i++)
        {
            QStringList subSplit = data.at(i).split(":");
#ifdef debug
            emit commandResponse(data.at(i).split(":"));
#endif
            if(subSplit.count() > 1){
                emit newFileFormatSort( new AttributeSortItem( subSplit.last(),subSplit.first(), "",false,  0));
            }

        }
    }
    else
    {
        emit commandResponseChanged("Command to get types for attribute failed!");
    }
}



void qOrbiter::getFloorplanDeviceCommand(int device)
{
qDebug() << Q_FUNC_INFO;
    //todo - add code to dce router get the info back. directly.
    QVariantMap t;
    QVariantList d;
    DCE::DeviceData_Base * fpDevice = this->m_pData->m_AllDevices.m_mapDeviceData_Base_Find(device);

    if(!fpDevice)
        return;

    if(fpDevice->m_dwPK_DeviceTemplate == DEVICETEMPLATE_qOrbiter_CONST){
        qDebug() << " need child stream information";
    }

    for (map<int, string>::iterator it = fpDevice->m_mapCommands.begin(); it!=fpDevice->m_mapCommands.end(); ++it){
        QVariantMap l;
        l.insert("command_name", QString::fromStdString(it->second) );
        l.insert("command_number",QVariant(it->first) );
        d.append(l);

    }

    t.insert("commands",d);
    t.insert("device", device);

    emit addFloorplanDeviceCommand(t) ;

}

void qOrbiter::shutdown()
{
    // Closing and deleting of superclass member variables are done by superclass

}

bool qOrbiter::timeCodeInterceptor(Socket *pSocket, Message *pMessage, DeviceData_Base *pDeviceFrom, DeviceData_Base *pDeviceTo)
{
    Q_UNUSED(pSocket);
    Q_UNUSED(pDeviceTo);

    if(!m_bRunning )
        return false;

    string time = pMessage->m_mapParameters[EVENTPARAMETER_Current_Time_CONST];

    QString deviceEa;
    int id;

    QMap <long, string>p(pMessage->m_mapParameters);

    if(pDeviceFrom->m_dwPK_DeviceTemplate==DEVICETEMPLATE_qMediaPlayer_CONST){
        deviceEa = QString::fromStdString(pDeviceFrom->GetTopMostDevice()->m_sDescription);
        emit timecodeEvent( deviceEa, p);
    } else {
        id=pDeviceFrom->m_dwPK_Room;
        emit timecodeEvent( id, p);
    }
    //qDebug() <<  Q_FUNC_INFO << "Recieved Timecode Message " << pDeviceFrom->GetTopMostDevice()->m_sDescription.c_str() << "::"<< time.c_str();
    return false;
}

void qOrbiter::beginSetup()
{
    i_ea = 0;
    i_room = 0;
    i_user = 0;
    iPK_Device_DatagridPlugIn =  long(6);
    iPK_Device_OrbiterPlugin = long(9);
    iPK_Device_GeneralInfoPlugin = long(4);
    iPK_Device_SecurityPlugin = long(13);
    iPK_Device_LightingPlugin = long(8);
    m_dwIDataGridRequestCounter = 0;
    iOrbiterPluginID = 9;
    iMediaPluginID = 10;
    iPK_Device_eventPlugin = 12;
    m_pOrbiterCat = 5;
    internal_streamID = 0;
    i_current_mediaType = 0;
    i_current_floorplanType = 0;
    setCurrentPage(0);
    b_cancelRequest = false;
    media_currentPage=0;
    media_pos=0;
    media_seek="";
    cellsToRender = 0;

    setGridSeperator(16999);

    b_mediaPlaying = false;
    m_dwPK_Device_NowPlaying = 0;
    m_dwPK_Device_NowPlaying_Video = 0;
    m_dwPK_Device_NowPlaying_Audio = 0;
    m_dwPK_Device_CaptureCard = 0;
    m_dwMaxRetries = 3;
    m_sExternalIP = "";
    m_bOrbiterConnected = false;
    setGridStatus(true);
    initializeGrid();
    setOrbiterSetupVars(0,0,0,0,0,0, deviceName);
#ifndef for_harmattan
    qRegisterMetaType< QList<ExistingOrbiter*> >("QList<ExistingOrbiter*>");
    //  qRegisterMetaType<SleepingAlarm>("SleepingAlarm");
    qRegisterMetaType< QList<QObject*> >("QList<QObject*>");

#endif

    // emit commandResponseChanged("Run function executed in thread::"+thread()->currentThreadId());

}

void qOrbiter::sendDCECommand(PreformedCommand cmd) {

    SendCommandNoResponse(cmd);
}

void qOrbiter::sendDCECommandResp(DCECommand *pCmd) {
    if (pCmd->getCallback() > 0) {
        string sResponse;

        bool result = SendCommand(*pCmd->getCommand(), &sResponse);
        if (result) {
            emit commandComplete(pCmd);
        } else {
            emit commandFailed(pCmd->getCallback());
            delete pCmd;
        }

    } else {
        SendCommandNoResponse(*pCmd->getCommand());
    }
}

void qOrbiter::updateScreenSaverTimeout(int t)
{

    string data = StringUtils::itos(t);
    DCE::CMD_Set_Device_Data setTimeout((long)m_dwPK_Device, (long)iPK_Device_GeneralInfoPlugin, long(m_dwPK_Device), data, 56 );
    SendCommand(setTimeout);

}

void qOrbiter::handleDceCommand(DCE::PreformedCommand cmd)
{
    emit transmitDceCommand(cmd);
}
void qOrbiter::handleDceCommandResp(DCECommand *pCmd)
{
    emit transmitDceCommandResp(pCmd);
}

void qOrbiter::setRecievingStatus(bool b)
{
    finished = b;
    emit recievingStatusChanged(finished);

}

bool qOrbiter::getRecievingStatus()
{
    return finished;
}

void qOrbiter::setGridStatus(bool b)
{
    requestMore = b;

}

bool qOrbiter::getGridStatus()
{
    return requestMore;
}

void qOrbiter::setCurrentRow(int row)
{
    media_currentRow = row;
}

int qOrbiter::getCurrentRow()
{
    return media_currentRow;
}

void qOrbiter::initializeGrid()
{
    // Taken care of when setMediaType changes mediaType     mediaFilter.clear();

    gridPaused = false;
    emit commandResponseChanged("Dg Variables Reset");
}

void qOrbiter::setStringParam(int paramType, QString param)
{
    //    mediaFilter.setStringParam(paramType, param);

    if(!param.contains("!F"))
        b_cancelRequest = true;

}

void qOrbiter::requestPage(int page)
{
    media_pos = page * media_pageSeperator;

    b_cancelRequest = false;
    requestMore = true;

    setGridStatus(true);
    emit clearPageGrid();
}


void qOrbiter::jumpMobileGrid(int page)
{

}

void DCE::qOrbiter::executeCommandGroup(int cmdGrp)
{


    LoggerWrapper::GetInstance()->Write(LV_STATUS, "Executing Command Group %d", cmdGrp);

    CMD_Execute_Command_Group execCommandGroup((long)m_dwPK_Device, (long)2, cmdGrp);
    if( SendCommand(execCommandGroup) ){
        qDebug() << "Sent CommandGrp " << cmdGrp;
    } else {
        registerDevice(i_user,QString(i_ea), i_room);
        qDebug() << "Failed to Send command!";
    }
    emit commandComplete();
}

void qOrbiter::displayToggle(bool t)
{
    int state;

    if(t)
        state=1;
    else
        state=0;

    // qDebug() << m_pData->FindFirstRelatedDeviceOfTemplate(DEVICETEMPLATE_OnScreen_Orbiter_CONST)->m_dwPK_Device;
    map <int, string> dvcMap;
    GetDevicesByTemplate(DEVICETEMPLATE_OnScreen_Orbiter_CONST, &dvcMap);


    // map<long, string >::const_iterator end = pMessage->m_mapParameters.end();
    for (map<int, string >::const_iterator it = dvcMap.begin(); it != dvcMap.end(); ++it)
    {
        int dparam = it->first;
        string dparam2 = it->second;

        DeviceData_Base *pDevice= m_pData->m_AllDevices.m_mapDeviceData_Base_Find((long)dparam);
        if(pDevice->m_dwPK_Room == this->i_room){
            DCE::CMD_Display_OnOff display(m_dwPK_Device, dparam, StringUtils::itos(state), false );
            SendCommand(display);
        }
    }

    //  emit commandResponseChanged("Attempting to toggle the display" );
}

void qOrbiter::setMediaSpeed(int s)
{
    internal_playback_speed = s;
}

void qOrbiter::getGridView(bool direction)
{

}

void qOrbiter::seekToGridPosition(QString s)
{
    media_seek=s.toStdString();
    emit clearPageGrid();
}

void qOrbiter::getContextImage(int attributeNumber)
{
    CMD_Get_Attribute_Image contextImgGrab(m_dwPK_Device, iMediaPluginID);

}

void qOrbiter::removePlaylistItem(int index)
{
    CMD_Remove_playlist_entry strikeItem( m_dwPK_Device, iMediaPluginID, index);
    string cmd_resp = "";
    if(SendCommand(strikeItem, &cmd_resp) && cmd_resp =="OK")
    {
        emit mediaResponseChanged("Item Removed");
    }
}

void qOrbiter::saveCurrentPlaylist( QString name, bool SaveAsNew)
{
    emit mediaResponseChanged("Saving playlist-"+name);
    CMD_Save_playlist savePlaylist(m_dwPK_Device, iMediaPluginID, i_user, StringUtils::itos(this->i_ea), name.toStdString(), SaveAsNew);
    string saveResp = "";
    if(SendCommand(savePlaylist, & saveResp) && saveResp == "OK")
    {
        emit mediaResponseChanged("Playlist Saved");
    }
    else
    {
        emit mediaResponseChanged("Playlist not saved::"+QString::fromStdString(saveResp.c_str()));
    }

}

void qOrbiter::shutdownMD()
{

}

QImage DCE::qOrbiter::getfileForDG(string filePath)
{
    char *picData = NULL;
    int picData_Size;
    picData_Size = 0;

    CMD_Request_File reqFile((long)m_dwPK_Device, (long)4 , (string)filePath, &picData, &picData_Size);
    string p_sResponse="";

    //SendCommand(reqFile, p_sResponse);
    QImage returnImage;
    if(SendCommand(reqFile, &p_sResponse) && p_sResponse=="OK")
    {
        QByteArray tempData;
        tempData.setRawData(picData, picData_Size);

        bool ok = returnImage.loadFromData(tempData);
        delete[] picData;
        if (!ok)
        {
            emit commandResponseChanged("Couldnt Load From Data, setting default icon image");
            returnImage.load(":/icons/icon.png");
            return returnImage;
        }
        return returnImage;

    }
    else
    {
        emit commandResponseChanged("Couldnt Load From Router, setting default icon image");
        returnImage.load(":/icons/icon.png");
        return returnImage;
    }

}

void DCE::qOrbiter::GetFileInfoForQml(QString qs_file_reference)
{
    string s_value_assignment;

    CMD_Get_Attributes_For_Media cmd_file_info(m_dwPK_Device, iMediaPluginID , qs_file_reference.toStdString(), "", &s_value_assignment);
    string pResponse="";

    if (SendCommand(cmd_file_info, &pResponse) && pResponse == "OK")
    {
        GetMediaAttributeGrid(qs_file_reference);
        emit commandResponseChanged("Requesting file information for "+ qs_file_reference );

    }
    else
    {
        emit commandResponseChanged("Unable to request file information");
        routerReload();
    }

}

void DCE::qOrbiter::loadDataGrid(QString dataGridId, int PK_DataGrid, QString option)
{

    //  QString fx = option.replace(0,1, QString::number(i_currentGridType));
    //  qWarning() << fx;
    LoggerWrapper::GetInstance()->Write(LV_STATUS, "qOrbiter::loadDataGridGrid PK = '%d', option = %s", PK_DataGrid, option.toStdString().c_str());
    if (PK_DataGrid < 1) {
        LoggerWrapper::GetInstance()->Write(LV_CRITICAL, "loadDataGrid() : PK_DataGrid < 1, aborting!");
        return;
    }
    //  option = fx;
    string *sResponse;

    emit commandResponseChanged(QString("Getting data grid PK_DataGrid ").append(QString::number(PK_DataGrid)));
    int cellsToRender= 0;
    int gHeight = 0;
    int gWidth = 1;
    QString dgName;
    dgName.append(dataGridId).append("_").append(QString::number(m_dwPK_Device));
    m_dwIDataGridRequestCounter++;

    int offset = 0;
    int pkVar  = 0;
    int iOffset= 0;
    string valassign = "0";
    bool isSuccessfull;
    int fetchItems = media_pageSeperator;
    emit commandResponseChanged("Current Options::"+option);
    CMD_Populate_Datagrid populateGrid(
                m_dwPK_Device,
                iPK_Device_DatagridPlugIn,
                StringUtils::itos( m_dwIDataGridRequestCounter ),
                dgName.toStdString(),
                PK_DataGrid,
                option.toStdString(),
                0,
                &pkVar,
                &valassign,
                &isSuccessfull,
                &gWidth,
                &gHeight
                );

    if (SendCommand(populateGrid))
    {
        LoggerWrapper::GetInstance()->Write(LV_STATUS, "Grid Dimensions: Height %d, Width %d", gHeight, gWidth);
        if (fetchItems > gHeight)
            fetchItems = gHeight;
        QString dgN = dgName;
        // For media browser, we need to get _<dgname> as this is the one that contains images
        if (PK_DataGrid == DATAGRID_Media_Browser_CONST)
        {
            LoggerWrapper::GetInstance()->Write(LV_STATUS, "qOrbiter::loadDataGrid() media browser, using _<dgname>");
            dgN = QString("_")+dgN;
        } else if (PK_DataGrid == DATAGRID_Current_Media_Sections_CONST){
            //  LoggerWrapper::GetInstance()->Write(LV_STATUS, "qOrbiter::loadDataGrid() playists , using plist_<dgname>");
            //  dgN = QString("plist_")+dgN;
        } else if (PK_DataGrid == DATAGRID_Current_Media_Sections_CONST){

        }

        // hack/fixme: need to sleep a short while here, because if we emit prepareDataGrid too soon,
        // the qml list view will get invalid items show on screen.
        // the prepareDataGrid signal is connected to the prepareDataGrid method in qorbiterManager, which
        // calls setTotalRows on the GenericFlatListModel. This model is connected to the qml ListView.
        // There might be some race condition going on between the ListView initializing and the model populating,
        // but I have been unable to track this down (yet).
        QThread::msleep(100);
        emit prepareDataGrid(dataGridId, dgN, gHeight, gWidth);
    }
}

void DCE::qOrbiter::loadDataForDataGrid(QString dataGridId, QString dgName, int PK_DataGrid, QString option, int startRow, int numRows, int numColumns, QString seek) {

    char *pData = NULL;
    int iData_Size=0;
    int GridCurRow = startRow;
    int GridCurCol= 0;
    int iOffset = 0;
    int rows = numRows;
    
    LoggerWrapper::GetInstance()->Write(LV_STATUS, "loadDataForDataGrid id = %s, startRow = %d, numRows = %d", dataGridId.toStdString().c_str(), startRow, numRows);

    QString gridName = dgName;
    // Remove _ prefix for media browser when seeking
    if (PK_DataGrid == DATAGRID_Media_Browser_CONST && !seek.isEmpty())
        gridName.remove(0,1);

    if(PK_DataGrid == DATAGRID_Current_Media_Sections_CONST && !seek.isEmpty()){
        gridName.remove("plist_");
    }
    if(PK_DataGrid == DATAGRID_EPG_All_Shows_CONST && !seek.isEmpty()){

    }


    //CMD_Request_Datagrid_Contents(long DeviceIDFrom, long DeviceIDTo,                   string sID,                                              string sDataGrid_ID,int iRow_count,int iColumn_count,bool bKeep_Row_Header,bool bKeep_Column_Header,bool bAdd_UpDown_Arrows,string sSeek,int iOffset,    char **pData,int *iData_Size,int *iRow,int *iColumn
    DCE::CMD_Request_Datagrid_Contents requestGrid( long(m_dwPK_Device), long(iPK_Device_DatagridPlugIn),
                                                    StringUtils::itos( m_dwIDataGridRequestCounter ),
                                                    gridName.toStdString(), rows, numColumns,
                                                    false, false,
                                                    true,  seek.toStdString(),    iOffset,
                                                    &pData, &iData_Size, &GridCurRow, &GridCurCol );
    std::string pRes="";
    if(SendCommand(requestGrid, &pRes) && pRes=="OK" )
    {
        //we should be doing any adding, sorting, searching in this thread, not the gui thread
        //Sending the whole table still leaves us with parsing it on the main gui thread.
        DataGridTable *pDataGridTable = new DataGridTable(iData_Size,pData,false);

        //this isnt emitting an item so much as an entire grid to be parsed.
        emit addDataGridItem(dataGridId, PK_DataGrid, GridCurRow, rows, pDataGridTable);
        delete[] pData;
        pData=NULL;

    }

    emit dgRequestFinished(dataGridId);
}

void DCE::qOrbiter::GetMediaAttributeGrid(QString  qs_fk_fileno)
{
    emit commandResponseChanged("Getting file info");
    int gHeight = 1;
    int gWidth = 1;
    int pkVar = 0;
    string valassign ="";
    bool isSuccessfull;// = "false";

    string m_sGridID ="mattrfile_"+StringUtils::itos(m_dwPK_Device);

    string m_sSeek;
    int iOffset;
    int iData_Size=0;
    int GridCurRow = 0;
    int GridCurCol= 0;
    string pResponse="";
    char *pData;
    pData = NULL;

    QString temp;
    m_dwIDataGridRequestCounter++;

    string s_val;
    CMD_Get_Attributes_For_Media attribute_detail_get(m_dwPK_Device, iMediaPluginID,  qs_fk_fileno.toStdString(), " ",&s_val );
    SendCommand(attribute_detail_get);
    QString breaker = s_val.c_str();

    QStringList details = breaker.split(QRegExp("\\t"));

    int placeholder;
    //QApplication::processEvents(QEventLoop::AllEvents);
#ifdef debug
    qDebug() << details.join("||");
#endif

    placeholder = details.indexOf("TITLE");
    if(placeholder != -1)
    {   temp = details.at(placeholder+1);
        emit fd_titleChanged(temp);
    }

    placeholder = details.indexOf("SYNOPSIS");
    if(placeholder != -1)
    {
        temp = details.at(placeholder+1);
        emit fd_synopChanged(temp);
    }

    placeholder = details.indexOf("PICTURE");
    if(placeholder != -1)
    {
        // filedetailsclass->setScreenshot(details.at(placeholder+1));
        // filedetailsclass->setScreenshotimage(getfileForDG(details.at(placeholder+1).toStdString()));
        emit mediaResponseChanged(details.at(placeholder+1));
        emit fd_imageUrlChanged(QString(details.at(placeholder+1)));

    }

    placeholder = details.indexOf("PATH");
    if(placeholder != -1)
    {
        emit fd_pathChanged(details.at(placeholder+1));
        //begin ugly bit to determine the storage device for later use. its not passed explicitly, so i use a regex to determine it for media files
        QRegExp deviceNo("(\\\[\\\d+\\\])");
        int l = deviceNo.indexIn(details.at(placeholder+1));

        if (l ==-1){
            emit fd_storageDeviceChanged("mediatype");
            emit commandResponseChanged("Stored in /mediaType");
        }
        else
        {
            if(!deviceNo.isEmpty()){
                QString f = deviceNo.cap(0);
                f.remove("[");
                f.remove("]");
                emit fd_storageDeviceChanged(f);
                QString localPath = details.at(placeholder+1).split(deviceNo).at(1);
                emit fd_pathChanged(localPath);
            }
            else
            {
                emit fd_storageDeviceChanged("local");
            }
        }
        //end ugly bit of regex. pretty because it works unless a user decides to also have [\d\d\d] type directories. I try to counter that by choosing only
        //the first match as that will be the first indexed by the regex engine.

    }
    //QApplication::processEvents(QEventLoop::AllEvents);
    placeholder = details.indexOf("FILENAME");
    if(placeholder != -1)
    {
        emit fd_fileNameChanged(details.at(placeholder+1));
    }

    CMD_Populate_Datagrid cmd_populate_attribute_grid(m_dwPK_Device, iPK_Device_DatagridPlugIn, StringUtils::itos( m_dwIDataGridRequestCounter ), string(m_sGridID), 83, qs_fk_fileno.toStdString(), DEVICETEMPLATE_Datagrid_Plugin_CONST, &pkVar, &valassign,  &isSuccessfull, &gHeight, &gWidth );

    if (SendCommand(cmd_populate_attribute_grid, &pResponse))
    {
        /*
          initial request to populate the text only grid as denoted by the lack of a leading "_" as in _MediaFile_43
          this way, we can safely check empty grids and error gracefully in the case of no matching media
          */

        string imgDG = m_sGridID; //standard text grid with no images. this will not crash the router if requested and its empty, picture grids will

        //CMD_Request_Datagrid_Contents(long DeviceIDFrom, long DeviceIDTo,                   string sID,                                              string sDataGrid_ID,int iRow_count,int iColumn_count,bool bKeep_Row_Header,bool bKeep_Column_Header,bool bAdd_UpDown_Arrows,string sSeek,int iOffset,    char **pData,int *iData_Size,int *iRow,int *iColumn
        DCE::CMD_Request_Datagrid_Contents req_data_grid( long(m_dwPK_Device), long(iPK_Device_DatagridPlugIn), StringUtils::itos( m_dwIDataGridRequestCounter ), string(m_sGridID),    int(gWidth), int(gHeight),           false, false,        true,   string(m_sSeek),    int(iOffset),  &pData,         &iData_Size, &GridCurRow, &GridCurCol );
        if(SendCommand(req_data_grid))
        {

            //creating a dg table to check for cells. If 0, then we error out and provide a single "error cell"
            DataGridTable *pDataGridTable = new DataGridTable(iData_Size,pData,false);
            // int cellsToRender= pDataGridTable->GetRows();
#ifndef ANDROID
            LoggerWrapper::GetInstance()->Write(LV_CRITICAL, "Attribute Datagrid Dimensions: Height %d, Width %d", gHeight, gWidth);
#endif

            int index;
            QString cellfk;
            DataGridCell *pCell;
            for(MemoryDataTable::iterator it=pDataGridTable->m_MemoryDataTable.begin();it!=pDataGridTable->m_MemoryDataTable.end();++it)
            {

                pCell = it->second;
                const char *pPath = pCell->GetImagePath();
                index = pDataGridTable->CovertColRowType(it->first).first;
                QString attributeType = pCell->m_mapAttributes_Find("Title").c_str();
                QString attribute  = pCell->m_mapAttributes_Find("Name").c_str();
                cellfk = pCell->GetValue();
#ifdef debug
                emit commandResponseChanged();
#endif
                int at = cellfk.remove("!A").toInt();
                if(attributeType == "Program") { emit fd_programChanged(attribute);                 emit newFileDetailAttribute(ATTRIBUTETYPE_Program_CONST, at,attribute ); }
                else if(attributeType == "Title") { emit fd_mediaTitleChanged(attribute); }
                else if(attributeType == "Channel") { emit fd_chanIdChanged(attribute);             emit newFileDetailAttribute(ATTRIBUTETYPE_TV_Channel_ID_CONST, at,attribute ); }
                else if(attributeType == "Episode") { emit fd_episodeChanged(attribute);            emit newFileDetailAttribute(ATTRIBUTETYPE_Episode_CONST, at,attribute );}
                else if(attributeType == "Performer") { emit fd_performersChanged(attribute);       emit newFileDetailAttribute(ATTRIBUTETYPE_Performer_CONST, at,attribute );}
                else if(attributeType == "Composer/Writer") { emit fd_composersChanged(attribute);  emit newFileDetailAttribute(ATTRIBUTETYPE_ComposerWriter_CONST, at,attribute ); }
                else if(attributeType == "Director") { emit fd_directorChanged(attribute);          emit newFileDetailAttribute(ATTRIBUTETYPE_Director_CONST, at,attribute ); }
                else if(attributeType == "Genre") { emit fd_genreChanged(attribute);                emit newFileDetailAttribute(ATTRIBUTETYPE_Genre_CONST, at,attribute ); }
                else if(attributeType == "Album") { emit fd_albumChanged(attribute);                emit newFileDetailAttribute(ATTRIBUTETYPE_Album_CONST, at,attribute ); }
                else if(attributeType == "Studio") { emit fd_studioChanged(attribute);              emit newFileDetailAttribute(ATTRIBUTETYPE_Studio_CONST, at,attribute );}
                else if(attributeType == "Track")  { emit fd_trackChanged(attribute);               emit newFileDetailAttribute(ATTRIBUTETYPE_Track_CONST, at,attribute ); }
                else if(attributeType == "Rating") { emit fd_ratingChanged(attribute);              emit newFileDetailAttribute(ATTRIBUTETYPE_Rated_CONST, at,attribute ); }
                else {
                }
#ifdef RPI
                QThread::msleep(100);
#endif
            }

            delete []pData;
            pData = NULL;
            pDataGridTable->ClearData();
            delete pDataGridTable;
            pDataGridTable =NULL;

        }
    }

}

void DCE::qOrbiter::GetSecurityCam(int i_inc_pkdevice, bool showScreen)
{

}

void DCE::qOrbiter::stop_AV()
{
    CMD_Stop endMedia(m_dwPK_Device, iMediaPluginID,false,0/*stream id*/);
    SendCommand(endMedia);
}



void qOrbiter::checkTimeCode(int npDevice)
{
    qWarning() << "Searching for ip address of media player, device " << npDevice;
    //  emit setMyIp(QString::fromStdString(m_sIPAddress));

    DeviceData_Base *pDevice =m_pData->m_AllDevices.m_mapDeviceData_Base_Find((long)npDevice) ;

    qWarning() << pDevice->m_dwPK_DeviceTemplate;
    string sIPAddress =pDevice->m_sIPAddress;
    string defaultPort= m_pEvent->GetDeviceDataFromDatabase(pDevice->m_dwPK_Device, DEVICEDATA_Port_CONST);

    qWarning() << "1st pass result is ==>" << sIPAddress.c_str();
    if( sIPAddress.empty() )
    {
        if( pDevice->m_dwPK_DeviceTemplate == DEVICETEMPLATE_Generic_PC_as_MD_CONST && !pDevice->m_pDevice_MD->m_sIPAddress.empty() ){
            qWarning("MD address?");
            sIPAddress = pDevice->m_pDevice_MD->m_sIPAddress;
        } else if( pDevice->m_dwPK_DeviceTemplate == DEVICETEMPLATE_OMX_Player_CONST){
            qWarning() << "OMX Player device, looking up ip address data";
            sIPAddress =  pDevice->m_sIPAddress;
            if( sIPAddress.empty() )
            {
                if( pDevice->m_pDevice_MD && !pDevice->m_pDevice_MD->m_sIPAddress.empty() )
                    sIPAddress = pDevice->m_pDevice_MD->m_sIPAddress;
                else if( pDevice->m_pDevice_Core && !pDevice->m_pDevice_Core->m_sIPAddress.empty() )
                    sIPAddress = pDevice->m_pDevice_Core->m_sIPAddress;
                else
                {
                    LoggerWrapper::GetInstance()->Write(LV_WARNING,"Orbiter::CMD_Set_Now_Playing  Xine has no IP address");
                    return;
                }
            }
            LoggerWrapper::GetInstance()->Write(LV_WARNING,"Orbiter::CMD_Set_Now_Playing  Xine has no IP address");

        }else if(pDevice->m_dwPK_DeviceTemplate == DEVICETEMPLATE_Xine_Player_CONST  ) {
            qWarning("On Screen Orbiter, looking up XINE Ip Address set!");
            sIPAddress =  pDevice->m_sIPAddress;

            if( sIPAddress.empty() )
            {
                if( pDevice->m_pDevice_MD && !pDevice->m_pDevice_MD->m_sIPAddress.empty() )
                    sIPAddress = pDevice->m_pDevice_MD->m_sIPAddress;
                else if( pDevice->m_pDevice_Core && !pDevice->m_pDevice_Core->m_sIPAddress.empty() )
                    sIPAddress = pDevice->m_pDevice_Core->m_sIPAddress;
                else
                {
                    LoggerWrapper::GetInstance()->Write(LV_WARNING,"QOrbiter::CMD_Set_Now_Playing  Xine has no IP address");
                    return;
                }
            }

        } else if(pDevice->m_dwPK_DeviceTemplate == DEVICETEMPLATE_qMediaPlayer_CONST ){
            sIPAddress = GetCurrentDeviceData(m_dwPK_Device_NowPlaying, DEVICEDATA_TCP_Address_CONST);

            if(sIPAddress.empty()){
                qWarning("QMediaPlayer Has Not IP address!");
                qDebug() << GetCurrentDeviceData(m_dwPK_Device_NowPlaying, DEVICEDATA_TCP_Address_CONST).c_str();
                return;
            }
        }
        else
        { qWarning() << "Could not find ip address";
            LoggerWrapper::GetInstance()->Write(LV_WARNING,"Media Player Has No Address");
            return;
        }
    }

    if((i_current_mediaType==4||i_current_mediaType==5) && !sIPAddress.empty() ){
        if(defaultPort.empty() ){
            defaultPort="12000";
        }
        emit updateTimeCode(QString::fromStdString(sIPAddress), QString::fromStdString(defaultPort).toInt());
    }
    else
    {
        emit stopTimeCode();

    }
    qWarning() << " New timecode device ip :: " << sIPAddress.c_str();
}

void qOrbiter::getStreamingVideo()
{

    char *grabData;
    int grabData_size=0;
    string sFormat ="png";
    string grabResponse="";

    CMD_Get_Video_Frame grabVideoFrame( m_dwPK_Device, m_dwPK_Device_NowPlaying, "0", this->internal_streamID, 800, 800, &grabData, &grabData_size, &sFormat );

    if(SendCommand(grabVideoFrame, &grabResponse) && grabResponse =="OK")
    {
        QImage tgrab;
        QByteArray buf;
        buf.setRawData(grabData, grabData_size);
        tgrab.loadFromData(buf);
        emit  videoGrabReady(tgrab);
        //emit commandResponseChanged("Image Retrieved");
    }
    else
    {
        emit commandResponseChanged("Couldnt get the stream image!");
        emit videoGrabReady(QImage());
    }

}



void qOrbiter::changedPlaylistPosition(QString pos)
{

    if(!pos.contains(QRegExp("TITLE:")))
    {
        //  qDebug() << pos;
        jumpToPlaylistPosition(pos);
    }
    else
    {
        //      pqOrbiter->setPosition(pos);
    }
}

void DCE::qOrbiter::ShowFloorPlan(int floorplantype)
{
    i_current_floorplanType = floorplantype;
    emit floorplanTypeChanged(floorplantype);

    //emit gotoQml(Screen);
}

/*
  This function updates the floorplan data. Its ordered by device number, lowest to highest
  Fields:
  Color - sent as an unsigned int
  String - device status
  String - device status with level
  design obj number (legacy)
  */
void qOrbiter::updateFloorPlan(QString p)
{
    string sval = "";
    p.remove(0, p.length() - 1);
    CMD_Get_Current_Floorplan getFloorPlan(m_dwPK_Device, iOrbiterPluginID, p.toStdString(), i_current_floorplanType , &sval);
    string pResponse="";
    if(SendCommand(getFloorPlan, &pResponse) && pResponse=="OK")
    {
        emit commandResponseChanged("Got floorplan for page "+p);
    }
    // qDebug() << "This Page Floorplan Data for Page " <<  p << ", Floorplan device type " << i_current_floorplanType << "::" <<sval.c_str();
}

/*!
 * \brief DCE::qOrbiter::GetScreenSaverImages
 * returns list of the availible screen saver images downloaded by the core.
 *
 */
void DCE::qOrbiter::GetScreenSaverImages()
{
    string sFilename;
    CMD_Get_Screen_Saver_Files screen_saver_files(m_dwPK_Device, iPK_Device_OrbiterPlugin,m_dwPK_Device, &sFilename);
    SendCommand(screen_saver_files);
    QStringList tempList = QString::fromStdString(sFilename).split("\n");
    emit screenSaverImages(tempList);
    tempList.detachShared();
    tempList.clear();

}

void DCE::qOrbiter::BindMediaRemote(bool onoff)
{
    string status;
    if (onoff == true)
    {
        status = "1";
    }
    else
    {
        status = "0";
    }
    int killer;
    CMD_Bind_to_Media_Remote bind_remote(m_dwPK_Device, iMediaPluginID, this->m_dwPK_Device,string("2355") ,status, string(""), StringUtils::itos(i_ea), 0, 0);
    SendCommand(bind_remote);
}

void DCE::qOrbiter::jumpToPlaylistPosition(QString pos)
{
    //qDebug("jumping to playlist item");
    CMD_Jump_Position_In_Playlist jump_playlist(m_dwPK_Device, iMediaPluginID, pos.toStdString(), internal_streamID);
    SendCommand(jump_playlist);
}

void DCE::qOrbiter::setNowPlayingDetails()
{
    if(i_current_mediaType != 11)
    {
        //qDebug("Requesting playlist");
    }
    else{


    }

}

void DCE::qOrbiter::SetSecurityStatus(string pin, string mode, int user, string special)
{
    CMD_Set_House_Mode set_security_mode(m_dwPK_Device, iPK_Device_SecurityPlugin, mode, user, pin,0, special);
    SendCommand(set_security_mode);
}

void DCE::qOrbiter::GetSingleSecurityCam(int cam_device, int iHeight, int iWidth, bool showScreen) //shows security camera, needs to be threaded as it blocks the ui
{
    //screen 17 is multi camera
    //screen 15 is single
    if(showScreen && currentScreen!="Screen_15.qml"){
        SCREEN_SingleCameraViewOnly singleSwitch(m_dwPK_Device,m_dwPK_Device, cam_device);
        SendCommand(singleSwitch);
        return;

    }
    if(currentScreen=="Screen_15.qml" || currentScreen=="Screen_17.qml"){

        char *sData;
        int sData_size= 0;
        string imgtype;
        CMD_Get_Video_Frame singleVideoFrame(m_dwPK_Device,long(cam_device), string("1"), 0, iWidth, iHeight, &sData, &sData_size, &imgtype);
        SendCommand(singleVideoFrame);

        QImage returnedFrame;
        returnedFrame.loadFromData(QByteArray(sData, sData_size));
        emit securityImageReady(cam_device, returnedFrame);
    } else {

    }

}

void DCE::qOrbiter::GetMultipleSecurityCams(QStringList cams) // not implemented yet
{
}

void DCE::qOrbiter::GetNowPlayingAttributes()
{
    /*
      this functions purpose is to return the attributes for the currently playing media this in this
      orbiter's EA it is a candidate for being extended along with the file details metadata function
      to expand our ui capabilities. it is essentially a clone of the many datagrid requests
      that the orbiter makes in addition to parsing of other information passed for a given object.
      */

    int p = 0;
    string s_val;
    string pResponse="";
    CMD_Get_Attributes_For_Media attribute_detail_get(m_dwPK_Device, iMediaPluginID, "" , StringUtils::itos(i_ea),&s_val );
    if (SendCommand(attribute_detail_get, &pResponse) && pResponse == "OK")
    {
        emit commandResponseChanged("Getting Media Attributes");
        QString breaker = s_val.c_str();
        QStringList details = breaker.split(QRegExp("\\t"));
        int placeholder;
        QString filepath;
        placeholder = details.indexOf("TITLE");
        if(placeholder != -1)
        {
            emit mediaResponseChanged(details.at(placeholder+1));
        }

        placeholder = details.indexOf("SYNOPSIS");
        if(placeholder != -1)
        {
            emit np_synopsisChanged(details.at(placeholder+1));
            //nowPlayingButton->setSynop(details.at(placeholder+1));
        }

        placeholder = details.indexOf("PICTURE");
        if(placeholder != -1)
        {

        }

        placeholder = details.indexOf("PATH");
        if(placeholder != -1)
        {
            //  qDebug() << details.at(placeholder+1);

            emit np_pathChanged(details.at(placeholder+1));
            //begin ugly bit to determine the storage device for later use. its not passed explicitly, so i use a regex to determine it for media files
            QRegExp deviceNo("(\\\[\\\d+\\\])");
            int l = deviceNo.indexIn(details.at(placeholder+1));

            if (l ==-1){
                emit np_storageDeviceChanged("mediatype");
                emit commandResponseChanged("Stored in /mediaType");
            }
            else
            {
                if(!deviceNo.isEmpty()){
                    QString f = deviceNo.cap(0);
                    f.remove("[");
                    f.remove("]");
                    emit np_storageDeviceChanged(f);
                    QString localPath = details.at(placeholder+1).split(deviceNo).at(1);
                    emit np_localpathChanged(localPath);
                }
                else
                {
                    emit np_storageDeviceChanged("local");
                }
            }
            //end ugly bit of regex. pretty because it works unless a user decides to also have [\d\d\d] type directories. I try to counter that by choosing only
            //the first match as that will be the first indexed by the regex engine.

        }

        placeholder = details.indexOf("FILENAME");
        if(placeholder != -1)
        {
            filepath.append(details.at(placeholder+1));
            emit mediaResponseChanged(details.at(placeholder+1));
        }

        emit np_filename(filepath);
        int gHeight = 0;
        int gWidth = 0;
        int pkVar = 0;
        string valassign ="";
        bool isSuccessfull;// = "false";

        string m_sGridID ="mac"+StringUtils::itos(m_dwPK_Device); // the string identifier on the type of grid
        string m_sSeek;
        int iData_Size=0;
        int GridCurRow = 0;
        int GridCurCol= 0;

        char *pData;
        pData = NULL;

        m_dwIDataGridRequestCounter++;

        CMD_Populate_Datagrid cmd_populate_attribute_grid(m_dwPK_Device, iPK_Device_DatagridPlugIn, StringUtils::itos( m_dwIDataGridRequestCounter ), string(m_sGridID), 31, StringUtils::itos(i_ea), 0, &pkVar, &valassign,  &isSuccessfull, &gHeight, &gWidth );

        if (SendCommand(cmd_populate_attribute_grid))
        {
            /*
                  initial request to populate the text only grid as denoted by the lack of a leading "_" as in _MediaFile_43
                  this way, we can safely check empty grids and error gracefully in the case of no matching media
                  */

            //standard text grid with no images. this will not crash the router if requested and its empty, picture grids will

            //CMD_Request_Datagrid_Contents(long DeviceIDFrom, long DeviceIDTo,                   string sID,                                              string sDataGrid_ID,int iRow_count,int iColumn_count,bool bKeep_Row_Header,bool bKeep_Column_Header,bool bAdd_UpDown_Arrows,string sSeek,int iOffset,    char **pData,int *iData_Size,int *iRow,int *iColumn
            DCE::CMD_Request_Datagrid_Contents req_data_grid( long(m_dwPK_Device), long(iPK_Device_DatagridPlugIn), StringUtils::itos( m_dwIDataGridRequestCounter ), string(m_sGridID),    int(gWidth), int(gHeight),           false, false,        true,   string(m_sSeek),    0,  &pData,         &iData_Size, &GridCurRow, &GridCurCol );
            if(SendCommand(req_data_grid))
            {


                //creating a dg table to check for cells. If 0, then we error out and provide a single "error cell"
                DataGridTable *pDataGridTable = new DataGridTable(iData_Size,pData,false);
                //int cellsToRender= pDataGridTable->GetRows();
                LoggerWrapper::GetInstance()->Write(LV_CRITICAL, "Attribute Datagrid Dimensions: Height %d, Width %d", gHeight, gWidth);
                QString cellTitle;
                QString cellAttribute;
                int index;
                QString cellfk;
                DataGridCell *pCell;
                for(MemoryDataTable::iterator it=pDataGridTable->m_MemoryDataTable.begin();it!=pDataGridTable->m_MemoryDataTable.end();++it)
                {

                    pCell = it->second;
                    index = pDataGridTable->CovertColRowType(it->first).first;
                    cellTitle = pCell->GetText();
                    cellAttribute = pCell->GetValue();
                    cellfk = pCell->GetValue();
                    QStringList parser = cellTitle.split(QRegExp("(\\n|:\\s)"), QString::KeepEmptyParts);
                    QString attributeType = parser.at(0);
                    QString attribute;
                    if(parser.length() < 2)
                    {
                        attribute = "";
                    }
                    attribute = parser.at(1);
                    if(attributeType == "Program")
                    {

                        emit np_program(attribute);

                    }
                    else if(attributeType == "Title")
                    {

                        emit np_mediaTitleChanged(attribute);

                    }
                    else if(attributeType == "Channel")
                    {

                        emit np_channel(attribute);
                    }
                    else if(attributeType == "Episode")
                    {
                        emit np_episode(attribute);

                    }
                    else if(attributeType == "Performer")
                    {
                        emit np_performer(attribute);

                    }
                    else if(attributeType == "Director")
                    {
                        emit np_director(attribute);

                    }
                    else if(attributeType == "Genre")
                    {
                        emit np_genre(attribute);

                    }
                    else if(attributeType == "Album")
                    {

                        emit np_album(attribute);

                    }
                    else if(attributeType == "Track")
                    {
                        emit np_track(attribute);

                    }
                    else if(attributeType == "Synopsis")
                    {
                        emit np_synopsisChanged(attribute);

                    }
                    else if(attributeType == "Release Date")
                    {
                        emit np_releaseDate(attribute);

                    }
                }
                pDataGridTable->ClearData();
                delete pDataGridTable;
                pDataGridTable = NULL;
                delete []pData;
                pData = NULL;
            }
        }
    }

}

void DCE::qOrbiter::requestLiveTvPlaylist()
{

    /*
      this functions purpose is to return the attributes for the currently playing media this in this
      orbiter's EA it is a candidate for being extended along with the file details metadata function
      to expand our ui capabilities. it is essentially a clone of the many datagrid requests
      that the orbiter makes.
      */

    //qDebug("Getting current Epg");
    return;
    int gHeight = 1;
    int gWidth = 1;
    int pkVar = 0;
    string valassign ="";
    bool isSuccessfull;// = "false";
    string m_sGridID ="tvchan_"+StringUtils::itos(m_dwPK_Device); // the string identifier on the type of grid
    string m_sSeek;
    string m_EA = QString::number(i_ea).toStdString();
    string m_UserID = QString::number(i_user).toStdString();
    int iOffset;
    int iData_Size=0;
    int GridCurRow = 0;
    int GridCurCol= 0;
    char *pData;
    pData = NULL;
    m_dwIDataGridRequestCounter++;
#ifdef ANDROID

    CMD_Populate_Datagrid cmd_populate_livetv_grid(m_dwPK_Device, iPK_Device_DatagridPlugIn, StringUtils::itos( m_dwIDataGridRequestCounter ), string(m_sGridID), 11, m_UserID + "," + m_EA, 0, &pkVar, &valassign,  &isSuccessfull, &gHeight, &gWidth );
#elif for_android
    CMD_Populate_Datagrid cmd_populate_livetv_grid(m_dwPK_Device, iPK_Device_DatagridPlugIn, StringUtils::itos( m_dwIDataGridRequestCounter ), string(m_sGridID),11, m_UserID + "," + m_EA, 0, &pkVar, &valassign,  &isSuccessfull, &gHeight, &gWidth );
#else
    CMD_Populate_Datagrid cmd_populate_livetv_grid(
                m_dwPK_Device,
                iPK_Device_DatagridPlugIn,
                StringUtils::itos( m_dwIDataGridRequestCounter ),
                string(m_sGridID),
                11, m_UserID + "," + m_EA,
                0,
                &pkVar,
                &valassign,
                &isSuccessfull,
                &gHeight,
                &gWidth
                );
#endif

    if (SendCommand(cmd_populate_livetv_grid))    {
        /*
              initial request to populate the text only grid as denoted by the lack of a leading "_" as in _MediaFile_43
              this way, we can safely check empty grids and error gracefully in the case of no matching media
              */

        //standard text grid with no images. this will not crash the router if requested and its empty, picture grids will

        //CMD_Request_Datagrid_Contents(long DeviceIDFrom, long DeviceIDTo,                   string sID,                                              string sDataGrid_ID,int iRow_count,int iColumn_count,bool bKeep_Row_Header,bool bKeep_Column_Header,bool bAdd_UpDown_Arrows,string sSeek,int iOffset,    char **pData,int *iData_Size,int *iRow,int *iColumn
        DCE::CMD_Request_Datagrid_Contents req_data_grid( long(m_dwPK_Device), long(iPK_Device_DatagridPlugIn), StringUtils::itos( m_dwIDataGridRequestCounter ), string(m_sGridID),    int(gWidth), int(gHeight),           false, false,        true,   string(m_sSeek),    int(iOffset),  &pData,         &iData_Size, &GridCurRow, &GridCurCol );
        if(SendCommand(req_data_grid))
        {
            //creating a dg table to check for cells. If 0, then we error out and provide a single "error cell"
            DataGridTable *pDataGridTable = new DataGridTable(iData_Size,pData,false);

            //LoggerWrapper::GetInstance()->Write(LV_CRITICAL, "Attribute Datagrid Dimensions: Height %i, Width %i", gHeight, gWidth);
            QString channelName;
            QString channelIndex;
            QString program;
            int index = 0;
            int channelNumber;
            DataGridCell *pCell;

            for(MemoryDataTable::iterator it=pDataGridTable->m_MemoryDataTable.begin();it!=pDataGridTable->m_MemoryDataTable.end();++it)
            {

                pCell = it->second;
                QStringList breaker = QString::fromStdString(pCell->m_mapAttributes_Find("Name").c_str()).split(" ");
                channelName = breaker.at(1);
                channelNumber = breaker.at(0).toInt();
                channelIndex = pCell->GetValue();
                program = QString::fromStdString(pCell->GetText());
                program.remove(channelName);
                program.remove(breaker.at(0));
                //                EPGItemClass *t = new EPGItemClass(channelName, channelNumber, channelIndex, program, index, QString("na"), QString("na"));
                //                emit addChannel(t);
                index++;
                QApplication::processEvents(QEventLoop::AllEvents);
            }


            pDataGridTable->ClearData();
            delete []pData; pData=NULL;
            pDataGridTable=NULL;
        }

    }
    else
    {
        emit commandResponseChanged("Could Not Populate");
    }

    if(i_current_mediaType == 1)
    {
        emit epgDone();
    }
    else
    {
        emit livetvDone();
    }
}


void DCE::qOrbiter::TuneToChannel(QString channel, QString chanid) //tunes to channel based on input, need some reworking for myth
{

    //  qDebug() << Q_FUNC_INFO << "MediaType::"<< i_current_mediaType << "\nchannel:: " << channel << "\nchannelid::"<<chanid;
    if(i_current_mediaType = 11)
    {
        emit mediaResponseChanged("Setting Channel! " + channel);
        CMD_Tune_to_channel changeChannel(m_dwPK_Device, iMediaPluginID, channel.toStdString(), channel.toStdString());
        SendCommand(changeChannel);
        emit np_channel(chanid);
        emit liveTvUpdate(chanid);
        emit livetvDone();
    }
    else
    {

        if(channel.contains("i"))
        {
            CMD_Tune_to_channel mythChannel(m_dwPK_Device, iMediaPluginID, channel.toStdString(), channel.toStdString());
            SendCommand(mythChannel);
        }
        else
        {

        }
    }
}


void DCE::qOrbiter::changedTrack(QString direction)
{
    string pResponse="";
    if (i_current_mediaType == 1)
    {
        if(direction == "+1")
        {
            CMD_Channel_up tvChanUp(m_dwPK_Device, iMediaPluginID );
            if(SendCommand(tvChanUp, &pResponse) && pResponse =="OK")
            {
                emit mediaResponseChanged("Channel Up sent");
            }
        }
        else
        {
            CMD_Channel_up tvChanDwn(m_dwPK_Device, iMediaPluginID );
            if(SendCommand(tvChanDwn, &pResponse) && pResponse =="OK")
            {
                emit mediaResponseChanged("Channel down sent");
            }
        }


    }
    else
    {
        emit commandResponseChanged("Changing tracks");

        CMD_Jump_Position_In_Playlist jump_playlist(m_dwPK_Device, iMediaPluginID, direction.toStdString(), internal_streamID );
        string sResponse = "";
        if(SendCommand(jump_playlist, &sResponse) && sResponse=="OK")
        {
            emit mediaResponseChanged("Jumped to" + direction);
        }
    }
}

void DCE::qOrbiter::populateAdditionalMedia() //additional media grid that populates after the initial request to break out the threading and allow for a checkpoint across threads
{

    //emit commandResponseChanged("requesting additional media");
#ifdef QT5
    QApplication::processEvents(QEventLoop::AllEvents);
#endif

    int gHeight = media_pageSeperator;            //how many rows we want
    int gWidth = 1;             //how many columns we want. in this case, just the one
    int pkVar = 0;              // ??
    int iOffset = 0;            // ??
    int GridCurRow = media_pos;        //the row to start from
    int GridCurCol= 0;           //column to start from
    string imgDG ="_MediaFile_"+QString::number(m_dwPK_Device).toStdString();
    string m_sSeek=media_seek;
    if(m_sSeek !=""){
        qDebug() << "seeking to " << m_sSeek.c_str();
        requestMore=true;
        GridCurRow = 0;
        GridCurCol =0;
        imgDG = "MediaFile_"+QString::number(m_dwPK_Device).toStdString();

    }

    int iData_Size=0;
    char *pData;
    pData = NULL;
    //CMD_Request_Datagrid_Contents(                              long DeviceIDFrom,                long DeviceIDTo,                   string sID,                                string sDataGrid_ID, int iRow_count,int iColumn_count,        bool bKeep_Row_Header,bool bKeep_Column_Header,bool bAdd_UpDown_Arrows,string sSeek,       int iOffset,    char **pData,int *iData_Size,int *iRow,int *iColumn

    DCE::CMD_Request_Datagrid_Contents req_data_grid_pics( long(m_dwPK_Device), long(iPK_Device_DatagridPlugIn), StringUtils::itos( m_dwIDataGridRequestCounter ), string(imgDG),    media_pageSeperator,    gWidth,                  false,                 false,                                 true, m_sSeek,   iOffset,  &pData,         &iData_Size, &GridCurRow, &GridCurCol );
    std::string pResponse ="";
    if(SendCommand(req_data_grid_pics, &pResponse) && pResponse == "OK")
    {

        DataGridTable* pMediaGridTable = new DataGridTable(iData_Size,pData,false);

        emit mediaResponseChanged("grid request ok");
        // LoggerWrapper::GetInstance()->Write(LV_CRITICAL, "Pic Datagrid Dimensions: Height %i, Width %i", gHeight, gWidth);
        DataGridCell *pCell;
        QString cellTitle;
        QString fk_file;
        QString filePath;
        int index;
        media_pos = GridCurRow;

        if (m_sSeek != "")
        {
            media_seek = "";
            populateAdditionalMedia();
            delete[] pData;
            pData=NULL;
            pMediaGridTable->ClearData();
            delete pMediaGridTable;
            pMediaGridTable = NULL;
            return;
        }
        setCurrentPage((std::abs(GridCurRow /  media_pageSeperator))) ;
        emit mediaResponseChanged("Page: "+ QString::number(media_currentPage));

        for(MemoryDataTable::iterator it=pMediaGridTable->m_MemoryDataTable.begin();it!=pMediaGridTable->m_MemoryDataTable.end();++it)
        {
            pCell= it->second;
            const char *pPath = pCell->GetImagePath();
#ifdef RPI
            filePath = QString::fromUtf8(pPath).remove(".tnj");
#else
            filePath = QString::fromUtf8(pPath).remove(".tnj");
#endif
            fk_file = pCell->GetValue();

            cellTitle = QString::fromUtf8(pCell->m_Text);


            //            if(fk_file.contains("!A"))
            //            {
            //                string sText = "";
            //                string sTextResp="";
            //                int t = QString(fk_file).remove("!").toInt();
            //                CMD_Get_Attribute attrib(m_dwPK_Device, iMediaPluginID, t, &sText );

            //                if(SendCommand(attrib, &sTextResp) && sTextResp=="OK"){
            //                   qDebug() << sText.c_str();
            //                    // cellTitle = QString::fromStdString(sText);
            //                }
            //            }
            index = pMediaGridTable->CovertColRowType(it->first).second;

            if(!b_cancelRequest && requestMore && !gridPaused){
                emit addItem(new gridItem(fk_file, cellTitle, filePath.remove("/home/mediapics/"), (index+1), this));
                QApplication::processEvents(QEventLoop::AllEvents);

            }
            else if(!requestMore ){
                logMediaMessage("Datagrid Pausing");
                return;
            } else if(currentScreen!="Screen_47.qml"){
                logMediaMessage("Datagrid Stopping, no longer on screen 47");
                pMediaGridTable->ClearData();
                delete pMediaGridTable;
                pMediaGridTable=NULL;
                delete []pData; pData=NULL;
                return;
            } else if(gridPaused){
                logMediaMessage("Datagrid is paused.");
                media_pos=index;
                logMediaMessage("Stopped at "+QString::number(media_pos));
                return;
            }
            else{
                logMediaMessage("Datagrid Stopping");
                pMediaGridTable->ClearData();
                delete pMediaGridTable;
                pMediaGridTable=NULL;
                delete []pData; pData=NULL;
                return;
            }
        }

        media_seek="";
        pMediaGridTable->ClearData();
        delete []pData; pData=NULL;
        delete pMediaGridTable;
        pMediaGridTable=NULL;
    }


}

void DCE::qOrbiter::SetSecurityMode(QString pin, int mode, QString handling)
{
    CMD_Set_House_Mode change_house_modes(m_dwPK_Device, iPK_Device_SecurityPlugin, StringUtils::itos(mode),i_user, pin.toStdString(), 0, handling.toStdString());
    SendCommand(change_house_modes);
}

void DCE::qOrbiter::setLocation(int location, int ea) // sets the ea and room
{
    i_room = location;
    i_ea = ea;

    DATA_Set_FK_EntertainArea(StringUtils::itos(i_ea));

    CMD_Set_Entertainment_Area_DL set_entertain_area(m_dwPK_Device, StringUtils::itos(iOrbiterPluginID), StringUtils::itos(ea));
    SendCommand(set_entertain_area);

    CMD_Set_Current_Room_DL set_current_room(m_dwPK_Device, StringUtils::itos(iOrbiterPluginID), location);
    SendCommand(set_current_room);

    setUser(i_user);

}

void DCE::qOrbiter::setUser(int user)
{
    qDebug() << Q_FUNC_INFO << user;
    if(user==0)
        return;

    logDceMessage("SetUser() to " + QString::number(user));

    CMD_Set_Device_Data userData(m_dwPK_Device, this->iPK_Device_GeneralInfoPlugin ,m_dwPK_Device,StringUtils::itos(user),3);
    string cResp="";
    if(SendCommand(userData, &cResp)){
        logDceMessage("set user cmd " +QString::fromStdString(cResp.c_str()));
    }
    else{
        logDceMessage("Set user failed! " +QString::fromStdString(cResp.c_str()));
    }

    i_user = user;
}

void DCE::qOrbiter::quickReload() //experimental function. checkConnection is going to be our watchdog at some point, now its just um. there to restart things.
{
    qDebug() << Q_FUNC_INFO;
    string sResponse;
    Event_Impl event_Impl(DEVICEID_MESSAGESEND, 0, m_sHostName);
    event_Impl.m_pClientSocket->SendString( "RELOAD" );
    if( !event_Impl.m_pClientSocket->ReceiveString( sResponse ) || sResponse!="OK" )
    {
        CannotReloadRouter();
        LoggerWrapper::GetInstance()->Write(LV_WARNING,"Reload request denied: %s",sResponse.c_str());
    }

}

void DCE::qOrbiter::powerOn(QString devicetype)
{

    if (devicetype == "DISPLAY")
    {

    }
}


void DCE::qOrbiter::GetAdvancedMediaOptions(int device) // prepping for advanced media options
{
    int cellsToRender= 0;

    bool isSuccessfull;
    string valassign="";
    int gHeight = 1;
    int gWidth = 0;
    string dgIdent ="cmds_"+StringUtils::itos(m_dwPK_Device);
    int iData_Size=0;
    int GridCurRow = 0;
    int GridCurCol= 0;
    char *pData;
    pData = NULL;
    string m_sSeek = "";
    string options = StringUtils::itos(device) + ",134, 670";
    m_dwIDataGridRequestCounter++;
    int offset = 0;
    int pkVar=0;
    CMD_Populate_Datagrid codeGrid(m_dwPK_Device, iPK_Device_DatagridPlugIn, StringUtils::itos( m_dwIDataGridRequestCounter ), string(dgIdent), 24, options, DEVICETEMPLATE_Datagrid_Plugin_CONST, &pkVar, &valassign,  &isSuccessfull, &gHeight, &gWidth );
    string gResp="";
    if(SendCommand(codeGrid, &gResp) && gResp == "OK")
    {
        //CMD_Request_Datagrid_Contents(                              long DeviceIDFrom,                long DeviceIDTo,                   string sID,                                string sDataGrid_ID, int iRow_count,int iColumn_count,        bool bKeep_Row_Header,bool bKeep_Column_Header,bool bAdd_UpDown_Arrows,string sSeek,       int iOffset,    char **pData,int *iData_Size,int *iRow,int *iColumn
        DCE::CMD_Request_Datagrid_Contents advanced_av_grid( long(m_dwPK_Device), long(iPK_Device_DatagridPlugIn), StringUtils::itos( m_dwIDataGridRequestCounter ), string(dgIdent),    int(gWidth),    int(gHeight),                      false,                 false,                                 true, string(m_sSeek), 0   ,  &pData,         &iData_Size, &GridCurRow, &GridCurCol );

        if(SendCommand(advanced_av_grid))
        {
            DataGridTable *pDataGridTable = new DataGridTable(iData_Size,pData,false);
            cellsToRender= pDataGridTable->GetRows();

            LoggerWrapper::GetInstance()->Write(LV_CRITICAL, "Advanced AV  Grid Dimensions: Height %d, Width %d", gHeight, gWidth);
            QString cellTitle;
            QString fk_file;
            QString filePath;
            int index;

            for(MemoryDataTable::iterator it=pDataGridTable->m_MemoryDataTable.begin();it!=pDataGridTable->m_MemoryDataTable.end();++it)
            {
                DataGridCell *pCell = it->second;
                const char *pPath = pCell->GetImagePath();
                filePath = QString::fromUtf8(pPath);
                fk_file = pCell->GetValue();
                cellTitle = QString::fromUtf8(pCell->m_Text);
                index = pDataGridTable->CovertColRowType(it->first).first;
                if(!cellTitle.contains("learn"))
                {
                    //                    qDebug() << pCell->GetText();
                    //                    qDebug() << pCell->m_NumAttributes;
                    //                cellTitle.prepend("Missing Command name ");
                    emit newDeviceCommand(new AvCommand(fk_file.toInt(), cellTitle, false, device));
                }

            }
            pDataGridTable->ClearData();
            delete pDataGridTable; pDataGridTable=NULL;
            delete []pData; pData=NULL;
            pDataGridTable=NULL;

        }
    }
}

//zoom level for current media player
void DCE::qOrbiter::setZoom(QString zoomLevel)
{

    string sResponse="";
    CMD_Set_Zoom setMediaZoom(m_dwPK_Device, iMediaPluginID, internal_streamID, zoomLevel.toStdString());
    if (SendCommand(setMediaZoom, &sResponse) && sResponse=="OK")
    {
        emit commandResponseChanged(QString::fromStdString(sResponse));
    }
    else
    {
        emit commandResponseChanged(QString("Error sending command!"));
    }
}


void DCE::qOrbiter::setAspect(QString ratio) //set aspect ratio for current media player
{
    string sResponse = "";
    CMD_Set_Aspect_Ratio setMediaAspect(m_dwPK_Device, iMediaPluginID, internal_streamID, ratio.toStdString());
    if (SendCommand(setMediaAspect, &sResponse) && sResponse=="OK")
    {

    }
    else
    {
        emit commandResponseChanged("Error sending command!");
    }
}

void DCE::qOrbiter::GetText(int textno)
{

}

//used for resume to pass complex things like chapters and resume positions in playlists.
void DCE::qOrbiter::setPosition(QString position)
{
    //CHAPTER:0 POS:2040 TITLE:0 SUBTITLE:-1 AUDIO:-1 TOTAL:1239600 QUEUE_POS:0
    if(currentScreen.contains( "Screen_49.qml"))

    {
        CMD_Set_Media_Position setPosition(m_dwPK_Device, m_dwPK_Device_NowPlaying, internal_streamID, position.toStdString());
        //qDebug("DVD pls change") ;
        if(!SendCommand(setPosition))
        {

        }
    }
    else
    {

        CMD_Set_Media_Position setPosition(m_dwPK_Device, m_dwPK_Device_NowPlaying, internal_streamID, position.toStdString());

        if(!SendCommand(setPosition))
        {

        }
    }

}

void qOrbiter::setPosition(int position)
{
    emit commandResponseChanged("Jumping position in stream to "+ QString::number(position)) ;
    CMD_Set_Media_Position setPosition(m_dwPK_Device, this->m_dwPK_Device_NowPlaying, internal_streamID, StringUtils::itos(position));
    string cResp = "";
    if(SendCommand(setPosition, &cResp) && cResp == "OK")
    {
        emit mediaResponseChanged("Jumping to Position");
    }
}

void DCE::qOrbiter::showMenu() //show the dvd menu
{
    CMD_Goto_Media_Menu showDVDmenu(m_dwPK_Device, iMediaPluginID, internal_streamID, i_current_mediaType );
    if(!SendCommand(showDVDmenu))
    {

    }

}

void DCE::qOrbiter::osdBack() // connects the Go back action.
{
    DCE::CMD_Back_Prior_Menu goBack(m_dwPK_Device, iMediaPluginID, internal_streamID);
    if (!SendCommand(goBack))
    {

    }
}

void DCE::qOrbiter::moveDirection(int d) //connects ui buttons to dce commands
{
    if(d==1){
        DCE::CMD_Move_Up moveUp(m_dwPK_Device, iMediaPluginID, internal_streamID);
        if(!SendCommand(moveUp)) { }
    } else if(d==2) {
        DCE::CMD_Move_Down moveDown(m_dwPK_Device, iMediaPluginID, internal_streamID);
        if(!SendCommand(moveDown)) { }
    } else if(d==3){
        DCE::CMD_Move_Left moveLeft(m_dwPK_Device, iMediaPluginID, internal_streamID);
        if(!SendCommand(moveLeft)) { }
    } else if(d==4){
        DCE::CMD_Move_Right move(m_dwPK_Device, iMediaPluginID, internal_streamID);
        if(!SendCommand(move)) { }
    } else if(d==5){
        DCE::CMD_EnterGo enter(m_dwPK_Device, iMediaPluginID, internal_streamID);
        if(SendCommand(enter)) { }
    }

}

void DCE::qOrbiter::JogStream(QString jump) //jumps position in stream for jog
{

    CMD_Jump_to_Position_in_Stream jog(m_dwPK_Device, this->m_dwPK_Device_NowPlaying, jump.toStdString(), internal_streamID  );
    SendCommand(jog);

}


/*
  Show advanced buttons is for the ir or other controls used to send specific commands to a device. It comes in the form of a data grid initially that lists
  the different devices. This can be cross - referenced with the now playing devices to show only relevant devices for the ui
  */
void DCE::qOrbiter::showAdvancedButtons()
{
    int cellsToRender= 0;

    int gHeight = 1;
    int gWidth = 8;
    string imgDG ="resetav_"+StringUtils::itos(m_dwPK_Device);
    int iData_Size=0;
    int GridCurRow = 0;
    int GridCurCol= 0;
    char *pData;
    pData = NULL;
    string m_sSeek = "";
    m_dwIDataGridRequestCounter++;
    int iOffset = 0;
    string option ="";
    bool isSuccessfull;
    int pkVar = 0;
    string valassign = "";
    CMD_Populate_Datagrid cmd_populate_device_grid(m_dwPK_Device, iPK_Device_DatagridPlugIn, StringUtils::itos( m_dwIDataGridRequestCounter ), string(imgDG), 91, option, 0, &pkVar, &valassign,  &isSuccessfull, &gHeight, &gWidth );

    if (SendCommand(cmd_populate_device_grid))
    {

        //CMD_Request_Datagrid_Contents(long DeviceIDFrom, long DeviceIDTo,                   string sID,                                              string sDataGrid_ID,int iRow_count,int iColumn_count,bool bKeep_Row_Header,bool bKeep_Column_Header,bool bAdd_UpDown_Arrows,string sSeek,int iOffset,    char **pData,int *iData_Size,int *iRow,int *iColumn
        DCE::CMD_Request_Datagrid_Contents req_device_grid( long(m_dwPK_Device), long(iPK_Device_DatagridPlugIn), StringUtils::itos( m_dwIDataGridRequestCounter ), string(imgDG),    int(gWidth), int(gHeight),           false, false,        true,   string(m_sSeek),    int(iOffset),  &pData,         &iData_Size, &GridCurRow, &GridCurCol );
        if(SendCommand(req_device_grid))
        {
            DataGridTable *pDataGridTable = new DataGridTable(iData_Size,pData,false);
            cellsToRender= pDataGridTable->GetRows();

            LoggerWrapper::GetInstance()->Write(LV_CRITICAL, "Advanced AV  Grid Dimensions: Height %d, Width %d", gHeight, gWidth);

            QString cellTitle;
            QString fk_file;
            QString filePath;
            bool isActive = false;
            int index;
            for(MemoryDataTable::iterator it=pDataGridTable->m_MemoryDataTable.begin();it!=pDataGridTable->m_MemoryDataTable.end();++it)
            {

                DataGridCell *pCell = it->second;
                const char *pPath = pCell->GetImagePath();
                filePath = QString::fromUtf8(pPath);
                fk_file = pCell->GetValue();
                cellTitle = QString::fromUtf8(pCell->m_Text);
                index = pDataGridTable->CovertColRowType(it->first).first;

                //cell title is device and heriarchy
                // fk_file seems to be device name and heirachy
                //
                QStringList splitter;
                splitter = cellTitle.split("/");

                if(fk_file.toInt()== m_dwPK_Device_NowPlaying ||
                        fk_file.toInt()== m_dwPK_Device_NowPlaying_Audio||
                        fk_file.toInt()== m_dwPK_Device_NowPlaying_Video||
                        fk_file.toInt()==m_dwPK_Device_CaptureCard){
                    isActive=true;
                } else {
                    isActive=false;
                }

                if(isActive){
                    emit addDevice(new AvDevice(fk_file.toInt(), splitter.at(0), splitter.at(splitter.length()-2), NULL, -1, isActive ));
                }

            }
        }
    }
}

void DCE::qOrbiter::movePlaylistEntry(QString pos, int index)
{

    if (pos == "+")
    {
        CMD_Move_Playlist_entry_Up move_entry_up(m_dwPK_Device, iMediaPluginID, index);
        SendCommand(move_entry_up);
    }
    else
    {
        CMD_Move_Playlist_entry_Down move_entry_down(m_dwPK_Device, iMediaPluginID, index);
        SendCommand(move_entry_down);
    }
}

void DCE::qOrbiter::addToPlaylist(bool now, std::string playlist)
{
    /*
      found out this command doesnt exist and need to be created. ack.
      */
}

void DCE::qOrbiter::grabScreenshot(QString fileWithPath)
{
    emit commandResponseChanged("Requesting id for: "+ fileWithPath);
    screenieData =NULL;         //screenshot data using the char** data structure for passing of data
    screenieDataSize=0;       //var for size of data
    string s_format ="JPG";   //the format we want returned
    int imageH;                 //image height of desired screenshot
    int imageW;                 //width of desired screenshot
    string sDisableAspectLock = "0";


    //  qDebug() << fileWithPath;
    int gHeight = 0;
    int gWidth = 0;
    int pkVar = 0;
    string valassign ="";
    bool isSuccessfull;// = "false";
    string m_sGridID ="thumbs_"+StringUtils::itos(m_dwPK_Device); // the string identifier on the type of grid
    string m_sSeek;
    int iData_Size=0;
    int GridCurRow = 0;
    int GridCurCol= 0;

    char *pData;
    pData = NULL;
    m_dwIDataGridRequestCounter++;

    CMD_Populate_Datagrid cmd_populate_attribute_grid(m_dwPK_Device, iPK_Device_DatagridPlugIn, StringUtils::itos( m_dwIDataGridRequestCounter ), string(m_sGridID), 31, QString::number(i_ea).toStdString(), 0, &pkVar, &valassign,  &isSuccessfull, &gHeight, &gWidth );

    if (SendCommand(cmd_populate_attribute_grid))
    {   m_dwIDataGridRequestCounter++;
        /*
              initial request to populate the text only grid as denoted by the lack of a leading "_" as in _MediaFile_43
              this way, we can safely check empty grids and error gracefully in the case of no matching media
              */

        string imgDG = m_sGridID; //standard text grid with no images. this will not crash the router if requested and its empty, picture grids will

        //CMD_Request_Datagrid_Contents(long DeviceIDFrom, long DeviceIDTo,                   string sID,                                              string sDataGrid_ID,int iRow_count,int iColumn_count,bool bKeep_Row_Header,bool bKeep_Column_Header,bool bAdd_UpDown_Arrows,string sSeek,int iOffset,    char **pData,int *iData_Size,int *iRow,int *iColumn
        DCE::CMD_Request_Datagrid_Contents req_data_grid( long(m_dwPK_Device), long(iPK_Device_DatagridPlugIn), StringUtils::itos( m_dwIDataGridRequestCounter ), string(m_sGridID),    int(gWidth), int(gHeight),           false, false,        true,   string(m_sSeek),    0,  &pData,         &iData_Size, &GridCurRow, &GridCurCol );
        if(SendCommand(req_data_grid))
        {

            //not sure what its for
            //creating a dg table to check for cells. If 0, then we error out and provide a single "error cell"
            DataGridTable *pDataGridTable = new DataGridTable(iData_Size,pData,false);


            LoggerWrapper::GetInstance()->Write(LV_CRITICAL, "Attribute Datagrid Dimensions: Height %d, Width %d", gHeight, gWidth);

            QString cellTitle;
            QString cellAttribute;
            QString cellfk;
            DataGridCell *pCell;
            for(MemoryDataTable::iterator it=pDataGridTable->m_MemoryDataTable.begin();it!=pDataGridTable->m_MemoryDataTable.end(); it++)
            {
                pCell= it->second;
                cellTitle = pCell->GetText();
                cellAttribute = pCell->GetValue();
                cellfk = pCell->GetValue();
                emit addScreenShotVar(new screenshotAttributes( cellfk, cellTitle, cellAttribute.prepend("!A") ));
            }
            pDataGridTable->ClearData();
            delete pDataGridTable;
            delete []pData; pData=NULL;
            pDataGridTable=NULL;

        }

        int iEK_File = 0;

        CMD_Get_ID_from_Filename getFileID(m_dwPK_Device, iMediaPluginID, fileWithPath.toStdString(), &iEK_File);
        string fResp = "";
        if(SendCommand(getFileID, &fResp) && fResp == "OK" && iEK_File !=0)
        {
            QString fk;
            fk.append("!F"+ QString::number(iEK_File));
            emit commandResponseChanged("Screenshot filename: "+fk);
            // string *fk = StringUtils::itos(&iEK_File);
            screenshotAttributes *t(new screenshotAttributes(fk, QString("Filename"),fk ));
            emit addScreenShotVar(t);
        }
    }
    emit screenshotVariablesReady();



    CMD_Get_Video_Frame grabMediaScreenshot(long(m_dwPK_Device), long(m_dwPK_Device_NowPlaying), sDisableAspectLock,internal_streamID, 800 , 800, &screenieData, &screenieDataSize, &s_format);
    string mpResp= "";

    if(SendCommand(grabMediaScreenshot, &mpResp) && mpResp=="OK")
    {

        QByteArray screenShotData;
        QImage t;
        screenShotData.setRawData(screenieData, screenieDataSize);
        t.loadFromData(screenShotData);
        emit screenShotReady(t);
    }
    else
    {
        qDebug() << "Recieved bad or no image";
        QByteArray screenShotData;
        QImage t;
        screenShotData.setRawData(screenieData, screenieDataSize);
        t.loadFromData(screenShotData);
        emit screenShotReady(t);
        if(t.isNull()){
            emit mediaResponseChanged("Couldnt Create Screenshot!");
        }

    }

}


void DCE::qOrbiter::powerOff(QString deviceType)
{

}

void DCE::qOrbiter::CopyDisc()
{
}

void qOrbiter::ejectDisc(long diskDriveDevice, int iSlotNo)
{
    qDebug() << Q_FUNC_INFO;
    CMD_Eject_Disk eject(m_dwPK_Device, diskDriveDevice, iSlotNo);
    SendCommandNoResponse(eject);
}

void DCE::qOrbiter::ShowBookMarks()
{
    // bmark_134
    int cellsToRender= 0;
    bool isSuccessfull;
    string valassign="";
    int gHeight = 5;
    int gWidth = 1;
    string dgIdent ="bmark_"+StringUtils::itos(m_dwPK_Device);
    int iData_Size=0;
    int GridCurRow = 0;
    int GridCurCol= 0;
    char *pData;
    pData = NULL;
    string m_sSeek = "";
    string options = "0,"+StringUtils::itos(i_ea);
    m_dwIDataGridRequestCounter++;
    int offset = 0;
    int pkVar=0;
    CMD_Populate_Datagrid bookmarkGrid(m_dwPK_Device, iPK_Device_DatagridPlugIn, StringUtils::itos( m_dwIDataGridRequestCounter ), string(dgIdent), 35, options, DEVICETEMPLATE_Datagrid_Plugin_CONST, &pkVar, &valassign,  &isSuccessfull, &gHeight, &gWidth );
    string gResp="";
    if(SendCommand(bookmarkGrid, &gResp) && gResp == "OK")
    {
        //CMD_Request_Datagrid_Contents(                              long DeviceIDFrom,                long DeviceIDTo,                   string sID,                                string sDataGrid_ID, int iRow_count,int iColumn_count,        bool bKeep_Row_Header,bool bKeep_Column_Header,bool bAdd_UpDown_Arrows,string sSeek,       int iOffset,    char **pData,int *iData_Size,int *iRow,int *iColumn
        DCE::CMD_Request_Datagrid_Contents bookmarkGrid( long(m_dwPK_Device), long(iPK_Device_DatagridPlugIn), StringUtils::itos( m_dwIDataGridRequestCounter ), string(dgIdent),    int(gWidth),    int(gHeight),                      false,                 false,                                 true, string(m_sSeek), 0   ,  &pData,         &iData_Size, &GridCurRow, &GridCurCol );

        if(SendCommand(bookmarkGrid))
        {
            DataGridTable *pDataGridTable = new DataGridTable(iData_Size,pData,false);
            cellsToRender= pDataGridTable->GetRows();

            LoggerWrapper::GetInstance()->Write(LV_CRITICAL, "Bookmark Grid Dimensions: Height %d, Width %d", gHeight, gWidth);
            QString cellTitle;
            QString fk_file;
            QString filePath;

            int outer_index;
            outer_index = 0;
            for(MemoryDataTable::iterator it=pDataGridTable->m_MemoryDataTable.begin();it!=pDataGridTable->m_MemoryDataTable.end();++it)
            {

                DataGridCell *pCell = it->second;
                const char *pPath = pCell->GetImagePath();
                filePath = QString::fromUtf8(pPath);
                fk_file = pCell->GetValue();


                if(outer_index==2)
                {
                    //bookmarks.append(new BookmarkItem(cellTitle, titleImg, bookmarkImg));
                    outer_index = 0;
                }
                else
                {
                    outer_index++;
                }
            }
            //emit bookmarkList(bookmarks);
            pDataGridTable->ClearData();
            delete pDataGridTable;
            delete []pData; pData=NULL;
            pDataGridTable=NULL;
        }
        //   bookmarks.clear();

    }
}



void qOrbiter::OnDisconnect(){
    PurgeInterceptors();
    emit routerConnectionChanged(false);
    m_bOrbiterConnected = false;
    setNowPlaying(false);
    Disconnect();
    emit eventResponseChanged("Connection Lost");
    emit routerDisconnect();
}

void qOrbiter::OnUnexpectedDisconnect()
{
    PurgeInterceptors();
    LoggerWrapper::GetInstance()->Write(LV_STATUS,"QOrbiter::onUnexpectedDisconnect %d", m_dwPK_Device);
    emit routerConnectionChanged(false);
    pthread_cond_broadcast( &m_listMessageQueueCond );
    Disconnect();
}

void qOrbiter::OnReload()
{
    PurgeInterceptors();
    qDebug() << "On Reload Triggered@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@";
    LoggerWrapper::GetInstance()->Write(LV_STATUS,"Command_Impl::OnReload %d", m_dwPK_Device);
    m_bOrbiterConnected = false;
    m_bRouterReloading = true;
    setNowPlaying(false);
    BindMediaRemote(false);
    char *pData;
    int iSize;
    pData = NULL;
    iSize = 0;
    DCE::CMD_Orbiter_Registered unregister(m_dwPK_Device, iOrbiterPluginID, StringUtils::itos(m_dwPK_Device) ,i_user, StringUtils::itos(i_ea), i_room, &pData, &iSize);
    SendCommand(unregister);
    pthread_cond_broadcast( &m_listMessageQueueCond );

#ifdef LINK_TO_ROUTER
    if(NULL != m_pRouter && m_pRouter->IsPlugin(m_pcRequestSocket->m_dwPK_Device))
        m_pRouter->Reload();
#endif
    emit routerReload();
#ifndef __ANDROID__
#ifndef Q_OS_MAC
    pthread_yield();
#endif
#endif
    emit routerReloading("Reloading");
    emit routerConnectionChanged(false);
    if(m_bIsOSD){
        qDebug() << "Is osd, exiting";
        deinitialize();
    } else {
        Disconnect();
    }


}


bool qOrbiter::OnReplaceHandler(string msg)
{
    PurgeInterceptors();
    // qDebug() << Q_FUNC_INFO;
    emit commandResponseChanged("Disconnecting due to device with same ID connecting.");
    //  qDebug() << "Message " << msg.c_str();
    registerDevice(i_user,QString(i_ea), i_room);
    emit routerReplace();
    // deinitialize();
    return true;

}

void DCE::qOrbiter::extraButtons(QString button){


    string cResp ="";
    if(button.toLower()=="enter/go"){

    }else if(button.toLower() == "livetv"){
        CMD_Live_AV_Path selectLiveTvPath(m_dwPK_Device, iMediaPluginID, StringUtils::itos(i_ea), true);
        SendCommand(selectLiveTvPath);
    } else if(button.toLower() == "schedule"){

    } else if(button.toLower() == "recordings"){
        CMD_Recorded_TV_Menu showRecorded(m_dwPK_Device, m_dwPK_Device_NowPlaying);
        SendCommand(showRecorded);
    } else if(button.toLower() == "music"){
        CMD_Music showMusic(m_dwPK_Device, m_dwPK_Device_NowPlaying );
        SendCommand(showMusic);
    } else if(button.toLower() == "guide"){
        DCE::CMD_Guide showGuide(m_dwPK_Device, m_dwPK_Device_NowPlaying );
        SendCommand(showGuide);
    } else if(button.toLower() == "showmenu"){
        CMD_Menu_Show_Menu showMenu(m_dwPK_Device, m_dwPK_Device_NowPlaying );
        SendCommand(showMenu);
    } else if(button.toLower() == "menu"){
        DCE::CMD_Menu menu(m_dwPK_Device, m_dwPK_Device_NowPlaying, "", internal_streamID);
        SendCommand(menu);
    } if(button.toLower() == "info"){
        CMD_Info showInfo(m_dwPK_Device, m_dwPK_Device_NowPlaying, "" );
        SendCommand(showInfo);
    } else if(button.toLower() == "favorites"){
        CMD_Favorites showFav(m_dwPK_Device, m_dwPK_Device_NowPlaying );
        SendCommand(showFav);
    }else if(button.toLower() == "record"){
        CMD_Record record(m_dwPK_Device, m_dwPK_Device_NowPlaying );
        SendCommand(record);
    } else if(button.toLower() == "help"){
        CMD_Help showHelp(m_dwPK_Device, m_dwPK_Device_NowPlaying );
        SendCommand(showHelp);
    } else if(button.toLower() == "channelbookmark"){

    }if(button.toLower() == "exit"){
        CMD_Exit exitAVscreen(m_dwPK_Device, m_dwPK_Device_NowPlaying);
        SendCommand(exitAVscreen);
        return;
    } else if(button.toLower()=="l2"){
        CMD_L2 ps3_l2(this->m_dwPK_Device, m_dwPK_Device_NowPlaying);
        if(SendCommand(ps3_l2, &cResp) && cResp=="OK"){
            emit commandComplete();
        } else {
            emit commandFailed();
        }
        return;
    } else if(button.toLower()=="l1"){
        CMD_L1 ps3_l1(this->m_dwPK_Device, iMediaPluginID);
        if(SendCommand(ps3_l1, &cResp) && cResp=="OK"){
            emit commandComplete();
        } else {
            emit commandFailed();
        }
        return;
    }else if(button.toLower()=="l3"){
        CMD_L3 ps3_l3(this->m_dwPK_Device, iMediaPluginID);
        if(SendCommand(ps3_l3, &cResp) && cResp=="OK"){
            emit commandComplete();
        } else {
            emit commandFailed();
        }
        return;
    }else if(button.toLower()=="r1"){
        CMD_R1 ps3_r1(this->m_dwPK_Device, iMediaPluginID);
        if(SendCommand(ps3_r1, &cResp) && cResp=="OK"){
            emit commandComplete();
        } else {
            emit commandFailed();
        }
        return;
    }else if(button.toLower()=="r2"){
        CMD_R2 ps3_r2(this->m_dwPK_Device, iMediaPluginID);
        if(SendCommand(ps3_r2, &cResp) && cResp=="OK"){
            emit commandComplete();
        } else {
            emit commandFailed();
        }
        return;
    }else if(button.toLower()=="r3"){
        CMD_R3 ps3_r3(this->m_dwPK_Device, iMediaPluginID);
        if(SendCommand(ps3_r3, &cResp) && cResp=="OK"){
            emit commandComplete();
        } else {
            emit commandFailed();
        }
        return;
    }else if(button.toLower()=="psbutton"){
        CMD_PS_Playstation ps3_btn(this->m_dwPK_Device, iMediaPluginID);
        if(SendCommand(ps3_btn, &cResp) && cResp=="OK"){
            emit commandComplete();
        } else {
            emit commandFailed();
        }
        return;
    }else if(button.toLower()=="start"){
        CMD_Start start(this->m_dwPK_Device, iMediaPluginID);
        if(SendCommand(start, &cResp) && cResp=="OK"){
            emit commandComplete();
        } else {
            emit commandFailed();
        }
        return;
    }else if(button.toLower()=="select"){
        CMD_Select select_cmd(this->m_dwPK_Device, iMediaPluginID);
        if(SendCommand(select_cmd, &cResp) && cResp=="OK"){
            emit commandComplete();
        } else {
            emit commandFailed();
        }
        return;
    }else if(button.toLower()=="triangle"){
        CMD_Triangle triangle (this->m_dwPK_Device, iMediaPluginID);
        if(SendCommand(triangle, &cResp) && cResp=="OK"){
            emit commandComplete();
        } else {
            emit commandFailed();
        }
        return;
    }else if(button.toLower()=="square"){
        CMD_Square square(this->m_dwPK_Device, iMediaPluginID);
        if(SendCommand(square, &cResp) && cResp=="OK"){
            emit commandComplete();
        } else {
            emit commandFailed();
        }
        return;
    }else if(button.toLower()=="x"){
        CMD_X x(this->m_dwPK_Device, iMediaPluginID);
        if(SendCommand(x, &cResp) && cResp=="OK"){
            emit commandComplete();
        } else {
            emit commandFailed();
        }
        return;
    }else if(button.toLower()=="circle"){
        CMD_Circle circle(this->m_dwPK_Device, iMediaPluginID);
        if(SendCommand(circle, &cResp) && cResp=="OK"){
            emit commandComplete();
        } else {
            emit commandFailed();
        }
        return;
    }else if(button.toLower()=="home"){
        CMD_Home home(this->m_dwPK_Device, iMediaPluginID);
        if(SendCommand(home, &cResp) && cResp=="OK"){
            emit commandComplete();
        } else {
            emit commandFailed();
        }
        return;
    }else if(button.toLower()=="y"){
        CMD_Yellow y(this->m_dwPK_Device, iMediaPluginID);
        if(SendCommand(y, &cResp) && cResp=="OK"){
            emit commandComplete();
        } else {
            emit commandFailed();
        }
        return;
    }else if(button.toLower()=="a"){
        CMD_A a(this->m_dwPK_Device, iMediaPluginID);
        if(SendCommand(a, &cResp) && cResp=="OK"){
            emit commandComplete();
        } else {
            emit commandFailed();
        }
        return;
    }else if(button.toLower()=="b"){
        CMD_B b(this->m_dwPK_Device, iMediaPluginID);
        if(SendCommand(b, &cResp) && cResp=="OK"){
            emit commandComplete();
        } else {
            emit commandFailed();
        }
        return;
    }else if(button.toLower()=="xbox"){
        CMD_Home xbox_home(this->m_dwPK_Device, iMediaPluginID);
        if(SendCommand(xbox_home, &cResp) && cResp=="OK"){
            emit commandComplete();
        } else {
            emit commandFailed();
        }
        return;
    } else if (button.toLower()=="p1"){
        CMD_Game_1P_Start CMD_Game_1P_Start(this->m_dwPK_Device,iMediaPluginID);
        if(SendCommand(CMD_Game_1P_Start,&cResp) && cResp=="OK"){
            emit commandComplete();
        } else {
            emit commandFailed();
        }
        return;

    }else if (button.toLower()=="p2"){
        CMD_Game_2P_Start CMD_Game_2P_Start(this->m_dwPK_Device,iMediaPluginID);
        if(SendCommand(CMD_Game_2P_Start,&cResp) && cResp=="OK"){
            emit commandComplete();
        } else {
            emit commandFailed();
        }
        return;

    }else if (button.toLower()=="p3"){
        CMD_Game_3P_Start CMD_Game_3P_Start(this->m_dwPK_Device,iMediaPluginID);
        if(SendCommand(CMD_Game_3P_Start,&cResp) && cResp=="OK"){
            emit commandComplete();
        } else {
            emit commandFailed();
        }
        return;

    }else if (button.toLower()=="p4"){
        CMD_Game_4P_Start CMD_Game_4P_Start(this->m_dwPK_Device,iMediaPluginID);
        if(SendCommand(CMD_Game_4P_Start,&cResp) && cResp=="OK"){
            emit commandComplete();
        } else {
            emit commandFailed();
        }
        return;
    }

}

void DCE::qOrbiter::saveScreenAttribute(QString attribute)
{

    emit mediaResponseChanged("Saving Screenshot for attribute: "+attribute);
    string sAttribute = attribute.toStdString();
    DCE::CMD_Make_Thumbnail thumb(m_dwPK_Device, iMediaPluginID, sAttribute, screenieData,screenieDataSize );
    string cResp = "";
    if(SendCommand(thumb))
        cleanupScreenshotData();
}

void DCE::qOrbiter::newOrbiter()
{
    //CMD_New_Orbiter newOrbiterDevice(int devicefrom, int deviceto, string sType, int iPK_Users, int iPK_devicetemplate, string sMacAddress, int pk_room, int width, int height, int skin, int lang, int size, int pkdevice);
    //SendCommand(newOrbiterDevice);
}

/*
          re-implementing from original orbiter as part of the orbiter setup. i dont know how it all works, but i have an idea
          PromptFor looks for the specific item it needs a list of, like users or rooms and then PromptUser will display the information
          on-screen so the user can choose and then a map of choices is broken down and submitted with the new orbiter command.
          line 146 in orbiter renderer.cpp for reference.
          */
int qOrbiter::PromptFor(std::string sToken)
{
    Event_Impl event_Impl(DEVICEID_MESSAGESEND, 0, dceIP.toStdString().c_str());
    qDebug() << "Messaging core ip" << dceIP.toStdString().c_str();
    string sResults;
    DCE::CMD_Get_Orbiter_Options_DT CMD_Get_Orbiter_Options_DT(m_dwPK_Device, DEVICETEMPLATE_Orbiter_Plugin_CONST, BL_SameHouse,
                                                               sToken,&sResults);

    CMD_Get_Orbiter_Options_DT.m_pMessage->m_eExpectedResponse = ER_ReplyMessage;
    Message *pResponse = event_Impl.SendReceiveMessage( CMD_Get_Orbiter_Options_DT.m_pMessage );
    if( !pResponse || pResponse->m_dwID != 0 )
    {
        if(pResponse)
            delete pResponse;

        qDebug() << "Sorry.  There is a problem getting the list of "<< sToken.c_str();
        return 0;
    }
    CMD_Get_Orbiter_Options_DT.ParseResponse( pResponse );
    delete pResponse;

    map<int,string> mapResponse;
    vector<string> Choices;
    StringUtils::Tokenize(sResults,"\n",Choices);
    QList <PromptData*> *promptList = new QList<PromptData*>();
    if( sToken=="Size" )
        mapResponse[0]="Default";

    for(vector<string>::iterator it = Choices.begin(); it != Choices.end(); ++it)
    {
        string sChoise = *it;
        string::size_type pos=0;
        int Choice = atoi(StringUtils::Tokenize(sChoise,"\t",pos).c_str());
        string sDescription = StringUtils::Tokenize(sChoise,"\t",pos);
        QString t = QString::fromStdString(sDescription);
        PromptData *p = new PromptData(QString::fromStdString(sDescription), Choice);
        promptList->append(p);

        if( Choice && sDescription.size() )
            mapResponse[Choice]=sDescription;
    }

    if (sToken=="Users"){
        emit promptResponse(1, promptList);
    }
    else if(sToken=="Room"){
        emit promptResponse(2, promptList);
    }

    return PromptUser("Please select the " + sToken,0,&mapResponse);
}

int qOrbiter::PromptUser(std::string sPrompt, int iTimeoutSeconds, map<int, std::string> *p_mapPrompts)
{
    return 0;
}

int qOrbiter::DeviceIdInvalid(){
    emit commandResponseChanged("Device ID is invalid. Finding Existing Orbiters of this type");
    //QApplication::processEvents(QEventLoop::AllEvents);
    QList<QObject*> * temp_orbiter_list = new QList<QObject*>;

    map<int,string> mapDevices;
    int dt = DEVICETEMPLATE_qOrbiter_CONST;
    if(m_bIsOSD){
        dt = DEVICETEMPLATE_OnScreen_qOrbiter_CONST;
    }
    GetDevicesByTemplate(dt,&mapDevices);
    if( mapDevices.size()==0 )
    {
        emit commandResponseChanged("No orbiters of this type found. Would you like to setup a new one?");
        //        //QApplication::processEvents(QEventLoop::AllEvents);
        populateSetupInformation();
        return 0;
    }
    else{
        clearExistingOrbiters();
        for(map<int,string>::iterator it=mapDevices.begin();it!=mapDevices.end();++it)
        {
            int i = (int)it->first;
            QString s = QString::fromStdString(it->second);

            ExistingOrbiter *f = new ExistingOrbiter((int)it->first,QString::fromStdString(it->second));
            emit addExistingOrbiter(f);
            cout << it->first << " " << it->second << endl;
        }
        emit commandResponseChanged("Returning List of Orbiters");

        emit deviceInvalid();
        return 0;
    }

}

int qOrbiter::SetupNewOrbiter()
{
    LoggerWrapper::GetInstance()->Write(LV_STATUS,"start SetupNewOrbiter");
    //  qDebug() << "Opening setup connection via Event_Impl to " << dceIP.toStdString().c_str();
    Event_Impl event_Impl(DEVICEID_MESSAGESEND, 0, dceIP.toStdString().c_str());
    while(true)
    {
        string sResponse;
        if( !event_Impl.m_pClientSocket->SendString("READY") || !event_Impl.m_pClientSocket->ReceiveString(sResponse) || sResponse.size()==0 )
        {
            emit commandResponseChanged("Setup connection hung");
            // qDebug() << "setup error in socket";
            commandResponseChanged(QString::fromStdString(sResponse));
            return 0;  // Something went wrong
        }
        else
        {
            if( sResponse=="YES" )
                break;
            Sleep(2000);
        }
    }

    LoggerWrapper::GetInstance()->Write(LV_STATUS,"Calling CMD_NEW_ORBITER");
    int PK_Device=0;

    string sType = "Linux";
    statusMessage("Setting up orbiter with core");

    DCE::CMD_New_Orbiter_DT CMD_New_Orbiter_DT(
                m_dwPK_Device,
                DEVICETEMPLATE_Orbiter_Plugin_CONST,
                BL_SameHouse,
                sType,
                sPK_Users,
                DEVICETEMPLATE_qOrbiter_CONST ,
                m_sMacAddress,
                sPK_Room,
                sWidth,
                sHeight,
                sPK_Skin,
                sPK_Lang,
                1,
                &PK_Device
                );

    CMD_New_Orbiter_DT.m_pMessage->m_eExpectedResponse = ER_ReplyMessage;
    Message *pResponse = event_Impl.SendReceiveMessage( CMD_New_Orbiter_DT.m_pMessage );
    if( !pResponse || pResponse->m_dwID != 0 )
    {
        if(pResponse)
            delete pResponse;
        emit commandResponseChanged("SetupNewOrbiter unable to create orbiter");
        LoggerWrapper::GetInstance()->Write(LV_CRITICAL,"SetupNewOrbiter unable to create orbiter");
        emit commandResponseChanged("Sorry.  There is a problem creating the new orbiter.  Please check the logs.");
        return 0;
    }

    CMD_New_Orbiter_DT.ParseResponse( pResponse );
    delete pResponse;


    if( !PK_Device )
    {
        LoggerWrapper::GetInstance()->Write(LV_CRITICAL,"SetupNewOrbiter unable to create orbiter #2");
        emit commandResponseChanged("Sorry.  Orbiter Plugin could not create the device for some reason.  Please check the logs.");
        return 0;
    }

    statusMessage("success, the device ID is:"+ PK_Device);
    LoggerWrapper::GetInstance()->Write(LV_STATUS,"SetupNewOrbiter new orbiter %d",PK_Device);
    return PK_Device;  // Retry loading as the specified device
}


void qOrbiter::CreateChildren(){
    if(m_bIsOSD){
        emit commandResponseChanged("OSD QOrbiter ::creating children");
        for( int i=0; i < (int)m_pData->m_vectDeviceData_Impl_Children.size(); i++ )
        {
            DeviceData_Impl *pDeviceData_Impl_Child = m_pData->m_vectDeviceData_Impl_Children[i];
            //  childrenDeviceList.insert(pDeviceData_Impl_Child->m_dwPK_Device, QString::fromStdString(pDeviceData_Impl_Child->m_sDescription));
            // This device was marked as disabled
            if (pDeviceData_Impl_Child->m_bDisabled)
            {
                LoggerWrapper::GetInstance()->Write(LV_WARNING, "Child device %d is disabled", pDeviceData_Impl_Child->m_dwPK_Device);
                continue;
            }
            LoggerWrapper::GetInstance()->Write(LV_WARNING, "Creating child %d", pDeviceData_Impl_Child->m_dwPK_Device);

            // This device has it's own executible. Try to spawn it. If that fails, we will try to create it ourselves
            if( pDeviceData_Impl_Child->m_bImplementsDCE && !pDeviceData_Impl_Child->m_bIsEmbedded )
            {
                if( SpawnChildDevice(pDeviceData_Impl_Child->m_dwPK_Device,pDeviceData_Impl_Child->m_sCommandLine) )
                    continue;
            }
            Event_Impl *pEvent = m_pEvent->CreateEvent( pDeviceData_Impl_Child->m_dwPK_DeviceTemplate, m_pPrimaryDeviceCommand->m_pEvent->m_pClientSocket, pDeviceData_Impl_Child->m_dwPK_Device );
            if ( !pEvent )
            {
                pEvent = new Event_Impl( m_pPrimaryDeviceCommand->m_pEvent->m_pClientSocket, pDeviceData_Impl_Child->m_dwPK_Device );
                LoggerWrapper::GetInstance()->Write( LV_WARNING, "Note: Device manager has attached a device of type %d that this has no custom event handler for.  It will not fire events.",
                                                     pDeviceData_Impl_Child->m_dwPK_DeviceTemplate);
            }
            Command_Impl *pCommand = m_pPrimaryDeviceCommand->CreateCommand( pDeviceData_Impl_Child->m_dwPK_DeviceTemplate, m_pPrimaryDeviceCommand, pDeviceData_Impl_Child, pEvent );
            if ( !pCommand )
            {
                pCommand = new Command_Impl(m_pPrimaryDeviceCommand, pDeviceData_Impl_Child, pEvent, m_pRouter);
                pCommand->m_bGeneric=true;
                LoggerWrapper::GetInstance()->Write(LV_WARNING, "Note: Device manager has attached a device of type %d that this has no custom handler for.  This is normal for IR.", pDeviceData_Impl_Child->m_dwPK_DeviceTemplate);
            }
            pCommand->m_pParent = this;
            // pCommand->CreateChildren();
            m_mapCommandImpl_Children[pDeviceData_Impl_Child->m_dwPK_Device] = pCommand;
        }

    } else {
        emit commandResponseChanged("Non OSD QOrbiter::Creating Children");
        emit commandResponseChanged("Size of children devices::"+QString::number((int)m_pData->m_vectDeviceData_Impl_Children.size()));
        for( int i=0; i < (int)m_pData->m_vectDeviceData_Impl_Children.size(); i++ ){

            emit commandResponseChanged("Finding Child devices...");
            DeviceData_Impl *pDeviceData_Impl_Child = m_pData->m_vectDeviceData_Impl_Children[i];

            // This device was marked as disabled
            if (pDeviceData_Impl_Child->m_bDisabled){
                LoggerWrapper::GetInstance()->Write(LV_WARNING, "Child device %d is disabled", pDeviceData_Impl_Child->m_dwPK_Device);
                continue;
            }
            emit commandResponseChanged("Current device template::"+QString::number(pDeviceData_Impl_Child->m_dwPK_DeviceTemplate));
            if (pDeviceData_Impl_Child->m_dwPK_DeviceTemplate == DEVICETEMPLATE_qMediaPlayer_CONST){
                int t = pDeviceData_Impl_Child->m_dwPK_Device;
                setqMediaPlayerID(t);
                emit commandResponseChanged("QMediaPlayer ID::"+t);
                //   emit qMediaPlayerIDChanged(qMediaPlayerID);
            }
        }
    }
    emit commandResponseChanged("Finished spawning children!");
    emit routerConnectionChanged(true);

}

void qOrbiter::CannotReloadRouter()
{
    qDebug() << Q_FUNC_INFO;
    QString reload_screen= QString("Screen_%1.qml").arg(QString::number(283));
    emit gotoQml(reload_screen);

}



void qOrbiter::populateSetupInformation()
{
    PromptFor("Users");
    PromptFor("Room");

}

void DCE::qOrbiter::adjustLighting(int level, myMap devices)
{
    myMap::iterator i;

    for (i = devices.begin(); i != devices.end(); ++i){
        string pResponse="";
        CMD_Set_Level basic(m_dwPK_Device , i.key(), StringUtils::itos(level));
        if(SendCommand(basic,&pResponse)){

        }

        emit commandResponseChanged(QString::fromStdString(pResponse.c_str()));

    }

}

void qOrbiter::adjustRoomLights(QString level)
{
    string param="";
    if(level.contains("-"))
    {
        param=level.remove("-").toStdString();
        param.insert(0,"-");
    }
    else{
        param=level.toStdString();
    }
    CMD_Set_Level al(m_dwPK_Device, iPK_Device_LightingPlugin,param);
    SendCommand(al);
    emit commandResponseChanged("Set lighting level to" +level);
}

void DCE::qOrbiter::prepareFileList(QString filterString)
{
    if(currentScreen != "Screen_47.qml"){

        b_cancelRequest = true;
        requestMore=false;
        return;
    }
    else{

    }


    //  mediaFilter.setMediaType(iPK_MediaType);
    requestMore = false;
    media_currentRow = 0;
    cellsToRender = 0;
    //pMediaGridTable = NULL;
    emit mediaResponseChanged("Initial media request for filter " + filterString);
#ifdef QT5
    //QApplication::processEvents(QEventLoop::AllEvents);
#endif
    //emit cleanupGrid();

    int gHeight = media_pageSeperator;            //how many rows we want
    int gWidth = 1;                      //how many columns we want. in this case, just the one
    int pkVar = 0;                       // ??
    int iOffset = 0;                      // ??
    int GridCurRow = 0;                   //the row to start from
    int GridCurCol= 0;                   //column to start from

    string valassign ="";              // ??
    bool isSuccessfull;// = "false";   // holdover from the old orbiter?

    string m_sGridID ="MediaFile_"+QString::number(m_dwPK_Device).toStdString(); //identfier that specifies the orbiter device it goes to
    string m_sSeek=media_seek; //the theoretical seek

    int iData_Size=0;
    char *pData;
    pData = NULL;

    m_dwIDataGridRequestCounter++;  //request counter dont know what its used for.

    QString s;

    s = filterString;//mediaFilter.getFilterString();


#ifdef QT5
    //QApplication::processEvents(QEventLoop::AllEvents);
#endif
    //qDebug() << s;
    CMD_Populate_Datagrid populateDataGrid(m_dwPK_Device, iPK_Device_DatagridPlugIn, StringUtils::itos( m_dwIDataGridRequestCounter ), string(m_sGridID), 63, s.toStdString(), 0, &pkVar, &valassign,  &isSuccessfull,  &gWidth, &gHeight);

    if (SendCommand(populateDataGrid))
    {

        /*
                      initial request to populate the text only grid as denoted by the lack of a leading "_" as in _MediaFile_43
                      this way, we can safely check empty grids and error gracefully in the case of no matching media
                      */

        //standard text grid with no images. this will not crash the router if requested and its empty, picture grids will

        //CMD_Request_Datagrid_Contents(long DeviceIDFrom, long DeviceIDTo,                   string sID,                                              string sDataGrid_ID,int iRow_count,int iColumn_count,bool bKeep_Row_Header,bool bKeep_Column_Header,bool bAdd_UpDown_Arrows,string sSeek,int iOffset,    char **pData,int *iData_Size,int *iRow,int *iColumn

        DCE::CMD_Request_Datagrid_Contents req_data_grid( long(m_dwPK_Device), long(iPK_Device_DatagridPlugIn), StringUtils::itos( m_dwIDataGridRequestCounter ), string(m_sGridID),    gHeight, gWidth,           false, false,        true,   string(m_sSeek),    iOffset,  &pData,         &iData_Size, &GridCurRow, &GridCurCol );
        if(SendCommand(req_data_grid))
        {
            //not sure what its for
            //creating a dg table to check for cells. If 0, then we error out and provide a single "error cell"
            DataGridTable * pMediaGridTable = new DataGridTable(iData_Size,pData,false);
            cellsToRender= pMediaGridTable->GetRows();

            LoggerWrapper::GetInstance()->Write(LV_CRITICAL, "Datagrid Dimensions: Height %d, Width %d", gHeight, gWidth);
            if (cellsToRender == 0)
            {
                //	      emit noMediaFound();
                //	        mediaFilter.noMedia();
                emit mediaResponseChanged("No Media");
                return;
                // exit ; //exit the loop because there is no grid? - eventually provide "no media" feedback
            }
            else
            {


                i_mediaModelRows = cellsToRender;
                emit gridModelSizeChange(cellsToRender);
                media_totalPages = (i_mediaModelRows / media_pageSeperator)+1; //16 being the items per page.
                setModelPages(media_totalPages);
                emit mediaResponseChanged(QString::number(media_totalPages)+ " pages from request, populating first page.");
                delete[] pData;
                pMediaGridTable->ClearData();
                delete pMediaGridTable;
                pData = NULL;
                pMediaGridTable = NULL;
                if(b_cancelRequest)
                    b_cancelRequest=false;{
                    requestPage(0);
                }

                //requestGenres(iPK_MediaType);
            }
        }
        /*
                  Datagrid params
                  # 4 PK_Variable (int) (Out)  The populate grid can optionally return a variable number
                                                to assign a value into. For example, the current path in
                                                the file grid.

                  # 5 Value To Assign (string) (Out) The value to assign into the variable.

                  # 10 ID (string)              For debugging purposes if problems arise with a request
                                                not being filled, or a grid not populated when it should be.
                                                If the Orbiter specified an ID when requesting the grid or populating it,
                                                 the Datagrid plug-in will log the ID and status so the develope

                  # 15 DataGrid ID (string)     A unique ID for this instance of the grid that will be passed with the
                                                Request Datagrid Contents command.

                  # 38 PK_DataGrid (int)        Which grid should be populated

                  # 39 Options (string)         The options are specific the type of grid (PK_Datagrid). These are not
                                                pre-defined. The grid generator and orbiter must both pass the options
                                                in the correct format for the type of grid.

                 # 40 IsSuccessful (bool) (Out) Returns false if the grid could not be populated. Perhaps there was no
                                                registered datagrid generator.

                 # 44 PK_DeviceTemplate (int)   If more than 1 plugin registered to handle this grid, this parameter
                                                 will be used to match teh right one
                 # 60 Width (int) (Out)         The width of the grid, in columns, if the width is determined at
                                                populate time, such as a file grid. If the whole size of the grid is unknown,
                                                such as the EPG grid, this should be 0.

                # 61 Height (int) (Out)         The height of the grid, in rows, if the heightis determined at populate time,
                                                such as a file grid. If the whole size of the grid is unknown, such as the EPG grid,
                                                 this should be 0.
            */
    }

}

void DCE::qOrbiter::cleanupGrid()
{
    emit commandResponseChanged("Clearing Grid");
    //emit clearPageGrid();
}

bool qOrbiter::checkLoadingStatus()
{
    if( requestMore == true )
    {
        if(currentScreen=="Screen_47.qml")
        {
            //emit commandResponseChanged("Count" + QString::number(i_currentMediaModelRow)+ "/" + QString::number(i_mediaModelRows));
            return true;
        }
        else
        {
            return false;
            emit clearModel();
        }
    }
    else
    {
        //emit commandResponseChanged("Loading Ended");
        return false;
    }
}


void qOrbiter::getFloorPlanImage(QString fp_path)
{
    char *picData = NULL;
    int picData_Size;
    picData_Size = 0;

    CMD_Request_File reqFile((long)m_dwPK_Device, (long)4 , fp_path.toStdString(), &picData, &picData_Size);
    string p_sResponse="";
    if(SendCommand(reqFile, &p_sResponse) && p_sResponse=="OK")
    {
#ifdef QT5
        //QApplication::processEvents(QEventLoop::AllEvents);
#endif

        emit floorPlanImageData( (const uchar*)picData, picData_Size);
    }
}

void qOrbiter::getFloorplanDeviceStatus(int device)
{
    string status="UNKNOWN";
    CMD_Get_Device_Status getDeviceStatus(m_dwPK_Device, iPK_Device_GeneralInfoPlugin, device, &status);
    string cResponse="";
    if(SendCommand(getDeviceStatus, &cResponse) && cResponse=="OK"){    }
    cResponse="";

    string state="UNKNOWN";
    CMD_Get_Device_State getDeviceState(m_dwPK_Device, iPK_Device_GeneralInfoPlugin, device, &state);
    if(SendCommand(getDeviceState, &cResponse) && cResponse=="OK"){ }

    emit floorplanDeviceStatus(QString::fromStdString(status), QString::fromStdString(state), device);
}

void qOrbiter::getScreenSaverImage(QString inc_requested_img_path)
{
    char *picData=NULL;
    int picData_Size;
    picData_Size = 0;
    CMD_Request_File reqFile((long)m_dwPK_Device, (long)4 , inc_requested_img_path.toStdString(), &picData, &picData_Size);
    string p_sResponse="";
    if(SendCommand(reqFile, &p_sResponse) && p_sResponse=="OK")
    {
#ifdef QT5
        //QApplication::processEvents(QEventLoop::AllEvents);
#endif
#ifndef __ANDROID__
#ifndef Q_OS_MAC
        pthread_yield();
#endif
#endif

        emit mediaResponseChanged("DCE::Recieved Screensaver image");
        emit currentScreenSaverImage(QByteArray(picData, picData_Size));

        delete picData;
        picData=NULL;
        picData_Size = 0;

    }
}

void DCE::qOrbiter::sendAvCommand(int deviceto, int command)
{
    string cmd_string;
    QString commandString =  QString::number(m_dwPK_Device) + " " + QString::number(deviceto) + " " + "1" + " " + QString::number(command);
    cmd_string = commandString.toStdString();
    DCE::Message *avMessage = new Message(cmd_string);
    SendMessageToRouter(avMessage);

}

void qOrbiter::sendStringMessage(QString msg)
{
    Message m(msg.toStdString());
    bool ok=true;
    SendMessage(&m,ok);
}

void DCE::qOrbiter::setGridSeperator(int sep)
{
    media_pageSeperator = sep;
    media_totalPages = (i_mediaModelRows / media_pageSeperator); //16 being the items per page.
    b_cancelRequest = true;
    requestMore = false;

    setModelPages(media_totalPages);
    emit pageSeperatorChanged(media_pageSeperator);




}

//<-dceag-c190-b->

/** @brief COMMAND: #190 - Enter/Go */
/** Select the highlighted item */
/** @param #41 StreamID */
/** ID of stream to apply */

void qOrbiter::CMD_EnterGo(int iStreamID,string &sCMD_Result,Message *pMessage)
//<-dceag-c190-e->
{
    emit dceGuiCommand(EnterGo);
    sCMD_Result="OK";
}
//<-dceag-c194-b->

/** @brief COMMAND: #194 - Toggle Power */
/** First time stops any media playing.  Second time turns the display off.  Third time powers off the media director. */
/** @param #8 On/Off */
/** Depending on each device On/Off can be interpreted differently, but in genereal On/Off has a value of 1 for on and 0 for Off */

void qOrbiter::CMD_Toggle_Power(string sOnOff,string &sCMD_Result,Message *pMessage)
//<-dceag-c194-e->
{

}

//<-dceag-c200-b->

/** @brief COMMAND: #200 - Move Up */
/** Move the highlight up */
/** @param #41 StreamID */
/** ID of stream to apply */

void qOrbiter::CMD_Move_Up(int iStreamID,string &sCMD_Result,Message *pMessage)
//<-dceag-c200-e->
{
    emit dceGuiCommand(MoveUp);
    sCMD_Result="OK";
}

//<-dceag-c201-b->

/** @brief COMMAND: #201 - Move Down */
/** Move the highlight down */
/** @param #41 StreamID */
/** ID of stream to apply */

void qOrbiter::CMD_Move_Down(int iStreamID,string &sCMD_Result,Message *pMessage)
//<-dceag-c201-e->
{
    emit dceGuiCommand(MoveDown);
    sCMD_Result="OK";
}

//<-dceag-c202-b->

/** @brief COMMAND: #202 - Move Left */
/** Move the highlight left */
/** @param #41 StreamID */
/** ID of stream to apply */

void qOrbiter::CMD_Move_Left(int iStreamID,string &sCMD_Result,Message *pMessage)
//<-dceag-c202-e->
{
    emit dceGuiCommand(MoveLeft);
}

//<-dceag-c203-b->

/** @brief COMMAND: #203 - Move Right */
/** Move the highlight right */
/** @param #41 StreamID */
/** ID of stream to apply */

void qOrbiter::CMD_Move_Right(int iStreamID,string &sCMD_Result,Message *pMessage)
//<-dceag-c203-e->
{
    emit dceGuiCommand(MoveRight);
}

//<-dceag-c240-b->

/** @brief COMMAND: #240 - Back / Prior Menu */
/** If at a remote control, forward to media plugin.  Otherwise go back 1 screen. */
/** @param #41 StreamID */
/** ID of stream to apply */

void qOrbiter::CMD_Back_Prior_Menu(int iStreamID,string &sCMD_Result,Message *pMessage)
//<-dceag-c240-e->
{
    emit dceGuiCommand(BackPriorMenu);
    sCMD_Result = "OK";
}

//<-dceag-c363-b->

/** @brief COMMAND: #363 - Back / Clear Entry */
/** If at a remote control, forward to media plugin.  Otherwise clear typing */

void qOrbiter::CMD_Back_Clear_Entry(string &sCMD_Result,Message *pMessage)
//<-dceag-c363-e->
{
    emit dceGuiCommand(BackClearEntry);
    sCMD_Result = "OK";
}

//<-dceag-c548-b->

/** @brief COMMAND: #548 - Menu */
/** Shows the main menu */
/** @param #9 Text */
/** A string indicating which menu should appear.  The parameter is only used for smart media devices */
/** @param #41 StreamID */
/** ID of stream to apply */

void qOrbiter::CMD_Menu(string sText,int iStreamID,string &sCMD_Result,Message *pMessage)
//<-dceag-c548-e->
{
    qDebug() << Q_FUNC_INFO;
    emit dceGuiCommand(Menu);
    sCMD_Result="OK";
}


void qOrbiter::pingCore()
{

    if(dceIP.toStdString()!=""){

        emit commandResponseChanged("initiating ping to core with address::"+dceIP);
        QString url =dceIP;
        if(!url.contains(QRegExp("(\\D)"))){

            emit commandResponseChanged("Host name provided, doing lookup");
            QHostInfo::lookupHost(url, this, SLOT(checkPing(QHostInfo)));
        }
        else{

            if(!m_bOrbiterConnected){
                emit commandResponseChanged("No hostname, checking installation");
                checkInstall();
            }
        }
    }
    else
    {
        return;
    }


    // TODO: add a network timeout for this so it returns faster for located non-lmce machines. Currently it only returns fast if the ip or hostname is totally invalid, i.e. no route. For online machines,
    //it takes a bit longer. solve by attatching A Qtimer checking process and force it to cancel requests that dont return in a reasonable(whatever that is) amount of time. 5 seconds? I mean, who is still on
    //dialup?

}

void qOrbiter::checkPing(QHostInfo info)
{

    emit commandResponseChanged("Ping router says response is: "+ info.lookupId());
    if (info.error() != QHostInfo::NoError){
        emit routerInvalid();
    }
    else{

        emit commandResponseChanged("ip address: " + info.addresses().at(0).toString());
        m_sHostName = info.addresses().at(0).toString().toStdString();
        m_sIPAddress = info.addresses().at(0).toString().toStdString();

        emit commandResponseChanged("Router found, checking for LinuxMCE installation");

        if(!m_bRunning ){
            emit commandResponseChanged("Checking for linuxmce installation" + dceIP);
            checkInstall();
        }
    }

}

void qOrbiter::checkInstall()
{
    emit commandResponseChanged("Checking for LinuxMCE installtion in checkInstall() at "+ dceIP);

    QString url = "http://"+dceIP+"/lmce-admin/index.php";
    QNetworkAccessManager *pingManager = new QNetworkAccessManager();

    connect(pingManager, SIGNAL(finished(QNetworkReply*)), this, SLOT(verifyInstall(QNetworkReply*)));
    QNetworkRequest s;
    QNetworkReply *badReply = pingManager->get(QNetworkRequest(url));

}

void qOrbiter::verifyInstall(QNetworkReply *r)
{
    if(r->bytesAvailable() !=0 && this->m_bOrbiterConnected == false)
    {
        emit routerFound(true);
        emit commandResponseChanged("Found installation, connecting.");
        if ( initialize() == true )
        {

            emit routerConnectionChanged(true);
            LoggerWrapper::GetInstance()->Write(LV_STATUS, "Connect OK");

            if( m_bLocalMode )
                RunLocalMode();
        } else{
            qDebug() << "Cannot Connect to router";
            this->m_bCancelSocketOp = true;
        }
    } else {
        emit routerFound(false);
    }

}



//<-dceag-c126-b->

/** @brief COMMAND: #126 - Guide */
/** Go to the media guide if applicable, otherwise forward to media plugin. */

void qOrbiter::CMD_Guide(string &sCMD_Result,Message *pMessage)
//<-dceag-c126-e->
{

}


void qOrbiter::getAttributeImage(QString param)
{
    CMD_Get_Attribute_Image attributeImage(m_dwPK_Device , iMediaPluginID );

}


void qOrbiter::showUiMenu()
{
    CMD_Set_Active_Menu showHome(this->m_dwPK_Device, this->m_dwPK_Device_NowPlaying, "Returning");
    SendCommand(showHome);
}



void qOrbiter::setAlarm(QString dataGridId, int row, int role, bool toggle, int grp)
{
    LoggerWrapper::GetInstance()->Write(LV_DEBUG, "qOrbiter.setAlarm start");
    if (grp != 0)
    {
        LoggerWrapper::GetInstance()->Write(LV_DEBUG, "qOrbiter.setAlarm grp != 0");
        CMD_Toggle_Event_Handler toggleAlarm(m_dwPK_Device, iPK_Device_eventPlugin, grp);
        string pResponse="";
        if (SendCommand(toggleAlarm, &pResponse) && pResponse =="OK"){
            LoggerWrapper::GetInstance()->Write(LV_STATUS, "qorbiter::setAlarm RESP = OK");
            emit updateItemData(dataGridId, row, role, QVariant::fromValue(toggle));
        }
        else
        {
            emit commandResponseChanged("Failed to toggle Alarm.");
        }
    }
}


void qOrbiter::getVolume()
{
    //DeviceData_Base *aDevice = m_dwPK_Device_NowPlaying_Audio;
    string level="";
    string pResp="";
    CMD_Get_Device_Data getAudioLevel(m_dwPK_Device,iMediaPluginID, m_dwPK_Device_NowPlaying, DEVICEDATA_Volume_Level_CONST, true, &level );
    if(SendCommand(getAudioLevel, &pResp) && pResp=="OK")
    {
        emit deviceAudioLevelChanged(QString::fromStdString(level).toInt());
    }
    else
    {

        emit deviceAudioLevelChanged(0);
    }
}


void qOrbiter::executeMessageSend(QVariantMap outGoing)
{


    QVariant l = outGoing["to"].toMap();
    QVariantList paramList = outGoing["params"].toList();
    QMap<long, string> map_params;
    foreach (QVariant t, paramList) {
        QVariantMap item = t.toMap();
        int f = item["paramno"].toInt();
        string a = item["val"].toString().toStdString();
        map_params.insert((long)f, a);
    }

    int cmd = outGoing["command"].toInt();
    long paramCount = outGoing["count"].toInt();
    //  long deviceTo = outGoing["to"].toInt();

    vector<class Message *> b;
    QStringList keys = outGoing["to"].toMap().keys();

    QString targets = keys.join(",");

    QString outMessage;
    outMessage.append('http://192.168.80.1 -targetType category -bl 5 1 5 1 809 251 0 9 "TESTING QOrbiter ALERT" 182 15 70 "test"');
    //(QString::fromLocal8Bit('dcerouter -targetType category -bl 5 1 5 1 809 251 0 9 "TESTING QORBITER ALERT" 182 15 70 "test"'));
    Message* m = new Message();
    m->m_dwPK_Device_From = m_dwPK_Device;
    m->m_sPK_Device_List_To =targets.toStdString();
    m->m_dwPK_Device_To = DEVICEID_LIST;
    m->m_mapParameters = map_params.toStdMap() ;
    m->m_dwMessage_Type = 1;
    m->m_dwID = cmd;

    m->m_bCanBuffer = false;
    m->m_eBroadcastLevel = BL_SameHouse;
    m->m_eRetry = MR_None;
    m->m_dwPriority = 1;
    string *msgResponse;
    //  qDebug() <<"Message content";
    //  qDebug() <<"Device From ==>" << m->m_dwPK_Device_From;
    //  qDebug() <<"Device to ==>" << m->m_sPK_Device_List_To.c_str();

    if(m->m_dwPK_Device_To != -1 && m->m_dwPK_Device_Template != -1 && m->m_dwPK_Device_Category_To !=-1)
        this->m_pPrimaryDeviceCommand->SendMessageToRouter(m);
}


void qOrbiter::checkRouterConnection()
{
    if(m_bQuit_get() == false){

    }
    if(RouterNeedsReload()){

    }

    if(this->m_bRunning){

    }
}


/** @brief COMMAND: #89 - Vol Up */
/** volume up */
/** @param #72 Repeat Command */
/** If specified, repeat the volume up this many times */

void qOrbiter::CMD_Vol_Up(int iRepeat_Command,string &sCMD_Result,Message *pMessage){}
//<-dceag-c89-e->
//<-dceag-c90-b->

/** @brief COMMAND: #90 - Vol Down */
/** volume down */
/** @param #72 Repeat Command */
/** If specified, repeat the volume down this many times. */

void qOrbiter::CMD_Vol_Down(int iRepeat_Command,string &sCMD_Result,Message *pMessage){}
//<-dceag-c90-e->
//<-dceag-c97-b->

/** @brief COMMAND: #97 - Mute */
/** mute */

void qOrbiter::CMD_Mute(string &sCMD_Result,Message *pMessage){

}
//<-dceag-c97-e->


void qOrbiter::setVariable(int pkvar ,QString val)
{
    DCE::CMD_Set_Variable setVar(m_dwPK_Device,this->iPK_Device_GeneralInfoPlugin, pkvar, val.toStdString());
    string resp ="";

    if(SendCommand(setVar, &resp) && resp=="OK"){
        qWarning("CMD_Set_Variable Sucessful!");
    } else
    {
        qWarning("CMD_Set_Variable Failed!");
    }
}

void qOrbiter::reInitialize(){

    qDebug() << "Initialize !!!!!!!!!!!!";
    if(this->m_pPrimaryDeviceCommand->m_bQuit_get() == true ){
        emit commandResponseChanged("Device set to quit");
    }

    this->m_pPrimaryDeviceCommand->Close();
    pthread_cond_broadcast( &m_listMessageQueueCond );


    if ((GetConfig() == true) && (Connect(PK_DeviceTemplate_get()) == true))
    {

        m_dwMaxRetries = 1;
        m_bRouterReloading = false;
        m_bReload = false;
        m_bOrbiterConnected = true;


        emit deviceValid(true);
        emit commandResponseChanged("Starting Manager");
        emit startManager(QString::number(m_dwPK_Device), dceIP);

        if(!getConfiguration()){
            exit(99);
        }

        registerDevice(i_user,QString(i_ea), i_room);
        CreateChildren();

        emit routerConnectionChanged(true);
    }else {
        emit routerConnectionChanged(false);
    }
}

void qOrbiter::authorizePrivateMedia(int mediaType, QString pin, int user){
    bool valid;
    string pResp = "";
    DCE::CMD_Verify_PIN checkPin(m_dwPK_Device, iPK_Device_SecurityPlugin,  user, pin.toStdString(), &valid );
    if(SendCommand(checkPin, &pResp) && pResp=="OK"){
        if(valid){

            setStringParam(mediaType, QString::number(user));
            emit mediaAuthChanged(user);
        }else{
            emit mediaAuthChanged(-1);
        }
    }

}
