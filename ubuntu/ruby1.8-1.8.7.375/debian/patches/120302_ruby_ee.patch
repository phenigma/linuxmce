commit ff1b93fd53b34e320c7017824bf70d40ec5065ff
Author: John Leach <john@johnleach.co.uk>
Date:   Sun Oct 21 00:58:14 2012 +0100

    Updated ruby EE patch

--- a/ChangeLog
+++ b/ChangeLog
@@ -201,6 +201,22 @@
 	  store->ex_data.sk.  [ruby-core:28907] [ruby-core:23971]
 	  [ruby-core:18121]
 
+Mon Oct 12 22:35:00 2011  Brent Roman  <brent@mbari.org>
+        
+	* fixed inverted NUL_P test in eval.c(cc_purge)
+        
+Mon Oct 11 17:55:00 2011  Brent Roman  <brent@mbari.org>
+        
+	* always includes GC.stress method, even if MBARI_API enabled
+        
+Mon Oct 10 23:15:00 2011  Brent Roman  <brent@mbari.org>
+
+        * MBARI 8 patchset wrapup
+        
+	* removed break; after JUMP_TAG
+        
+        * fixed GCC 4.6 compile warnings in eval.c and gc.c
+
 Thu Jun 30 12:52:56 2011  WATANABE Hirofumi  <eban@ruby-lang.org>
 
 	* ext/tk/extconf.rb (intptr_t, uintptr_t): support for the latest ActiveTcl with mingw.
@@ -1147,6 +1163,23 @@
 	* string.c (rb_str_inspect): wrong result of UTF-8 inspect because of
 	  the mistake of calculation.  reported by eban via IRC.
 
+Fri Feb  5 23:09:01 2010  Akinori MUSHA  <knu@iDaemons.org>
+
+	* ext/rational/rational.c: Added to provide a fast implementation
+	  of Fixnum#gcd (and maybe some others in the future) in C.  The
+	  base code was submitted by Kurt Stephens. [Feature #2561]
+
+	* ext/rational/lib/rational.rb: Moved from lib/rational.rb.  Make
+	  overall code optimization; submitted by Kurt Stephens.
+	  [Feature #2561]
+
+	* test/rational/test_rational.rb, test/rational/test_rational2.rb:
+	  Add tests for Rational, ported from trunk.
+
+	* test/rational/test_fixnum_gcd.rb: Add a test for Integer#gcd.
+	  Case values are only provided for i386 and amd64 at the moment;
+	  submitted by Kurt Stephens. [Feature #2561]
+
 Sun Jan 10 19:00:31 2010  Nobuyoshi Nakada  <nobu@ruby-lang.org>
 
 	* lib/webrick/accesslog.rb : Escape needed.
@@ -1716,6 +1749,11 @@
 	* eval.c (rb_thread_schedule): handle EBADF of select as well.
 	  [ruby-core:21264]
 
+Fri May 15 17:33:51 2009  Nobuyoshi Nakada  <nobu@ruby-lang.org>
+
+	* eval.c (rb_thread_join), ext/thread/thread.c (wake_one): adjusts
+	  targets of rest waiting threads to join.  [ruby-core:23457]
+
 Wed Apr  8 18:59:52 2009  NAKAMURA Usaku  <usa@ruby-lang.org>
 
 	* win32/win32.c (subtruct): check tv_sec.
@@ -1817,6 +1855,24 @@
 	* parse.y (IS_BEG): EXPR_CLASS should be treated like EXPR_BEG.
 	  [ruby-core:21453]
 
+Wed Mar 4 12:01:19 2009  Brent Roman  <brent@mbari.org>
+        
+        * rubysig.h:  assume non-Apple gcc on PowerPC is not using -mregnames
+        
+        * version.h:  bumped date
+        
+Wed Mar 1 12:01:19 2009  Brent Roman  <brent@mbari.org>
+        
+        * eval.c:  fixed missed volatile qualifiers
+        
+        * version.h:  bumped date, MBARI version 8A --> 8B
+        
+Wed Feb 27 12:01:19 2009  Brent Roman  <brent@mbari.org>
+        
+        * rubysig.c:  added support for __anyPowerPC__
+        
+        * version.h:  bumped date
+
 Wed Feb 25 15:15:52 2009  Nobuyoshi Nakada  <nobu@ruby-lang.org>
 
 	* node.h (rb_thread_raised_clear): should not clear flags other than
@@ -1838,6 +1894,16 @@
 	* win32/win32.c (winnt_stat): gets rid of strange behavior of
 	  GetFileAttributes().  [ruby-core:21269]
 
+Wed Feb 25 12:01:19 2009  Brent Roman  <brent@mbari.org>
+
+        * gc.c:  default GC.limit=2e6*sizeof(VALUE)
+        
+        * eval.c:  added RB_GC_GUARDs to eval_slit() & more volatile tweaks
+        
+        * re.c:  removed unneeded volatile qualifier & copy in rb_regcomp()
+        
+        * version.h:  bumped date, MBARI version 7A --> 8A
+
 Tue Feb 24 02:44:39 2009  Masatoshi SEKI  <m_seki@mva.biglobe.ne.jp>
 
 	* lib/erb.rb (PercentScanner): remove PercentScanner. fixed % after
@@ -1850,6 +1916,20 @@
 	* hash.c (rb_hash_s_create): set nil as the value if assoc length
 	  is not enough.  [ruby-core:21249]
 
+Tue Feb 24 00:01:19 2009  Brent Roman  <brent@mbari.org>
+
+        * cofigure.in:  added --enable-mbari-api and --with-wipe-sites
+
+        * signal.c:  removed CHECK_INTS after kill
+        
+        * test/ruby/suicide.rb:  add tiny delay to let signal propogate
+        
+        * gc.c:  save regs properly on main stack before marking it!
+        
+        * eval.c:  numerous corrections in use of volatile variables w/setjmp()
+        
+        * version.h:  bumped date, MBARI version 7+ --> 7A
+
 Sun Feb 22 22:08:45 2009  Nobuyoshi Nakada  <nobu@ruby-lang.org>
 
 	* eval.c (stack_extend): streamlined rb_thread_restore_context()
@@ -1989,22 +2069,28 @@
 	  a patch from Alan Johnson <alan.wayne.johnson at gmail.com> in 
 	  [ruby-core:19982].
 
-Fri Feb 13 19:18:42 2009  Nobuyoshi Nakada  <nobu@ruby-lang.org>
-
-	* lib/logger.rb (ProgName): fixed for svn, based on a patch from
-	  Nobuhiro IMAI at [ruby-dev:37108].
-
 Sun Feb 15 04:17:40 2009  Yukihiro Matsumoto  <matz@ruby-lang.org>
 
 	* lib/webrick/httprequest.rb (WEBrick::HTTPRequest#read_request_line):
 	  use non-greedy match for path retrieval to avoid huge recursion
 	  for insanely long path.
 
+Fri Feb 13 19:18:42 2009  Nobuyoshi Nakada  <nobu@ruby-lang.org>
+
+	* lib/logger.rb (ProgName): fixed for svn, based on a patch from
+	  Nobuhiro IMAI at [ruby-dev:37108].
+
 Fri Feb 13 19:04:54 2009  Keiju Ishitsuka  <keiju@ruby-lang.org>
 
 	* shell/command-processor.rb: undefined method `top_level_test' in
   	  Shell#test. [ruby-list:45634]
 
+Fri Feb 13 00:01:19 2009  Brent Roman  <brent@mbari.org>
+
+        * signal.c:  CHECK_INTS after kill in case of suicide
+        
+        * version.h:  bumped date
+
 Tue Feb 10 20:00:52 2009  Nobuyoshi Nakada  <nobu@ruby-lang.org>
 
 	* eval.c (load_lock): makes circular require deadlock.
@@ -2024,6 +2110,12 @@
 	  Shin").  [ruby-talk:273360]
 	  back ported from 1.9. fix [ruby-core:19791]
 
+Tue Feb 10 00:01:19 2009  Brent Roman  <brent@mbari.org>
+
+        * gc.c:  don't redundantly mark stack before base of current thread
+        
+        * version.h:  bumped date
+
 Mon Feb  9 17:35:38 2009  NAKAMURA Usaku  <usa@ruby-lang.org>
 
 	* win32/win32.c (rb_w32_accept): secure fd before accept because if
@@ -2042,6 +2134,23 @@
 	* ext/stringio/stringio.c (strio_ungetc): should allow ungetc at
 	  the top of the buffer.  ref #701
 
+Mon Feb 09 00:01:19 2009  Brent Roman  <brent@mbari.org>
+
+        * rubysig.h:  default values for STACK_WIPE_SITES if x86_64
+                      cast builtin_alloca result to (VALUE *)
+        
+        * gc.c:  don't use builtin-frame-address at all
+        
+        * version.h:  bumped date
+
+Sun Feb 08 00:01:19 2009  Brent Roman  <brent@mbari.org>
+
+        * rubysig.h:  changed default values for STACK_WIPE_SITES
+        
+        * gc.c:  don't trust config's USE_BUILTIN_FRAME_ADDRESS
+        
+        * version.h:  bumped date
+
 Thu Feb  5 09:38:48 2009  NARUSE, Yui  <naruse@ruby-lang.org>
 
 	* ext/nkf/nkf-utf8/nkf.c (h_conv): can't guess UTF-8 input in
@@ -2146,6 +2255,15 @@
 
 	* test/rexml/test_document.rb: ditto.
 
+Thu Jan 23 00:01:19 2009  Brent Roman  <brent@mbari.org>
+
+        * rubysig.h:  remapped wipe methods to avoid values > 9
+                      added cases for __ppc64__ and __x86_64__
+        
+        * missing/alloca.c:  made 64-bit clean
+        
+        * version.h:  bumped date
+        
 Thu Jan 22 15:19:39 2009  Nobuyoshi Nakada  <nobu@ruby-lang.org>
 
 	* marshal.c (marshal_load): arg.data is no longer a VALUE but a
@@ -2196,6 +2314,21 @@
 	  rb_broken_glibc_ia64_erfc.
 	  [ruby-core:18228]
 
+Sun Jan 18 20:15:36 2009  Brent Roman  <brent@mbari.org>
+
+        * rubysig.h:  added support for STACK_WIPE_METHOD==5 (x86 asm)
+
+        * gc.c:       allow another STACK_WIPE_METHOD
+
+        * version.h:  bumped date
+
+
+Sat Jan 17 20:15:36 2009  Brent Roman  <brent@mbari.org>
+
+        * gc.c:     use separate gc stack so it never need be wiped
+
+        * version.h:  bumped date
+
 Sat Jan 17 12:16:10 2009  Yukihiro Matsumoto  <matz@ruby-lang.org>
 
 	* random.c (Init_Random): always initialize seed.
@@ -2209,16 +2342,47 @@
 
 	* eval.c (PUSH_CREF): use NEW_CREF().
 
+Fri Jan 16 20:15:36 2009  Brent Roman  <brent@mbari.org>
+
+        * gc.c:     added GC_STACK_PAD, renamed stack_gc_limit->gc_stack_limit
+                    optionally wipe the entire GC stack after each gc pass
+        
+        * rubysig.h:  default STACK_WIPE_SITES changed to 0x4770
+        
+        * version.h:  bumped date
+
 Thu Jan 15 14:34:32 2009  Nobuyoshi Nakada  <nobu@ruby-lang.org>
 
 	* gc.c (STACK_LEVEL_MAX, ruby_stack_length): returns size_t.
 	  [ruby-core:18207]
+
 Wed Jan 14 10:39:56 2009  Nobuyoshi Nakada  <nobu@ruby-lang.org>
 
 	* stable/ext/socket/socket.c (NI_MAXHOST, NI_MAXSERV): fixed invalid
 	  preprocessor directives.  a patch from Peter Bowen at
 	  [ruby-core:18211].
 
+Wed Jan 14 20:15:36 2009  Brent Roman  <brent@mbari.org>
+
+        * eval.c:     declare wipe_after with gnu always_inline attribute
+        
+        * rubysig.h:  use alloca(0) to get sp for all CPU except PowerPC
+                      (less likely to trash stack when clearing it)
+        
+        * version.h:  bumped date
+
+
+Sun Jan 13 20:15:36 2009  Brent Roman  <brent@mbari.org>
+
+        * rubysig.h:  moved #defs to configure alloca here from gc.c
+                      added missing # to #else
+        
+        * gc.c: removed #defs to configurure alloca
+                set_stack_size must handle signed rlim_t for Darwin & BSD Unix
+                
+        * version.h:  bumped date
+
+
 Tue Jan 13 04:40:30 2009  Shugo Maeda  <shugo@ruby-lang.org>
 
 	* lib/net/ftp.rb (login): raise FTPReplyError if passwd or acct
@@ -2232,6 +2396,22 @@
 	* gc.c (rb_gc_call_finalizer_at_exit): self-referencing finalizers
 	  cannot be invoked.  [ruby-dev:35681]
 
+Sun Jan 11 20:15:36 2009  Brent Roman  <brent@mbari.org>
+
+        * rubysig.h:  added support for multiple STACK_WIPE_METHODs
+                      added __stack_depth()
+                      added 2nd param to stack_past()
+                      __sp() returns stack pointer in an efficent, portable way                     
+        
+        * gc.c: STACK_END uses __sp()
+                STACK_UPPER now takes only two parameters
+                added rb_gc_wipe_stack()               
+                rb_mark_tbl() and mark_hash() implemented as #define macros
+                added STACK_END parameters to __stack_past() invocations
+                exploited missed opportunities for tail recursion in markchilren
+                
+        * version.h:  bumped date
+
 Sun Jan 11 11:33:27 2009  Shugo Maeda  <shugo@ruby-lang.org>
 
 	* lib/net/ftp.rb (chdir): handle 5xx errors correctly.
@@ -2259,6 +2439,20 @@
 	* parse.y (yylex): 8 and 9 in octal integer should cause compile
 	  error.  [ruby-dev:35729]
 
+Mon Jan  5 20:15:36 2009  Brent Roman  <brent@mbari.org>
+
+        * common.mk:  added dependency on rubysig.h to version.h     
+        
+        * eval.c:  added wipeAfter and STACK_WIPE_SITES cofiguration options
+        
+        * gc.c: added STACK_WIPE_SITES cofiguration options
+                added GC.exorcise method
+        
+        * rubysig.h:  added STACK_WIPE_SITES cofiguration options
+                      when available, use gcc asm to optimize wipe_stack
+        
+        * version.h:  include STACK_WIPE_SITES options in MBARI release string
+
 Mon Jan  5 11:14:39 2009  Nobuyoshi Nakada  <nobu@ruby-lang.org>
 
 	* eval.c (rb_thread_schedule): runs deferred finalizers.
@@ -2274,6 +2468,21 @@
 	  finalizers before explicit GC.start or the process termination.
 	  [ruby-core:18045]
 
+Sun Jan  4 20:15:36 2009  Brent Roman  <brent@mbari.org>
+
+        * eval.c:  eliminated up_stk_extent(), wipe_stack in rb_thread_switch
+        
+        * gc.c: removed lev counter args, check stack pointer instead
+                streamlined SET_STACK_END and STACK_END, stack_length(), etc.
+                added TOP_FRAME to use gcc's builtin frame_address
+                optimized is_heap_pointer()
+                gc_mark_rest() does not need to copy entire mark_stack!
+                added set_stack_size() to properly hande RLIM_INFINITY
+                
+        * rubysig.h:  repaired broken pseudo preemptive thread switching
+                      removed rb_gc_malloc_increase & limit
+                      replaced buggy __stack_grown* with __stack_past* macros
+
 Sun Jan  4 04:49:01 2009  Nobuyoshi Nakada  <nobu@ruby-lang.org>
 
 	* win32/win32.c (rb_w32_telldir): just returns loc.
@@ -2282,13 +2491,74 @@
 	  [ruby-core:18041]
 
 Sun Jan  4 04:45:26 2009  Nobuyoshi Nakada  <nobu@ruby-lang.org>
+        * eval.c:  exclude other thread's stack frames from current one
 
+        * gc.c:  STACK_LENGTH macro takes start parameter
 	* win32/win32.c (rb_w32_select): recalc the rest of timeout for each
 	  iterations.  [ruby-core:18015]
 
+        * node.h: added stk_start pointer to ruby thread struct
+
 Fri Jan  2 03:08:47 2009  Kouhei Sutou  <kou@cozmixng.org>
 
-	* test/rss/: use PNG instead of zlib as binary data. [ruby-dev:35666]
+        * intern.h:  stack_length takes base pointer as parameter
+        
+	* test/rss/: use PNG instead of zlib as binary data. [ruby-dev:35666]       
+
+Tue Dec 19 20:15:36 2008  Brent Roman  <brent@mbari.org>
+
+        * eval.c:  added (Method|Proc)#(__line__|__file__) methods
+                   call ruby_set_current_source() before adding method nodes
+
+Tue Dec 15  9:15:36 2008  Brent Roman  <brent@mbari.org>
+
+        * eval.c:  factored rb_eval() into many separate non-inlined
+                  functions to reduce the size of its stack frame when
+                  compiled with gcc.
+                  Factored callcc into 2 functions.
+
+Tue Dec 13  6:10:36 2008  Brent Roman  <brent@mbari.org>
+
+        * eval.c:  update stack extent just before and after every setjmp
+
+        * gc.c:  replaced rb_gc_stress with gc_getlimit and setlimit
+                 update stack extent after every xmalloc and xrealloc
+                 export rb_gc_stack_grow_direction if not known at compile time
+                 removed dynamic adjustment of malloc_limit
+                 removed workaround for obsolete gcc 2.7.2.3 bug                 
+
+        * signal.h: don't try to clear stress after segsegv.  It's a too late.
+        
+        * rubysig.h:  CHECK_INTS clears ghost references off stack
+
+
+Tue Dec 12  6:11:36 2008  Brent Roman  <brent@mbari.org>
+
+        * eval.c:  exclude other thread's stack frames from current one
+
+        * gc.c:  STACK_LENGTH macro takes start parameter
+
+        * node.h: added stk_start pointer to ruby thread struct
+
+        * intern.h:  stack_length takes base pointer as parameter
+        
+
+Tue Dec  9  8:11:36 2008  Brent Roman  <brent@mbari.org>
+
+     * eval.c:  added Continuation.thread method
+        * cc_mark frees the continuation's stack if its thread is dead
+          avoids recursive gc that segfaults [see Dec 5th, 2007 ruby-core]
+
+        * added cast in PUSH_FRAME() to eliminate gcc 4.2 compiler warnings    
+                   
+        * THREAD_DATA() replaces rb_thread_check() in most contexts
+        
+        * rb_thread_check now complains when passed a Continuation
+          (no longer need redundant check in thgroup_add()
+        
+        * rb_callcc() assigns th->thread before scope_dup()
+          this avoids segfaults if this scope_dup() triggers a gc pass
+        
 
 Tue Nov 11 01:07:32 2008  Kazuhiro NISHIYAMA  <zn@mbf.nifty.com>
 
--- a/NEWS
+++ b/NEWS
@@ -7,6 +7,223 @@
 reference information is supplied with.  For a full list of changes
 with all sufficient information, see the ChangeLog file.
 
+== Changes since the 1.8.7 release
+
+=== Lexical changes
+
+* empty symbol literal
+
+  Empty symbol (:"") is allowed.
+
+* looser splat opetator
+
+  You can write things like:
+    x, *y, z = a, *b, c
+    def foo(a, b=1, *c, d); end
+  But when you evaluate them, you will get exceptions.
+
+* new hash immediates
+
+  Ruby 1.9 style hash syntax e.g. { key: value } is now also supported
+  in 1.8.  You can also write a method invocation syntax foo bar: baz.
+
+=== Configuration changes
+
+* version specific directories
+
+  A new configure option --with-ruby-version is added, which allows
+  user to specify the version string (defaulted to "1.8") for version
+  specific directories such as library directories, ri directories and
+  gem directories.
+
+=== Library updates (outstanding ones only)
+
+* builtin classes
+
+  * Array#try_convert()
+  * Hash#try_convert()
+  * IO#try_convert()
+  * Regexp#try_convert()
+  * String#try_convert()
+
+    New methods.
+
+  * Array#sample
+
+    New method with which replaces #choice.
+
+  * Enumerable#each_with_object
+  * Enumerator#with_object
+
+    New methods.
+
+  * Enumerator.new { |y| ... }
+
+    Now can generate an enumerator from a block that defines
+    enumeration instead of an enumerable object.
+
+  * Enumerator#rewind
+
+    Now calls the "rewind" method of the enclosed object if defined.
+
+  * Enumerator#inspect
+
+    Implemented.
+
+  * Hash#default_proc=
+
+    New method.
+
+  * Hash#key
+
+    Renamed from Hash#index.
+
+  * ENV.key
+
+    Renamed from ENV.index.
+
+  * IO#ungetbyte
+
+    Added as an alias to #ungetc.
+
+  * Proc#===
+
+    New method primarily for use in the case-when construct.
+
+  * Range#cover?
+
+    New alias to #include? for the forward compatibility with 1.9, in
+    which the behavior of Range#include? has changed.
+
+  * Regexp
+
+    The regular expression /\s/ now properly matches a vertical tab
+    character (VT: "\v") and /\S/ does not.  It was a bug that /\s/
+    did not match VT when /[\s]/ does.  It is clear that VT should
+    always be regarded as white space, not to mention String#strip.
+
+  * String#getbyte
+  * String#setbyte
+  * String#ord
+
+    New methods for the forward compatibility with 1.9, in which the
+    behavior of String#[] and String#[]= have changed.  String#ord is
+    $KCODE aware.
+
+  * Symbol#succ
+  * Symbol#next
+  * Symbol#<=>
+  * Symbol#casecmp
+  * Symbol#=~
+  * Symbol#[]
+  * Symbol#slice
+  * Symbol#length
+  * Symbol#size
+  * Symbol#empty?
+  * Symbol#match
+  * Symbol#upcase
+  * Symbol#downcase
+  * Symbol#capitalize
+  * Symbol#swapcase
+
+    New methods.
+
+* base64
+
+  * Base64#strict_encode64
+  * Base64#strict_decode64
+  * Base64#urlsafe_encode64
+  * Base64#urlsafe_decode64
+
+    New methods.
+
+* dbm
+
+  DBM#key
+
+    Renamed from DBM#index.
+
+* gdbm
+
+  GDBM#key
+
+    Renamed from GDBM#index.
+
+* open-uri
+
+  * Added a lot of new options:
+
+    * :ftp_active_mode => bool
+
+      Specify false to enable FTP passive mode.  It is adviced that
+      this option should be explicitly set for forward compatibility
+      because the default mode is changed in Ruby >= 1.9.
+
+    * :read_timeout => seconds
+    * :proxy_http_basic_authentication => [uri, user, password]
+    * :redirect => bool
+    * :ssl_verify_mode => OpenSSL::SSL::VERIFY_*
+    * :ssl_ca_cert => filename
+
+* rational
+
+  * Performace improved by making overall code optimization and
+    introducing Fixnum#gcd implemented in C.
+
+* sdbm
+
+  SDBM#key
+
+    Renamed from SDBM#index.
+
+* securerandom
+
+  SecureRandom.uuid
+
+    New method to generate a v4 random UUID.
+
+* set
+
+  Set#classify
+  Set#collect!
+  Set#delete_if
+  Set#delete_if
+  Set#divide
+  Set#reject!
+
+    Return an enumerator if no block is given.
+
+* stringio
+
+  * StringIO#ungetbyte
+
+    Added as an alias to #ungetc.
+
+* digest
+    * new methods:
+      * Digest::Class.base64digest
+      * Digest::Instance#base64digest
+      * Digest::Instance#base64digest!
+
+* rss
+
+  * 0.2.4 -> 0.2.7.
+
+  * RSS::Maker.make
+    * raise an exception not returns nil for invalid feed making.
+    * requires block.
+
+  * RSS::Maker.[]
+    * new method to return maker class.
+
+  * RSS::Maker.supported?(version)
+    * new method to check whether given version is supported.
+
+  * RSS::Maker: item.guid.permanent_link?
+    * new alias of item.guid.isPermaLink
+  * RSS::Maker: item.guid.permanent_link=
+    * new alias of item.guid.isPermaLink=
+
 * REXML
 
   * REXML::Document.entity_expansion_limit=
--- /dev/null
+++ b/Rakefile
@@ -0,0 +1 @@
+require File.expand_path(File.dirname(__FILE__)) + '/distro/tasks'
\ No newline at end of file
--- a/common.mk
+++ b/common.mk
@@ -42,6 +42,7 @@
 		object.$(OBJEXT) \
 		pack.$(OBJEXT) \
 		parse.$(OBJEXT) \
+		pointerset.$(OBJEXT) \
 		process.$(OBJEXT) \
 		prec.$(OBJEXT) \
 		random.$(OBJEXT) \
@@ -397,7 +398,9 @@
 gc.$(OBJEXT): {$(VPATH)}gc.c {$(VPATH)}ruby.h config.h \
   {$(VPATH)}defines.h {$(VPATH)}intern.h {$(VPATH)}missing.h \
   {$(VPATH)}rubysig.h {$(VPATH)}st.h {$(VPATH)}node.h \
-  {$(VPATH)}env.h {$(VPATH)}re.h {$(VPATH)}regex.h
+  {$(VPATH)}env.h {$(VPATH)}re.h {$(VPATH)}regex.h \
+  {$(VPATH)}pointerset.h {$(VPATH)}marktable.h \
+  {$(VPATH)}marktable.c {$(VPATH)}fastmarktable.c
 hash.$(OBJEXT): {$(VPATH)}hash.c {$(VPATH)}ruby.h config.h \
   {$(VPATH)}defines.h {$(VPATH)}intern.h {$(VPATH)}missing.h \
   {$(VPATH)}st.h {$(VPATH)}util.h {$(VPATH)}rubysig.h
@@ -426,6 +429,7 @@
   {$(VPATH)}defines.h {$(VPATH)}intern.h {$(VPATH)}missing.h \
   {$(VPATH)}env.h {$(VPATH)}node.h {$(VPATH)}st.h \
   {$(VPATH)}regex.h {$(VPATH)}util.h {$(VPATH)}lex.c
+pointerset.$(OBJEXT): {$(VPATH)}pointerset.c {$(VPATH)}pointerset.h
 prec.$(OBJEXT): {$(VPATH)}prec.c {$(VPATH)}ruby.h config.h \
   {$(VPATH)}defines.h {$(VPATH)}intern.h {$(VPATH)}missing.h
 process.$(OBJEXT): {$(VPATH)}process.c {$(VPATH)}ruby.h config.h \
@@ -463,7 +467,7 @@
   {$(VPATH)}env.h {$(VPATH)}node.h {$(VPATH)}st.h {$(VPATH)}util.h
 version.$(OBJEXT): {$(VPATH)}version.c {$(VPATH)}ruby.h config.h \
   {$(VPATH)}defines.h {$(VPATH)}intern.h {$(VPATH)}missing.h \
-  {$(VPATH)}version.h
+  {$(VPATH)}rubysig.h {$(VPATH)}version.h
 
 dist: $(PROGRAM)
 	$(RUNRUBY) $(srcdir)/distruby.rb
--- a/configure.in
+++ b/configure.in
@@ -152,6 +152,25 @@
 if test $frame_address = yes; then
     AC_DEFINE(USE_BUILTIN_FRAME_ADDRESS)
 fi
+AC_ARG_ENABLE(mbari-api,
+       [  --enable-mbari-api      enable API changes from the MBARI patches. ],
+       [mbari_api=$enableval],
+       [mbari_api=yes])
+if test "$mbari_api" = yes; then
+    AC_DEFINE(MBARI_API)
+fi
+AC_ARG_WITH(wipe-sites,
+[  --with-wipe-sites=MASK  override default STACK_WIPES_SITES mask in rubysig.h],
+[wipe_sites=$withval])
+if test "$wipe_sites" != ""; then
+  case $wipe_sites in
+       none|no)  wipe_sites=0x0;;
+       yes) wipe_sites=;;
+  esac
+  if test -n "$wipe_sites"; then
+    AC_DEFINE_UNQUOTED(STACK_WIPE_SITES,$wipe_sites)
+  fi
+fi
 
 AC_ARG_PROGRAM
 
@@ -602,6 +621,40 @@
   ;;
 *)
   AC_FUNC_ALLOCA
+  if test $ac_cv_func_alloca_works = yes; then
+	# On Apple uses llvm-gcc since Xcode 4. llvm-gcc has this nice bug
+	# where __builtin_alloca(0) would return non-NULL with -O0, but NULL
+	# with -O2...
+	AC_CACHE_CHECK(whether alloca(0) returns the stack pointer, rb_cv_alloca_0_returns_stack_pointer,
+	  [AC_TRY_RUN([
+#ifdef HAVE_ALLOCA_H_
+#  include <alloca.h>
+#endif
+#include <stdlib.h>
+int
+main()
+{
+	/* It's important that we assign the result of alloca to a variable!
+	 * If we put it in the if-statement then the compiler's -O2 optimizations
+	 * will optimize it away to "if (true)", thereby bypassing our
+	 * llvm-gcc bug detection! Let's put 'volatile' in there too,
+	 * just in case.
+	 */
+	volatile void *addr = alloca(0);
+    if (addr != NULL) {
+        return 0;
+    } else {
+        return 1;
+    }
+}
+],
+		rb_cv_alloca_0_returns_stack_pointer=yes,
+		rb_cv_alloca_0_returns_stack_pointer=no,
+		rb_cv_alloca_0_returns_stack_pointer=no)])
+	if test $rb_cv_alloca_0_returns_stack_pointer = yes; then
+	  AC_DEFINE(ALLOCA_0_RETURNS_STACK_POINTER, 1)
+	fi
+  fi
   ;;
 esac
 AC_FUNC_MEMCMP
@@ -1866,7 +1919,7 @@
 AC_DEFINE_UNQUOTED(RUBY_VENDOR_ARCHLIB, "${RUBY_VENDOR_LIB_PATH2}/${sitearch}")
 
 AC_ARG_WITH(search-path,
-		[  --with-search-path=DIR specify the additional search path],
+		[  --with-search-path= DIR specify the additional search path],
 		[search_path=$withval])
 if test "$search_path" != ""; then
     AC_DEFINE_UNQUOTED(RUBY_SEARCH_PATH,"$search_path")
--- a/defines.h
+++ b/defines.h
@@ -51,6 +51,19 @@
 void *xrealloc _((void*,long));
 void xfree _((void*));
 
+#if defined(__APPLE__)
+    #define USING_SYSTEM_ALLOCATOR_LIBRARY
+#endif
+
+/* See system_allocator.c for documentation. */
+#ifdef USING_SYSTEM_ALLOCATOR_LIBRARY
+    void *system_malloc(long size);
+    void system_free(void *ptr);
+#else
+    #define system_malloc(size) malloc(size)
+    #define system_free(ptr) free(ptr)
+#endif
+
 #if SIZEOF_LONG_LONG > 0
 # define LONG_LONG long long
 #elif SIZEOF___INT64 > 0
--- a/eval.c
+++ b/eval.c
@@ -240,9 +240,9 @@
 VALUE rb_cBinding;
 static VALUE proc_invoke _((VALUE,VALUE,VALUE,VALUE));
 static VALUE rb_f_binding _((VALUE));
-static void rb_f_END _((void));
+NOINLINE(static void rb_f_END _((void)));
 static VALUE rb_f_block_given_p _((void));
-static VALUE block_pass _((VALUE,NODE*));
+static VALUE block_pass _((volatile VALUE, NODE *volatile));
 static void eval_check_tick _((void));
 
 VALUE rb_cMethod;
@@ -265,6 +265,23 @@
 VALUE (*ruby_sandbox_save)_((rb_thread_t));
 VALUE (*ruby_sandbox_restore)_((rb_thread_t));
 NODE* ruby_current_node;
+
+void
+ruby_set_current_source()
+{
+    if (ruby_current_node) {
+	ruby_sourcefile = ruby_current_node->nd_file;
+	ruby_sourceline = nd_line(ruby_current_node);
+    }
+}
+
+#ifdef MBARI_API
+#define SET_METHOD_SOURCE()  ruby_set_current_source()
+#else
+#define SET_METHOD_SOURCE()  (void)0
+#endif
+
+
 int ruby_safe_level = 0;
 /* safe-level:
    0 - strings from streams/environment/ARGV are tainted (default)
@@ -749,6 +766,7 @@
     if (!name) {
 	rb_raise(rb_eArgError, "argument needs to be symbol or string");
     }
+    SET_METHOD_SOURCE();
     len = strlen(name)+2;
     buf = ALLOCA_N(char,len);
     snprintf(buf, len, "@%s", name);
@@ -789,7 +807,7 @@
     _frame.argc = 0;			\
     _frame.flags = 0;			\
     _frame.uniq = frame_unique++;	\
-    ruby_frame = &_frame
+    ruby_frame = (struct FRAME *)&_frame
 
 #define POP_FRAME()  			\
     ruby_current_node = _frame.node;	\
@@ -987,7 +1005,7 @@
     ID id;
 
     if (!ruby_scope->local_tbl) return NULL;
-    if (cnt >= ruby_scope->local_tbl[0]) return NULL;
+    if ((ID)cnt >= ruby_scope->local_tbl[0]) return NULL;
     id = ruby_scope->local_tbl[cnt+1];
     while (vars) {
 	if (vars->id == id) return &vars->val;
@@ -1050,7 +1068,26 @@
 #define PROT_LAMBDA INT2FIX(2)	/* 5 */
 #define PROT_YIELD  INT2FIX(3)	/* 7 */
 
-#define EXEC_TAG()    ruby_setjmp(((void)0), prot_tag->buf)
+#if STACK_WIPE_SITES & 0x42
+#ifdef __GNUC__
+static inline int wipeAfter(int) __attribute__((always_inline));
+#endif
+static inline int wipeAfter(int status)
+{
+  rb_gc_wipe_stack();
+  return status;
+}
+#else
+#define wipeAfter(status) status
+#endif
+#if STACK_WIPE_SITES & 2
+#define wipeAfterTag(status) wipeAfter(status)
+#else
+#define wipeAfterTag(status) status
+#endif
+
+#define EXEC_TAG_0()  ruby_setjmp(((void)0), prot_tag->buf)
+#define EXEC_TAG()    wipeAfterTag(EXEC_TAG_0())
 
 #define JUMP_TAG(st) do {		\
     ruby_frame = prot_tag->frame;	\
@@ -1126,10 +1163,17 @@
 } while (0)
 
 static VALUE rb_eval _((VALUE,NODE*));
-static VALUE eval _((VALUE,VALUE,VALUE,const char*,int));
+static VALUE eval _((VALUE,VALUE,volatile VALUE,const char* volatile,int));
 static NODE *compile _((VALUE, const char*, int));
 
-static VALUE rb_yield_0 _((VALUE, VALUE, VALUE, int, int));
+static VALUE rb_yield_0 
+               _((volatile VALUE, volatile VALUE, VALUE, int, volatile int));
+
+#if STACK_WIPE_SITES & 0x20
+#define wipeBeforeYield()  rb_gc_wipe_stack()
+#else
+#define wipeBeforeYield()  (void)0
+#endif
 
 #define YIELD_LAMBDA_CALL 1
 #define YIELD_PROC_CALL   2
@@ -1139,7 +1183,7 @@
 #define YIELD_FUNC_LAMBDA 3
 
 static VALUE rb_call _((VALUE,VALUE,ID,int,const VALUE*,int,VALUE));
-static VALUE module_setup _((VALUE,NODE*));
+static VALUE module_setup _((VALUE,NODE *volatile));
 
 static VALUE massign _((VALUE,NODE*,VALUE,int));
 static void assign _((VALUE,NODE*,VALUE,int));
@@ -1171,22 +1215,6 @@
 static int tracing = 0;
 static void call_trace_func _((rb_event_t,NODE*,VALUE,ID,VALUE));
 
-#if 0
-#define SET_CURRENT_SOURCE() (ruby_sourcefile = ruby_current_node->nd_file, \
-			      ruby_sourceline = nd_line(ruby_current_node))
-#else
-#define SET_CURRENT_SOURCE() ((void)0)
-#endif
-
-void
-ruby_set_current_source()
-{
-    if (ruby_current_node) {
-	ruby_sourcefile = ruby_current_node->nd_file;
-	ruby_sourceline = nd_line(ruby_current_node);
-    }
-}
-
 static void
 #ifdef HAVE_STDARG_PROTOTYPES
 warn_printf(const char *fmt, ...)
@@ -1248,20 +1276,15 @@
 static void
 error_print()
 {
-    VALUE errat = Qnil;		/* OK */
+    VALUE errat;
     volatile VALUE eclass, e;
-    const char *einfo;
+    const char * einfo;
     long elen;
 
     if (NIL_P(ruby_errinfo)) return;
 
     PUSH_TAG(PROT_NONE);
-    if (EXEC_TAG() == 0) {
-	errat = get_backtrace(ruby_errinfo);
-    }
-    else {
-	errat = Qnil;
-    }
+    errat = EXEC_TAG() ? Qnil : get_backtrace(ruby_errinfo);
     if (EXEC_TAG()) goto error;
     if (NIL_P(errat)){
 	ruby_set_current_source();
@@ -1444,7 +1467,7 @@
 }
 
 static VALUE
-eval_node(self, node)
+eval_tree(self, node)
     VALUE self;
     NODE *node;
 {
@@ -1593,12 +1616,13 @@
 }
 
 int
-ruby_cleanup(ex)
-    int ex;
+ruby_cleanup(exArg)
+    int exArg;
 {
     int state;
     volatile VALUE errs[2];
-    int nerr;
+    unsigned nerr;
+    volatile int ex = exArg;
 
     errs[1] = ruby_errinfo;
     ruby_safe_level = 0;
@@ -1661,7 +1685,7 @@
     /* default visibility is private at toplevel */
     SCOPE_SET(SCOPE_PRIVATE);
     if ((state = EXEC_TAG()) == 0) {
-	eval_node(ruby_top_self, ruby_eval_tree);
+	eval_tree(ruby_top_self, ruby_eval_tree);
     }
     POP_ITER();
     POP_TAG();
@@ -1869,8 +1893,8 @@
     int level;
 {
     int state;
-    VALUE val = Qnil;		/* OK */
-    struct SCOPE *saved_scope;
+    VALUE val;
+    struct SCOPE * volatile saved_scope;
     volatile int safe = ruby_safe_level;
 
     if (OBJ_TAINTED(cmd)) {
@@ -1901,9 +1925,7 @@
     ruby_safe_level = level;
 
     PUSH_TAG(PROT_NONE);
-    if ((state = EXEC_TAG()) == 0) {
-	val = eval(ruby_top_self, cmd, Qnil, 0, 0);
-    }
+    val = (state = EXEC_TAG()) ? Qnil : eval(ruby_top_self, cmd, Qnil, 0, 0);
     if (ruby_scope->flags & SCOPE_DONT_RECYCLE)
 	scope_dup(saved_scope);
     ruby_scope = saved_scope;
@@ -1942,6 +1964,10 @@
     return rb_const_defined(cref->nd_clss, id);
 }
 
+NOINLINE(static VALUE ev_const_get _((NODE *cref, ID id, VALUE self)));
+NOINLINE(static void eval_cvar_set _((NODE *node, VALUE result, VALUE warn)));
+NOINLINE(static void eval_cdecl _((VALUE self, NODE *node, VALUE value)));
+
 static VALUE
 ev_const_get(cref, id, self)
     NODE *cref;
@@ -2269,7 +2295,10 @@
     NODE *node;
     NODE *rval;
 {
-    NODE *copy = NEW_NODE(NODE_SCOPE,0,rval,node->nd_next);
+    NODE *copy;
+
+    SET_METHOD_SOURCE();
+    copy=NEW_NODE(NODE_SCOPE,0,rval,node->nd_next);
 
     if (node->nd_tbl) {
 	copy->nd_tbl = ALLOC_N(ID, node->nd_tbl[0]+1);
@@ -2376,10 +2405,10 @@
 static const char*
 is_defined(self, node, buf)
     VALUE self;
-    NODE *node;			/* OK */
+    NODE *node;
     char *buf;
 {
-    VALUE val;			/* OK */
+    VALUE val;
     int state;
 
   again:
@@ -2724,14 +2753,15 @@
     NODE *node;
     VALUE self;
     ID id;
-    VALUE klass;		/* OK */
+    VALUE klass;
 {
-    int state, raised;
+    int state;
+    volatile int raised;
     struct FRAME *prev;
-    NODE *node_save;
+    NODE * volatile node_save;
     VALUE srcfile;
     const char *event_name;
-    rb_thread_t th = curr_thread;
+    volatile rb_thread_t th = curr_thread;
 
     if (!trace_func) return;
     if (tracing) return;
@@ -2781,7 +2811,6 @@
 
     tracing = 0;
     ruby_current_node = node_save;
-    SET_CURRENT_SOURCE();
     if (state) JUMP_TAG(state);
 }
 
@@ -2940,11 +2969,11 @@
 NORETURN(static void return_jump _((VALUE)));
 NORETURN(static void break_jump _((VALUE)));
 NORETURN(static void next_jump _((VALUE)));
-NORETURN(static void unknown_node _((NODE * volatile)));
+NORETURN(static void unknown_node _((NODE *)));
 
 static void
 unknown_node(node)
-    NODE *volatile node;
+    NODE *node;
 {
     ruby_current_node = 0;
     if (node->flags == 0) {
@@ -2958,41 +2987,884 @@
     }
 }
 
-static VALUE
-rb_eval(self, n)
-    VALUE self;
-    NODE *n;
+
+/*
+ *  functions factored out of rb_eval() to reduce its stack frame size
+ */
+#define eval_node_0(n,retType, self, node)  \
+NOINLINE(static retType TOKEN_PASTE(eval_,n) _((self, node)));\
+static retType TOKEN_PASTE(eval_,n)(self, node)
+
+#define eval_node(n,retType) \
+  eval_node_0(n,retType, VALUE self, NODE *node)
+#define eval_node_volatile(n,retType) \
+  eval_node_0(n,retType, volatile VALUE self, NODE * volatile node)
+
+eval_node(match2, VALUE)
+{
+    VALUE l = rb_eval(self,node->nd_recv);
+    VALUE r = rb_eval(self,node->nd_value);
+    return rb_reg_match(l, r);
+}
+
+eval_node(match3, VALUE)
+{
+  VALUE r = rb_eval(self,node->nd_recv);
+  VALUE l = rb_eval(self,node->nd_value);
+  return TYPE(l) == T_STRING ? rb_reg_match(r, l) : rb_funcall(l, match, 1, r);
+}
+
+
+eval_node_volatile(opt_n, void)
+{
+  int state;
+  PUSH_TAG(PROT_LOOP);
+  switch (state = EXEC_TAG()) {
+    case TAG_NEXT:
+      state = 0;
+    case 0:
+      while (!NIL_P(rb_gets())) {
+	opt_n_redo:
+	  rb_eval(self, node->nd_body);
+      }
+      break;
+
+    case TAG_REDO:
+      state = 0;
+      goto opt_n_redo;
+
+    case TAG_BREAK:
+      state = 0;
+    default:
+      break;
+  }
+  POP_TAG();
+  if (state) JUMP_TAG(state);
+}
+
+
+eval_node(when, NODE*)
+{
+  do {
+      NODE *tag = node->nd_head;
+      while (tag) {
+	  EXEC_EVENT_HOOK(RUBY_EVENT_LINE, tag, self,
+			  ruby_frame->last_func,
+			  ruby_frame->last_class);
+	  if (tag->nd_head && nd_type(tag->nd_head) == NODE_WHEN) {
+	      VALUE v = rb_eval(self, tag->nd_head->nd_head);
+	      long i;
+
+	      if (TYPE(v) != T_ARRAY) v = rb_ary_to_ary(v);
+	      for (i=0; i<RARRAY(v)->len; i++) {
+		  if (RTEST(RARRAY(v)->ptr[i])) return node->nd_body;
+	      }
+	      tag = tag->nd_next;
+	      continue;
+	  }
+	  if (RTEST(rb_eval(self, tag->nd_head))) return node->nd_body;
+	  tag = tag->nd_next;
+      }
+  } while ((node = node->nd_next) && nd_type(node) == NODE_WHEN);
+  return node;
+}
+
+
+eval_node(case, NODE*)
+{
+  VALUE val = rb_eval(self, node->nd_head);
+  node = node->nd_body;
+  while (node) {
+      NODE *tag;
+
+      if (nd_type(node) != NODE_WHEN) break;
+      tag = node->nd_head;
+      while (tag) {
+	  EXEC_EVENT_HOOK(RUBY_EVENT_LINE, tag, self,
+			  ruby_frame->last_func,
+			  ruby_frame->last_class);
+	  if (tag->nd_head && nd_type(tag->nd_head) == NODE_WHEN) {
+	      VALUE v = rb_eval(self, tag->nd_head->nd_head);
+	      long i;
+
+	      if (TYPE(v) != T_ARRAY) v = rb_ary_to_ary(v);
+	      for (i=0; i<RARRAY(v)->len; i++) {
+		  if (RTEST(rb_funcall2(RARRAY(v)->ptr[i], eqq, 1, &val)))
+		      return node->nd_body;
+	      }
+	      tag = tag->nd_next;
+	      continue;
+	  }
+	  if (RTEST(rb_funcall2(rb_eval(self, tag->nd_head), eqq, 1, &val)))
+	      return node->nd_body;
+	  tag = tag->nd_next;
+      }
+      node = node->nd_next;
+  }
+  return node;
+}
+
+
+eval_node_volatile(while, VALUE)
+{
+  int state;
+  VALUE result;
+  PUSH_TAG(PROT_LOOP);
+  switch (state = EXEC_TAG()) {
+    case 0:
+      if (!(node->nd_state) || RTEST(rb_eval(self, node->nd_cond))) {
+        do {
+	  while_redo:
+#if STACK_WIPE_SITES & 0x10
+            rb_gc_wipe_stack();
+#endif
+	    rb_eval(self, node->nd_body);
+	  while_next:
+	    ;
+        } while (RTEST(rb_eval(self, node->nd_cond)));
+      }  /* fall thru */
+    default:
+      result=Qnil;
+      break;
+
+    case TAG_REDO:
+      state = 0;
+      goto while_redo;
+    case TAG_NEXT:
+      state = 0;
+      goto while_next;
+    case TAG_BREAK:
+      if (TAG_DST()) {
+	  state = 0;
+	  result = prot_tag->retval;
+      }
+  }
+  POP_TAG();
+  if (state) JUMP_TAG(state);
+  return result;
+}
+
+
+eval_node_volatile(until, VALUE)
+{
+  int state;
+  VALUE result;
+  PUSH_TAG(PROT_LOOP);
+  switch (state = EXEC_TAG()) {
+    case 0:
+      if (!(node->nd_state) || !RTEST(rb_eval(self, node->nd_cond))) {
+        do {
+          until_redo:
+  #if STACK_WIPE_SITES & 0x10
+            rb_gc_wipe_stack();
+  #endif
+	    rb_eval(self, node->nd_body);
+          until_next:
+	    ;
+        } while (!RTEST(rb_eval(self, node->nd_cond)));
+      }  /* fall thru */
+    default:
+      result=Qnil;
+      break;
+
+    case TAG_REDO:
+      state = 0;
+      goto until_redo;
+    case TAG_NEXT:
+      state = 0;
+      goto until_next;
+    case TAG_BREAK:
+      if (TAG_DST()) {
+	  state = 0;
+	  result = prot_tag->retval;
+      }
+  }
+  POP_TAG();
+  if (state) JUMP_TAG(state);
+  return result;
+}
+
+
+eval_node_volatile(iter, VALUE)
+{
+  int state;
+  VALUE result;
+
+  PUSH_TAG(PROT_LOOP);
+  PUSH_BLOCK(node->nd_var, node->nd_body);
+
+  state = EXEC_TAG();
+  switch (state) {
+    case TAG_RETRY:
+      state = 0;  /* fall thru to case 0 */
+    case 0:
+      PUSH_ITER(ITER_PRE);
+      if (nd_type(node) == NODE_ITER) {
+	  result = rb_eval(self, node->nd_iter);
+      }
+      else {
+	  _block.flags &= ~BLOCK_D_SCOPE;
+	  BEGIN_CALLARGS;
+	  result = rb_eval(self, node->nd_iter);
+	  END_CALLARGS;
+	  ruby_current_node = (NODE *)node;
+	  result = rb_call(CLASS_OF(result),result,each,0,0,0,self);
+      }
+      POP_ITER();
+      break;
+      
+    case TAG_BREAK:
+      if (TAG_DST()) {
+        result = prot_tag->retval;
+        state = 0;
+      }
+  }
+  POP_BLOCK();
+  POP_TAG();
+  if (state) JUMP_TAG(state);
+  return result;
+}
+
+
+eval_node_volatile(rescue, VALUE)
 {
-    NODE * volatile contnode = 0;
-    NODE * volatile node = n;
+    volatile VALUE e_info = ruby_errinfo;
+    volatile int rescuing = 0;
     int state;
-    volatile VALUE result = Qnil;
-    st_data_t data;
+    VALUE result;
 
-#define RETURN(v) do { \
-    result = (v); \
-    goto finish; \
-} while (0)
+    PUSH_TAG(PROT_NONE);
+    if ((state = EXEC_TAG()) == 0) {
+      retry_entry:
+	result = rb_eval(self, node->nd_head);
+    }
+    else if (rescuing) {
+	if (rescuing < 0) {
+	    /* in rescue argument, just reraise */
+            result = Qnil;
+	}
+	else if (state == TAG_RETRY) {
+	    rescuing = state = 0;
+	    ruby_errinfo = e_info;
+	    goto retry_entry;
+	}
+	else if (state != TAG_RAISE) {
+	    result = prot_tag->retval;
+	}
+    }
+    else if (state == TAG_RAISE) {
+	NODE *resq = node->nd_resq;
 
-    eval_check_tick();
-  again:
-    if (!node) RETURN(Qnil);
+	rescuing = -1;
+	while (resq) {
+	    ruby_current_node = resq;
+	    if (handle_rescue(self, resq)) {
+		state = 0;
+		rescuing = 1;
+		result = rb_eval(self, resq->nd_body);
+		break;
+	    }
+	    resq = resq->nd_head; /* next rescue */
+	}
+    }
+    else {
+	result = prot_tag->retval;
+    }
+    POP_TAG();
+    if (state != TAG_RAISE) ruby_errinfo = e_info;
+    if (state) {
+	JUMP_TAG(state);
+    }
+    /* no exception raised */
+    if (!rescuing && node->nd_else) { /* else clause given */
+	result = Qundef;  /* caller must eval this! */
+    }
+    return result;
+}
+
+
+eval_node_volatile(ensure, VALUE)
+{
+  int state;
+  VALUE result;
+
+  PUSH_TAG(PROT_NONE);
+  if ((state = EXEC_TAG()) == 0) {
+      result = rb_eval(self, node->nd_head);
+  }
+  POP_TAG();
+  if (node->nd_ensr && !thread_no_ensure()) {
+      VALUE retval = prot_tag->retval; /* save retval */
+      VALUE errinfo = ruby_errinfo;
+
+      rb_eval(self, node->nd_ensr);
+      return_value(retval);
+      ruby_errinfo = errinfo;
+  }
+  if (state) JUMP_TAG(state);
+  return result;
+}
+
+
+eval_node(dot, VALUE)
+{
+  VALUE beg = rb_eval(self, node->nd_beg);
+  VALUE end = rb_eval(self, node->nd_end);
+  return rb_range_new(beg, end, nd_type(node) == NODE_DOT3);
+}
+
+
+eval_node(flip2, VALUE)
+{
+  VALUE *flip = rb_svar(node->nd_cnt);
+  if (!flip) rb_bug("unexpected local variable");
+  if (!RTEST(*flip)) {
+    if (!RTEST(rb_eval(self, node->nd_beg)))
+      return Qfalse;
+    *flip = RTEST(rb_eval(self, node->nd_end))?Qfalse:Qtrue;
+  }
+  else if (RTEST(rb_eval(self, node->nd_end)))
+    *flip = Qfalse;
+  return Qtrue;
+}
+
+
+eval_node(flip3, VALUE)
+{
+  VALUE *flip = rb_svar(node->nd_cnt);
+  if (!flip) rb_bug("unexpected local variable");
+  if (!RTEST(*flip))
+    return *flip = (RTEST(rb_eval(self, node->nd_beg)) ? Qtrue : Qfalse);
+  if (RTEST(rb_eval(self, node->nd_end)))
+    *flip = Qfalse;
+  return Qtrue;
+}
+
+
+eval_node(attrasgn, VALUE)
+{
+  VALUE recv;
+  int argc; VALUE *argv; /* used in SETUP_ARGS */
+  int scope;
+  TMP_PROTECT;
+
+  BEGIN_CALLARGS;
+  if (node->nd_recv == (NODE *)1) {
+      recv = self;
+      scope = 1;
+  }
+  else {
+      recv = rb_eval(self, node->nd_recv);
+      scope = 0;
+  }
+  SETUP_ARGS(node->nd_args);
+  END_CALLARGS;
+
+  ruby_current_node = node;
+  rb_call(CLASS_OF(recv),recv,node->nd_mid,argc,argv,scope,self);
+  return argv[argc-1];
+}
+
+
+eval_node(call, VALUE)
+{
+  VALUE recv;
+  int argc; VALUE *argv; /* used in SETUP_ARGS */
+  TMP_PROTECT;
+
+  BEGIN_CALLARGS;
+  recv = rb_eval(self, node->nd_recv);
+  SETUP_ARGS(node->nd_args);
+  END_CALLARGS;
+
+  ruby_current_node = node;
+  return rb_call(CLASS_OF(recv),recv,node->nd_mid,argc,argv,0,self);
+}
+
+
+eval_node(fcall, VALUE)
+{
+  int argc; VALUE *argv; /* used in SETUP_ARGS */
+  TMP_PROTECT;
 
+  BEGIN_CALLARGS;
+  SETUP_ARGS(node->nd_args);
+  END_CALLARGS;
+
+  ruby_current_node = node;
+  return rb_call(CLASS_OF(self),self,node->nd_mid,argc,argv,1,self);
+}
+
+
+eval_node(super, VALUE)
+{
+  int argc; VALUE *argv; /* used in SETUP_ARGS */
+  TMP_PROTECT;
+
+  if (ruby_frame->last_class == 0) {
+      if (ruby_frame->last_func) {
+	  rb_name_error(ruby_frame->last_func,
+			"superclass method `%s' disabled",
+			rb_id2name(ruby_frame->orig_func));
+      }
+      else {
+	  rb_raise(rb_eNoMethodError, "super called outside of method");
+      }
+  }
+  if (nd_type(node) == NODE_ZSUPER) {
+      argc = ruby_frame->argc;
+      if (argc && DMETHOD_P()) {
+	  if (TYPE(RBASIC(ruby_scope)->klass) != T_ARRAY ||
+	      RARRAY(RBASIC(ruby_scope)->klass)->len != argc) {
+	      rb_raise(rb_eRuntimeError, 
+		       "super: specify arguments explicitly");
+	  }
+	  argv = RARRAY(RBASIC(ruby_scope)->klass)->ptr;
+      }
+      else if (!ruby_scope->local_vars) {
+	  argc = 0;
+	  argv = 0;
+      }
+      else {
+	  argv = ruby_scope->local_vars + 2;
+      }
+  }
+  else {
+      BEGIN_CALLARGS;
+      SETUP_ARGS(node->nd_args);
+      END_CALLARGS;
+      ruby_current_node = node;
+  }
+  return rb_call_super(argc, argv);
+}
+
+
+eval_node_volatile(scope, VALUE)
+{
+  int state;
+  VALUE result;
+  struct FRAME frame;
+  NODE * volatile saved_cref = 0;
+
+  frame = *ruby_frame;
+  frame.tmp = ruby_frame;
+  ruby_frame = &frame;
+
+  PUSH_SCOPE();
+  PUSH_TAG(PROT_NONE);
+  if (node->nd_rval) {
+      saved_cref = ruby_cref;
+      ruby_cref = (NODE*)node->nd_rval;
+  }
+  if (node->nd_tbl) {
+      VALUE *vars = ALLOCA_N(VALUE, node->nd_tbl[0]+1);
+      *vars++ = (VALUE)node;
+      ruby_scope->local_vars = vars;
+      rb_mem_clear(ruby_scope->local_vars, node->nd_tbl[0]);
+      ruby_scope->local_tbl = node->nd_tbl;
+  }
+  else {
+      ruby_scope->local_vars = 0;
+      ruby_scope->local_tbl  = 0;
+  }
+  if ((state = EXEC_TAG()) == 0) {
+      result = rb_eval(self, node->nd_next);
+  }
+  POP_TAG();
+  POP_SCOPE();
+  ruby_frame = frame.tmp;
+  if (saved_cref)
+      ruby_cref = saved_cref;
+  if (state) JUMP_TAG(state);
+  return result;
+}
+
+eval_node(op_asgn1, VALUE)
+{
+  int argc; VALUE *argv; /* used in SETUP_ARGS */
+  VALUE recv, val, tmp;
+  NODE *rval;
+  TMP_PROTECT;
+
+  recv = rb_eval(self, node->nd_recv);
+  rval = node->nd_args->nd_head;
+  SETUP_ARGS0(node->nd_args->nd_body, 1);
+  val = rb_funcall3(recv, aref, argc, argv);
+  switch (node->nd_mid) {
+  case 0: /* OR */
+    if (RTEST(val)) return val;
+    val = rb_eval(self, rval);
+    break;
+  case 1: /* AND */
+    if (!RTEST(val)) return val;
+    val = rb_eval(self, rval);
+    break;
+  default:
+    tmp = rb_eval(self, rval);
+    val = rb_funcall3(val, node->nd_mid, 1, &tmp);
+  }
+  argv[argc] = val;
+  rb_funcall2(recv, aset, argc+1, argv);
+  return val;
+}
+
+
+eval_node(op_asgn2, VALUE)
+{
+  ID id = node->nd_next->nd_vid;
+  VALUE recv, val, tmp;
+
+  recv = rb_eval(self, node->nd_recv);
+  val = rb_funcall3(recv, id, 0, 0);
+  switch (node->nd_next->nd_mid) {
+  case 0: /* OR */
+    if (RTEST(val)) return val;
+    val = rb_eval(self, node->nd_value);
+    break;
+  case 1: /* AND */
+    if (!RTEST(val)) return val;
+    val = rb_eval(self, node->nd_value);
+    break;
+  default:
+    tmp = rb_eval(self, node->nd_value);
+    val = rb_funcall3(val, node->nd_next->nd_mid, 1, &tmp);
+  }
+
+  rb_funcall2(recv, node->nd_next->nd_aid, 1, &val);
+  return val;
+}
+
+
+eval_node(hash, VALUE)
+{
+  NODE *list;
+  VALUE hash = rb_hash_new();
+  VALUE key, val;
+
+  list = node->nd_head;
+  while (list) {
+      key = rb_eval(self, list->nd_head);
+      list = list->nd_next;
+      if (list == 0)
+	  rb_bug("odd number list for Hash");
+      val = rb_eval(self, list->nd_head);
+      list = list->nd_next;
+      rb_hash_aset(hash, key, val);
+  }
+  return hash;
+}
+
+
+eval_node(array, VALUE)
+{
+  VALUE ary;
+  long i;
+
+  i = node->nd_alen;
+  ary = rb_ary_new2(i);
+  for (i=0;node;node=node->nd_next) {
+      RARRAY(ary)->ptr[i++] = rb_eval(self, node->nd_head);
+      RARRAY(ary)->len = i;
+  }
+  return ary;
+}
+
+
+eval_node(slit, VALUE)
+{
+  VALUE str, str2;
+  NODE *list = node->nd_next;
+
+  str = rb_str_new3(node->nd_lit);
+  while (list) {
+      if (list->nd_head) {
+	  switch (nd_type(list->nd_head)) {
+	    case NODE_STR:
+	      str2 = list->nd_head->nd_lit;
+	      break;
+	    default:
+	      str2 = rb_eval(self, list->nd_head);
+	      break;
+	  }
+	  rb_str_append(str, str2);
+	  OBJ_INFECT(str, str2);
+      }
+      list = list->nd_next;
+  }
+  switch (nd_type(node)) {
+    case NODE_DREGX:
+      str2 = str;
+      str = rb_reg_new(RSTRING(str2)->ptr, RSTRING(str2)->len,
+			  node->nd_cflag);
+      RB_GC_GUARD(str2); /* ensure str2 is not GC'd in previous rb_reg_new */
+      break;
+    case NODE_DREGX_ONCE:	/* regexp expand once */
+      str2 = str;
+      str = rb_reg_new(RSTRING(str2)->ptr, RSTRING(str2)->len,
+			  node->nd_cflag);
+      nd_set_type(node, NODE_LIT);
+      node->nd_lit = str;
+      RB_GC_GUARD(str2); /* ensure str2 is not GC'd in previous rb_reg_new */
+      break;
+    case NODE_LIT:
+      /* other thread may replace NODE_DREGX_ONCE to NODE_LIT */
+      return Qundef;
+    case NODE_DXSTR:
+      return rb_funcall(self, '`', 1, str);
+    case NODE_DSYM:
+      return rb_str_intern(str);
+  }
+  return str;
+}
+
+        
+eval_node(defn, void)
+{
+  NODE *body,  *defn;
+  VALUE origin = 0;
+  int noex;
+
+  if (NIL_P(ruby_class)) {
+      rb_raise(rb_eTypeError, "no class/module to add method");
+  }
+  if (ruby_class == rb_cObject && node->nd_mid == init) {
+      rb_warn("redefining Object#initialize may cause infinite loop");
+  }
+  if (node->nd_mid == __id__ || node->nd_mid == __send__) {
+      rb_warn("redefining `%s' may cause serious problem",
+	      rb_id2name(node->nd_mid));
+  }
+  rb_frozen_class_p(ruby_class);
+  body = search_method(ruby_class, node->nd_mid, &origin);
+  if (body){
+      if (RTEST(ruby_verbose) && ruby_class == origin && body->nd_cnt == 0 && body->nd_body) {
+	  rb_warning("method redefined; discarding old %s", rb_id2name(node->nd_mid));
+      }
+  }
+
+  if (SCOPE_TEST(SCOPE_PRIVATE) || node->nd_mid == init) {
+      noex = NOEX_PRIVATE;
+  }
+  else if (SCOPE_TEST(SCOPE_PROTECTED)) {
+      noex = NOEX_PROTECTED;
+  }
+  else {
+      noex = NOEX_PUBLIC;
+  }
+  if (body && origin == ruby_class && body->nd_body == 0) {
+      noex |= NOEX_NOSUPER;
+  }
+
+  defn = rb_copy_node_scope(node->nd_defn, ruby_cref);
+  rb_add_method(ruby_class, node->nd_mid, defn, noex);
+  if (scope_vmode == SCOPE_MODFUNC) {
+      rb_add_method(rb_singleton_class(ruby_class),
+		    node->nd_mid, defn, NOEX_PUBLIC);
+  }
+}
+
+
+eval_node(defs, void)
+{
+  VALUE recv = rb_eval(self, node->nd_recv);
+  VALUE klass;
+  NODE *body = 0, *defn;
+  st_data_t data;
+
+  if (ruby_safe_level >= 4 && !OBJ_TAINTED(recv)) {
+      rb_raise(rb_eSecurityError, "Insecure: can't define singleton method");
+  }
+  if (FIXNUM_P(recv) || SYMBOL_P(recv)) {
+      rb_raise(rb_eTypeError,
+	       "can't define singleton method \"%s\" for %s",
+	       rb_id2name(node->nd_mid),
+	       rb_obj_classname(recv));
+  }
+
+  if (OBJ_FROZEN(recv)) rb_error_frozen("object");
+  klass = rb_singleton_class(recv);
+  if (st_lookup(RCLASS(klass)->m_tbl, node->nd_mid, &data)) {
+      body = (NODE *)data;
+      if (ruby_safe_level >= 4) {
+	  rb_raise(rb_eSecurityError, "redefining method prohibited");
+      }
+      if (RTEST(ruby_verbose)) {
+	  rb_warning("redefine %s", rb_id2name(node->nd_mid));
+      }
+  }
+  defn = rb_copy_node_scope(node->nd_defn, ruby_cref);
+  rb_add_method(klass, node->nd_mid, defn,
+		NOEX_PUBLIC|(body?body->nd_noex&NOEX_UNDEF:0));
+}
+
+
+eval_node(class, VALUE)
+{
+    VALUE super, klass, tmp, cbase;
+    ID cname;
+    int gen = Qfalse;
+
+    cbase = class_prefix(self, node->nd_cpath);
+    cname = node->nd_cpath->nd_mid;
+
+    if (NIL_P(ruby_cbase)) {
+	rb_raise(rb_eTypeError, "no outer class/module");
+    }
+    if (node->nd_super) {
+       super = rb_eval(self, node->nd_super);
+       rb_check_inheritable(super);
+    }
+    else {
+	super = 0;
+    }
+
+    if (rb_const_defined_at(cbase, cname)) {
+	klass = rb_const_get_at(cbase, cname);
+	if (TYPE(klass) != T_CLASS) {
+	    rb_raise(rb_eTypeError, "%s is not a class",
+		     rb_id2name(cname));
+	}
+	if (super) {
+	    tmp = rb_class_real(RCLASS(klass)->super);
+	    if (tmp != super) {
+		rb_raise(rb_eTypeError, "superclass mismatch for class %s",
+			 rb_id2name(cname));
+	    }
+	    super = 0;
+	}
+	if (ruby_safe_level >= 4) {
+	    rb_raise(rb_eSecurityError, "extending class prohibited");
+	}
+    }
+    else {
+	if (!super) super = rb_cObject;
+	klass = rb_define_class_id(cname, super);
+	rb_set_class_path(klass, cbase, rb_id2name(cname));
+	rb_const_set(cbase, cname, klass);
+	gen = Qtrue;
+    }
+    if (ruby_wrapper) {
+	rb_extend_object(klass, ruby_wrapper);
+	rb_include_module(klass, ruby_wrapper);
+    }
+    if (super && gen) {
+	rb_class_inherited(super, klass);
+    }
+    return module_setup(klass, node);
+}
+
+
+eval_node(module, VALUE)
+{
+  VALUE module, cbase;
+  ID cname;
+
+  if (NIL_P(ruby_cbase)) {
+      rb_raise(rb_eTypeError, "no outer class/module");
+  }
+  cbase = class_prefix(self, node->nd_cpath);
+  cname = node->nd_cpath->nd_mid;
+  if (rb_const_defined_at(cbase, cname)) {
+      module = rb_const_get_at(cbase, cname);
+      if (TYPE(module) != T_MODULE) {
+	  rb_raise(rb_eTypeError, "%s is not a module",
+		   rb_id2name(cname));
+      }
+      if (ruby_safe_level >= 4) {
+	  rb_raise(rb_eSecurityError, "extending module prohibited");
+      }
+  }
+  else {
+      module = rb_define_module_id(cname);
+      rb_set_class_path(module, cbase, rb_id2name(cname));
+      rb_const_set(cbase, cname, module);
+  }
+  if (ruby_wrapper) {
+      rb_extend_object(module, ruby_wrapper);
+      rb_include_module(module, ruby_wrapper);
+  }
+
+  return module_setup(module, node);
+}
+
+
+eval_node(sclass, VALUE)
+{
+  VALUE klass, result;
+
+  result = rb_eval(self, node->nd_recv);
+  if (FIXNUM_P(result) || SYMBOL_P(result)) {
+      rb_raise(rb_eTypeError, "no virtual class for %s",
+	       rb_obj_classname(result));
+  }
+  if (ruby_safe_level >= 4 && !OBJ_TAINTED(result))
+      rb_raise(rb_eSecurityError, "Insecure: can't extend object");
+  klass = rb_singleton_class(result);
+
+  if (ruby_wrapper) {
+      rb_extend_object(klass, ruby_wrapper);
+      rb_include_module(klass, ruby_wrapper);
+  }
+
+  return module_setup(klass, node);
+}
+
+
+eval_node(defined, VALUE)
+{
+    char buf[20];
+    const char *desc = is_defined(self, node->nd_head, buf);
+    return desc ? rb_str_new2(desc) : Qnil;
+}
+
+
+static void
+eval_cvar_set(node, result, warn)
+  NODE *node;
+  VALUE result, warn;
+{
+  rb_cvar_set(cvar_cbase(), node->nd_vid, result, warn);
+}
+
+
+static void
+eval_cdecl(self, node, result)
+  VALUE self, result;
+  NODE *node;
+{
+  if (node->nd_vid == 0)
+      rb_const_set(class_prefix(self, node->nd_else), 
+                          node->nd_else->nd_mid, result);
+  else
+      rb_const_set(ruby_cbase, node->nd_vid, result);
+}
+
+
+static VALUE
+rb_eval(self, node)
+  VALUE self;
+  NODE *node;
+{
+  VALUE result;
+
+  eval_check_tick();
+again:
+  CHECK_INTS;
+  result = Qnil;
+  if (node) {
     ruby_current_node = node;
     switch (nd_type(node)) {
       case NODE_BLOCK:
-	if (contnode) {
-	    result = rb_eval(self, node);
-	    break;
+	while (node->nd_next) {
+	    rb_eval(self, node->nd_head);
+	    node = node->nd_next;
 	}
-	contnode = node->nd_next;
 	node = node->nd_head;
 	goto again;
 
       case NODE_POSTEXE:
 	rb_f_END();
 	nd_set_type(node, NODE_NIL); /* exec just once */
-	result = Qnil;
 	break;
 
 	/* begin .. end without clauses */
@@ -3007,65 +3879,33 @@
 
 	/* nodes for speed-up(literal match) */
       case NODE_MATCH2:
-	{
-	    VALUE l = rb_eval(self,node->nd_recv);
-	    VALUE r = rb_eval(self,node->nd_value);
-	    result = rb_reg_match(l, r);
-	}
+        result = eval_match2(self, node);
 	break;
 
 	/* nodes for speed-up(literal match) */
       case NODE_MATCH3:
-	{
-	    VALUE r = rb_eval(self,node->nd_recv);
-	    VALUE l = rb_eval(self,node->nd_value);
-	    if (TYPE(l) == T_STRING) {
-		result = rb_reg_match(r, l);
-	    }
-	    else {
-		result = rb_funcall(l, match, 1, r);
-	    }
-	}
+        result = eval_match3(self,node);
 	break;
 
 	/* node for speed-up(top-level loop for -n/-p) */
       case NODE_OPT_N:
-	PUSH_TAG(PROT_LOOP);
-	switch (state = EXEC_TAG()) {
-	  case 0:
-	  opt_n_next:
-	    while (!NIL_P(rb_gets())) {
-	      opt_n_redo:
-		rb_eval(self, node->nd_body);
-	    }
-	    break;
-
-	  case TAG_REDO:
-	    state = 0;
-	    goto opt_n_redo;
-	  case TAG_NEXT:
-	    state = 0;
-	    goto opt_n_next;
-	  case TAG_BREAK:
-	    state = 0;
-	  default:
-	    break;
-	}
-	POP_TAG();
-	if (state) JUMP_TAG(state);
-	RETURN(Qnil);
+        eval_opt_n(self, node);
+        break;
 
       case NODE_SELF:
-	RETURN(self);
+	result = self;
+        break;
 
       case NODE_NIL:
-	RETURN(Qnil);
+	break;
 
       case NODE_TRUE:
-	RETURN(Qtrue);
+	result = Qtrue;
+        break;
 
       case NODE_FALSE:
-	RETURN(Qfalse);
+	result = Qfalse;
+        break;
 
       case NODE_IF:
 	if (RTEST(rb_eval(self, node->nd_cond))) {
@@ -3083,150 +3923,20 @@
 	goto again;
 
       case NODE_WHEN:
-	while (node) {
-	    NODE *tag;
-
-	    if (nd_type(node) != NODE_WHEN) goto again;
-	    tag = node->nd_head;
-	    while (tag) {
-		EXEC_EVENT_HOOK(RUBY_EVENT_LINE, tag, self,
-				ruby_frame->last_func,
-				ruby_frame->last_class);
-		if (tag->nd_head && nd_type(tag->nd_head) == NODE_WHEN) {
-		    VALUE v = rb_eval(self, tag->nd_head->nd_head);
-		    long i;
-
-		    if (TYPE(v) != T_ARRAY) v = rb_ary_to_ary(v);
-		    for (i=0; i<RARRAY(v)->len; i++) {
-			if (RTEST(RARRAY(v)->ptr[i])) {
-			    node = node->nd_body;
-			    goto again;
-			}
-		    }
-		    tag = tag->nd_next;
-		    continue;
-		}
-		if (RTEST(rb_eval(self, tag->nd_head))) {
-		    node = node->nd_body;
-		    goto again;
-		}
-		tag = tag->nd_next;
-	    }
-	    node = node->nd_next;
-	}
-	RETURN(Qnil);
+        if ((node = eval_when(self, node))) goto again;
+        break;
 
       case NODE_CASE:
-	{
-	    VALUE val;
-
-	    val = rb_eval(self, node->nd_head);
-	    node = node->nd_body;
-	    while (node) {
-		NODE *tag;
-
-		if (nd_type(node) != NODE_WHEN) {
-		    goto again;
-		}
-		tag = node->nd_head;
-		while (tag) {
-		    EXEC_EVENT_HOOK(RUBY_EVENT_LINE, tag, self,
-				    ruby_frame->last_func,
-				    ruby_frame->last_class);
-		    if (tag->nd_head && nd_type(tag->nd_head) == NODE_WHEN) {
-			VALUE v = rb_eval(self, tag->nd_head->nd_head);
-			long i;
-
-			if (TYPE(v) != T_ARRAY) v = rb_ary_to_ary(v);
-			for (i=0; i<RARRAY(v)->len; i++) {
-			    if (RTEST(rb_funcall2(RARRAY(v)->ptr[i], eqq, 1, &val))){
-				node = node->nd_body;
-				goto again;
-			    }
-			}
-			tag = tag->nd_next;
-			continue;
-		    }
-		    if (RTEST(rb_funcall2(rb_eval(self, tag->nd_head), eqq, 1, &val))) {
-			node = node->nd_body;
-			goto again;
-		    }
-		    tag = tag->nd_next;
-		}
-		node = node->nd_next;
-	    }
-	}
-	RETURN(Qnil);
+        if ((node = eval_case(self, node))) goto again;
+        break;
 
       case NODE_WHILE:
-	PUSH_TAG(PROT_LOOP);
-	result = Qnil;
-	switch (state = EXEC_TAG()) {
-	  case 0:
-	    if (node->nd_state && !RTEST(rb_eval(self, node->nd_cond)))
-		goto while_out;
-	    do {
-	      while_redo:
-		rb_eval(self, node->nd_body);
-	      while_next:
-		;
-	    } while (RTEST(rb_eval(self, node->nd_cond)));
-	    break;
-
-	  case TAG_REDO:
-	    state = 0;
-	    goto while_redo;
-	  case TAG_NEXT:
-	    state = 0;
-	    goto while_next;
-	  case TAG_BREAK:
-	    if (TAG_DST()) {
-		state = 0;
-		result = prot_tag->retval;
-	    }
-	    /* fall through */
-	  default:
-	    break;
-	}
-      while_out:
-	POP_TAG();
-	if (state) JUMP_TAG(state);
-	RETURN(result);
+        result = eval_while(self,node);
+        break;
 
       case NODE_UNTIL:
-	PUSH_TAG(PROT_LOOP);
-	result = Qnil;
-	switch (state = EXEC_TAG()) {
-	  case 0:
-	    if (node->nd_state && RTEST(rb_eval(self, node->nd_cond)))
-		goto until_out;
-	    do {
-	      until_redo:
-		rb_eval(self, node->nd_body);
-	      until_next:
-		;
-	    } while (!RTEST(rb_eval(self, node->nd_cond)));
-	    break;
-
-	  case TAG_REDO:
-	    state = 0;
-	    goto until_redo;
-	  case TAG_NEXT:
-	    state = 0;
-	    goto until_next;
-	  case TAG_BREAK:
-	    if (TAG_DST()) {
-		state = 0;
-		result = prot_tag->retval;
-	    }
-	    /* fall through */
-	  default:
-	    break;
-	}
-      until_out:
-	POP_TAG();
-	if (state) JUMP_TAG(state);
-	RETURN(result);
+        result = eval_until(self,node);
+        break;
 
       case NODE_BLOCK_PASS:
 	result = block_pass(self, node);
@@ -3234,47 +3944,7 @@
 
       case NODE_ITER:
       case NODE_FOR:
-	{
-	    PUSH_TAG(PROT_LOOP);
-	    PUSH_BLOCK(node->nd_var, node->nd_body);
-
-	    state = EXEC_TAG();
-	    if (state == 0) {
-	      iter_retry:
-		PUSH_ITER(ITER_PRE);
-		if (nd_type(node) == NODE_ITER) {
-		    result = rb_eval(self, node->nd_iter);
-		}
-		else {
-		    VALUE recv;
-
-		    _block.flags &= ~BLOCK_D_SCOPE;
-		    BEGIN_CALLARGS;
-		    recv = rb_eval(self, node->nd_iter);
-		    END_CALLARGS;
-		    ruby_current_node = node;
-		    SET_CURRENT_SOURCE();
-		    result = rb_call(CLASS_OF(recv),recv,each,0,0,0,self);
-		}
-		POP_ITER();
-	    }
-	    else if (state == TAG_BREAK && TAG_DST()) {
-		result = prot_tag->retval;
-		state = 0;
-	    }
-	    else if (state == TAG_RETRY) {
-		state = 0;
-		goto iter_retry;
-	    }
-	    POP_BLOCK();
-	    POP_TAG();
-	    switch (state) {
-	      case 0:
-		break;
-	      default:
-		JUMP_TAG(state);
-	    }
-	}
+	result = eval_iter(self, node);
 	break;
 
       case NODE_BREAK:
@@ -3282,19 +3952,14 @@
 	break;
 
       case NODE_NEXT:
-	CHECK_INTS;
 	next_jump(rb_eval(self, node->nd_stts));
 	break;
 
       case NODE_REDO:
-	CHECK_INTS;
 	JUMP_TAG(TAG_REDO);
-	break;
 
       case NODE_RETRY:
-	CHECK_INTS;
 	JUMP_TAG(TAG_RETRY);
-	break;
 
       case NODE_SPLAT:
 	result = splat_value(rb_eval(self, node->nd_head));
@@ -3317,78 +3982,19 @@
 	else {
 	    result = Qundef;	/* no arg */
 	}
-	SET_CURRENT_SOURCE();
 	result = rb_yield_0(result, 0, 0, 0, node->nd_state);
 	break;
 
       case NODE_RESCUE:
-	{
-	    volatile VALUE e_info = ruby_errinfo;
-	    volatile int rescuing = 0;
-
-	    PUSH_TAG(PROT_NONE);
-	    if ((state = EXEC_TAG()) == 0) {
-	      retry_entry:
-		result = rb_eval(self, node->nd_head);
-	    }
-	    else if (rescuing) {
-		if (rescuing < 0) {
-		    /* in rescue argument, just reraise */
-		}
-		else if (state == TAG_RETRY) {
-		    rescuing = state = 0;
-		    ruby_errinfo = e_info;
-		    goto retry_entry;
-		}
-		else if (state != TAG_RAISE) {
-		    result = prot_tag->retval;
-		}
-	    }
-	    else if (state == TAG_RAISE) {
-		NODE *resq = node->nd_resq;
-
-		rescuing = -1;
-		while (resq) {
-		    ruby_current_node = resq;
-		    if (handle_rescue(self, resq)) {
-			state = 0;
-			rescuing = 1;
-			result = rb_eval(self, resq->nd_body);
-			break;
-		    }
-		    resq = resq->nd_head; /* next rescue */
-		}
-	    }
-	    else {
-		result = prot_tag->retval;
-	    }
-	    POP_TAG();
-	    if (state != TAG_RAISE) ruby_errinfo = e_info;
-	    if (state) {
-		JUMP_TAG(state);
-	    }
-	    /* no exception raised */
-	    if (!rescuing && (node = node->nd_else)) { /* else clause given */
-		goto again;
-	    }
-	}
+        result = eval_rescue(self,node);
+        if (result == Qundef) {  /* handle else clause w/o recursion */
+          node = node->nd_else;
+          goto again;
+        }
 	break;
 
       case NODE_ENSURE:
-	PUSH_TAG(PROT_NONE);
-	if ((state = EXEC_TAG()) == 0) {
-	    result = rb_eval(self, node->nd_head);
-	}
-	POP_TAG();
-	if (node->nd_ensr && !thread_no_ensure()) {
-	    VALUE retval = prot_tag->retval; /* save retval */
-	    VALUE errinfo = ruby_errinfo;
-
-	    rb_eval(self, node->nd_ensr);
-	    return_value(retval);
-	    ruby_errinfo = errinfo;
-	}
-	if (state) JUMP_TAG(state);
+        result = eval_ensure(self,node);
 	break;
 
       case NODE_AND:
@@ -3404,56 +4010,20 @@
 	goto again;
 
       case NODE_NOT:
-	if (RTEST(rb_eval(self, node->nd_body))) result = Qfalse;
-	else result = Qtrue;
+	result = RTEST(rb_eval(self, node->nd_body)) ? Qfalse : Qtrue;
 	break;
 
       case NODE_DOT2:
       case NODE_DOT3:
-        {
-	    VALUE beg = rb_eval(self, node->nd_beg);
-	    VALUE end = rb_eval(self, node->nd_end);
-	    result = rb_range_new(beg, end, nd_type(node) == NODE_DOT3);
-	}	
-	break;
+        result = eval_dot(self,node);
+        break;
 
       case NODE_FLIP2:		/* like AWK */
-	{
-	    VALUE *flip = rb_svar(node->nd_cnt);
-	    if (!flip) rb_bug("unexpected local variable");
-	    if (!RTEST(*flip)) {
-		if (RTEST(rb_eval(self, node->nd_beg))) {
-		    *flip = RTEST(rb_eval(self, node->nd_end))?Qfalse:Qtrue;
-		    result = Qtrue;
-		}
-		else {
-		    result = Qfalse;
-		}
-	    }
-	    else {
-		if (RTEST(rb_eval(self, node->nd_end))) {
-		    *flip = Qfalse;
-		}
-		result = Qtrue;
-	    }
-	}
+        result = eval_flip2(self,node);
 	break;
 
       case NODE_FLIP3:		/* like SED */
-	{
-	    VALUE *flip = rb_svar(node->nd_cnt);
-	    if (!flip) rb_bug("unexpected local variable");
-	    if (!RTEST(*flip)) {
-		result = RTEST(rb_eval(self, node->nd_beg)) ? Qtrue : Qfalse;
-		*flip = result;
-	    }
-	    else {
-		if (RTEST(rb_eval(self, node->nd_end))) {
-		    *flip = Qfalse;
-		}
-		result = Qtrue;
-	    }
-	}
+        result = eval_flip3(self,node);
 	break;
 
       case NODE_RETURN:
@@ -3461,220 +4031,46 @@
 	break;
 
       case NODE_ARGSCAT:
-	{
-	    VALUE args = rb_eval(self, node->nd_head);
-	    result = rb_ary_concat(args, splat_value(rb_eval(self, node->nd_body)));
-	}
+	result = rb_eval(self, node->nd_head);
+	result = rb_ary_concat(result, splat_value(rb_eval(self, node->nd_body)));
 	break;
 
       case NODE_ARGSPUSH:
-	{
-	    VALUE args = rb_ary_dup(rb_eval(self, node->nd_head));
-	    result = rb_ary_push(args, rb_eval(self, node->nd_body));
-	}
+	result = rb_ary_dup(rb_eval(self, node->nd_head));
+	result = rb_ary_push(result, rb_eval(self, node->nd_body));
 	break;
 
       case NODE_ATTRASGN:
-	{
-	    VALUE recv;
-	    int argc; VALUE *argv; /* used in SETUP_ARGS */
-	    int scope;
-	    TMP_PROTECT;
-
-	    BEGIN_CALLARGS;
-	    if (node->nd_recv == (NODE *)1) {
-		recv = self;
-		scope = 1;
-	    }
-	    else {
-		recv = rb_eval(self, node->nd_recv);
-		scope = 0;
-	    }
-	    SETUP_ARGS(node->nd_args);
-	    END_CALLARGS;
-
-	    ruby_current_node = node;
-	    SET_CURRENT_SOURCE();
-	    rb_call(CLASS_OF(recv),recv,node->nd_mid,argc,argv,scope,self);
-	    result = argv[argc-1];
-	}
-	break;
+        result = eval_attrasgn(self,node);
+        break;
 
       case NODE_CALL:
-	{
-	    VALUE recv;
-	    int argc; VALUE *argv; /* used in SETUP_ARGS */
-	    TMP_PROTECT;
-
-	    BEGIN_CALLARGS;
-	    recv = rb_eval(self, node->nd_recv);
-	    SETUP_ARGS(node->nd_args);
-	    END_CALLARGS;
-
-	    ruby_current_node = node;
-	    SET_CURRENT_SOURCE();
-	    result = rb_call(CLASS_OF(recv),recv,node->nd_mid,argc,argv,0,self);
-	}
+        result = eval_call(self,node);
 	break;
 
       case NODE_FCALL:
-	{
-	    int argc; VALUE *argv; /* used in SETUP_ARGS */
-	    TMP_PROTECT;
-
-	    BEGIN_CALLARGS;
-	    SETUP_ARGS(node->nd_args);
-	    END_CALLARGS;
-
-	    ruby_current_node = node;
-	    SET_CURRENT_SOURCE();
-	    result = rb_call(CLASS_OF(self),self,node->nd_mid,argc,argv,1,self);
-	}
+        result = eval_fcall(self,node);
 	break;
 
       case NODE_VCALL:
-	SET_CURRENT_SOURCE();
 	result = rb_call(CLASS_OF(self),self,node->nd_mid,0,0,2,self);
 	break;
 
       case NODE_SUPER:
       case NODE_ZSUPER:
-	{
-	    int argc; VALUE *argv; /* used in SETUP_ARGS */
-	    TMP_PROTECT;
-
-	    if (ruby_frame->last_class == 0) {
-		if (ruby_frame->last_func) {
-		    rb_name_error(ruby_frame->last_func,
-				  "superclass method `%s' disabled",
-				  rb_id2name(ruby_frame->orig_func));
-		}
-		else {
-		    rb_raise(rb_eNoMethodError, "super called outside of method");
-		}
-	    }
-	    if (nd_type(node) == NODE_ZSUPER) {
-		argc = ruby_frame->argc;
-		if (argc && DMETHOD_P()) {
-		    if (TYPE(RBASIC(ruby_scope)->klass) != T_ARRAY ||
-			RARRAY(RBASIC(ruby_scope)->klass)->len != argc) {
-			rb_raise(rb_eRuntimeError, 
-				 "super: specify arguments explicitly");
-		    }
-		    argv = RARRAY(RBASIC(ruby_scope)->klass)->ptr;
-		}
-		else if (!ruby_scope->local_vars) {
-		    argc = 0;
-		    argv = 0;
-		}
-		else {
-		    argv = ruby_scope->local_vars + 2;
-		}
-	    }
-	    else {
-		BEGIN_CALLARGS;
-		SETUP_ARGS(node->nd_args);
-		END_CALLARGS;
-		ruby_current_node = node;
-	    }
-
-	    SET_CURRENT_SOURCE();
-	    result = rb_call_super(argc, argv);
-	}
+        result = eval_super(self,node);
 	break;
 
       case NODE_SCOPE:
-	{
-	    struct FRAME frame;
-	    NODE *saved_cref = 0;
-
-	    frame = *ruby_frame;
-	    frame.tmp = ruby_frame;
-	    ruby_frame = &frame;
-
-	    PUSH_SCOPE();
-	    PUSH_TAG(PROT_NONE);
-	    if (node->nd_rval) {
-		saved_cref = ruby_cref;
-		ruby_cref = (NODE*)node->nd_rval;
-	    }
-	    if (node->nd_tbl) {
-		VALUE *vars = ALLOCA_N(VALUE, node->nd_tbl[0]+1);
-		*vars++ = (VALUE)node;
-		ruby_scope->local_vars = vars;
-		rb_mem_clear(ruby_scope->local_vars, node->nd_tbl[0]);
-		ruby_scope->local_tbl = node->nd_tbl;
-	    }
-	    else {
-		ruby_scope->local_vars = 0;
-		ruby_scope->local_tbl  = 0;
-	    }
-	    if ((state = EXEC_TAG()) == 0) {
-		result = rb_eval(self, node->nd_next);
-	    }
-	    POP_TAG();
-	    POP_SCOPE();
-	    ruby_frame = frame.tmp;
-	    if (saved_cref)
-		ruby_cref = saved_cref;
-	    if (state) JUMP_TAG(state);
-	}
-	break;
+        result = eval_scope(self,node);
+        break;
 
       case NODE_OP_ASGN1:
-	{
-	    int argc; VALUE *argv; /* used in SETUP_ARGS */
-	    VALUE recv, val, tmp;
-	    NODE *rval;
-	    TMP_PROTECT;
-
-	    recv = rb_eval(self, node->nd_recv);
-	    rval = node->nd_args->nd_head;
-	    SETUP_ARGS0(node->nd_args->nd_body, 1);
-	    val = rb_funcall3(recv, aref, argc, argv);
-	    switch (node->nd_mid) {
-	    case 0: /* OR */
-	      if (RTEST(val)) RETURN(val);
-	      val = rb_eval(self, rval);
-	      break;
-	    case 1: /* AND */
-	      if (!RTEST(val)) RETURN(val);
-	      val = rb_eval(self, rval);
-	      break;
-	    default:
-	      tmp = rb_eval(self, rval);
-	      val = rb_funcall3(val, node->nd_mid, 1, &tmp);
-	    }
-	    argv[argc] = val;
-	    rb_funcall2(recv, aset, argc+1, argv);
-	    result = val;
-	}
+        result = eval_op_asgn1(self,node);
 	break;
 
       case NODE_OP_ASGN2:
-	{
-	    ID id = node->nd_next->nd_vid;
-	    VALUE recv, val, tmp;
-
-	    recv = rb_eval(self, node->nd_recv);
-	    val = rb_funcall3(recv, id, 0, 0);
-	    switch (node->nd_next->nd_mid) {
-	    case 0: /* OR */
-	      if (RTEST(val)) RETURN(val);
-	      val = rb_eval(self, node->nd_value);
-	      break;
-	    case 1: /* AND */
-	      if (!RTEST(val)) RETURN(val);
-	      val = rb_eval(self, node->nd_value);
-	      break;
-	    default:
-	      tmp = rb_eval(self, node->nd_value);
-	      val = rb_funcall3(val, node->nd_next->nd_mid, 1, &tmp);
-	    }
-
-	    rb_funcall2(recv, node->nd_next->nd_aid, 1, &val);
-	    result = val;
-	}
+        result = eval_op_asgn2(self,node);
 	break;
 
       case NODE_OP_ASGN_AND:
@@ -3723,26 +4119,21 @@
 	break;
 
       case NODE_CDECL:
-	result = rb_eval(self, node->nd_value);
-	if (node->nd_vid == 0) {
-	    rb_const_set(class_prefix(self, node->nd_else), node->nd_else->nd_mid, result);
-	}
-	else {
-	    rb_const_set(ruby_cbase, node->nd_vid, result);
-	}
+        result = rb_eval(self, node->nd_value);
+        eval_cdecl(self, node, result);
 	break;
 
       case NODE_CVDECL:
 	if (NIL_P(ruby_cbase)) {
 	    rb_raise(rb_eTypeError, "no class/module to define class variable");
 	}
-	result = rb_eval(self, node->nd_value);
-	rb_cvar_set(cvar_cbase(), node->nd_vid, result, Qtrue);
+        result = rb_eval(self, node->nd_value);
+        eval_cvar_set(node, result, Qtrue);
 	break;
 
       case NODE_CVASGN:
-	result = rb_eval(self, node->nd_value);
-	rb_cvar_set(cvar_cbase(), node->nd_vid, result, Qfalse);
+        result = rb_eval(self, node->nd_value);
+        eval_cvar_set(node, result, Qfalse);
 	break;
 
       case NODE_LVAR:
@@ -3785,26 +4176,21 @@
 	break;
 
       case NODE_COLON2:
-	{
-	    VALUE klass;
-
-	    klass = rb_eval(self, node->nd_head);
-	    if (rb_is_const_id(node->nd_mid)) {
-		switch (TYPE(klass)) {
-		  case T_CLASS:
-		  case T_MODULE:
-		    result = rb_const_get_from(klass, node->nd_mid);
-		    break;
-		  default:
-		    rb_raise(rb_eTypeError, "%s is not a class/module",
-			     RSTRING(rb_obj_as_string(klass))->ptr);
-		    break;
-		}
-	    }
-	    else {
-		result = rb_funcall(klass, node->nd_mid, 0, 0);
+	result = rb_eval(self, node->nd_head);
+	if (rb_is_const_id(node->nd_mid)) {
+	    switch (TYPE(result)) {
+	      case T_CLASS:
+	      case T_MODULE:
+		result = rb_const_get_from(result, node->nd_mid);
+		break;
+	      default:
+		rb_raise(rb_eTypeError, "%s is not a class/module",
+			 RSTRING(rb_obj_as_string(result))->ptr);
+		break;
 	    }
 	}
+	else
+	    result = rb_funcall(result, node->nd_mid, 0, 0);
 	break;
 
       case NODE_COLON3:
@@ -3835,23 +4221,7 @@
 	break;
 
       case NODE_HASH:
-	{
-	    NODE *list;
-	    VALUE hash = rb_hash_new();
-	    VALUE key, val;
-
-	    list = node->nd_head;
-	    while (list) {
-		key = rb_eval(self, list->nd_head);
-		list = list->nd_next;
-		if (list == 0)
-		    rb_bug("odd number list for Hash");
-		val = rb_eval(self, list->nd_head);
-		list = list->nd_next;
-		rb_hash_aset(hash, key, val);
-	    }
-	    result = hash;
-	}
+        result = eval_hash(self,node);
 	break;
 
       case NODE_ZARRAY:		/* zero length list */
@@ -3859,19 +4229,7 @@
 	break;
 
       case NODE_ARRAY:
-	{
-	    VALUE ary;
-	    long i;
-
-	    i = node->nd_alen;
-	    ary = rb_ary_new2(i);
-	    for (i=0;node;node=node->nd_next) {
-		RARRAY(ary)->ptr[i++] = rb_eval(self, node->nd_head);
-		RARRAY(ary)->len = i;
-	    }
-
-	    result = ary;
-	}
+        result = eval_array(self,node);
 	break;
 
       case NODE_STR:
@@ -3887,53 +4245,8 @@
       case NODE_DREGX:
       case NODE_DREGX_ONCE:
       case NODE_DSYM:
-	{
-	    VALUE str, str2;
-	    NODE *list = node->nd_next;
-
-	    str = rb_str_new3(node->nd_lit);
-	    while (list) {
-		if (list->nd_head) {
-		    switch (nd_type(list->nd_head)) {
-		      case NODE_STR:
-			str2 = list->nd_head->nd_lit;
-			break;
-		      default:
-			str2 = rb_eval(self, list->nd_head);
-			break;
-		    }
-		    rb_str_append(str, str2);
-		    OBJ_INFECT(str, str2);
-		}
-		list = list->nd_next;
-	    }
-	    switch (nd_type(node)) {
-	      case NODE_DREGX:
-		result = rb_reg_new(RSTRING(str)->ptr, RSTRING(str)->len,
-				    node->nd_cflag);
-		RB_GC_GUARD(str); /* ensure str is not GC'd in rb_reg_new */
-		break;
-	      case NODE_DREGX_ONCE:	/* regexp expand once */
-		result = rb_reg_new(RSTRING(str)->ptr, RSTRING(str)->len,
-				    node->nd_cflag);
-		nd_set_type(node, NODE_LIT);
-		RB_GC_GUARD(str); /* ensure str is not GC'd in rb_reg_new */
-		node->nd_lit = result;
-		break;
-	      case NODE_LIT:
-		/* other thread may replace NODE_DREGX_ONCE to NODE_LIT */
-		goto again;
-	      case NODE_DXSTR:
-		result = rb_funcall(self, '`', 1, str);
-		break;
-	      case NODE_DSYM:
-		result = rb_str_intern(str);
-		break;
-	      default:
-		result = str;
-		break;
-	    }
-	}
+        result = eval_slit(self, node);
+        if (result == Qundef) goto again;
 	break;
 
       case NODE_XSTR:
@@ -3945,84 +4258,13 @@
 	break;
 
       case NODE_DEFN:
-	if (node->nd_defn) {
-	    NODE *body,  *defn;
-	    VALUE origin = 0;
-	    int noex;
-
-	    if (NIL_P(ruby_class)) {
-		rb_raise(rb_eTypeError, "no class/module to add method");
-	    }
-	    if (ruby_class == rb_cObject && node->nd_mid == init) {
-		rb_warn("redefining Object#initialize may cause infinite loop");
-	    }
-	    if (node->nd_mid == __id__ || node->nd_mid == __send__) {
-		rb_warn("redefining `%s' may cause serious problem",
-			rb_id2name(node->nd_mid));
-	    }
-	    rb_frozen_class_p(ruby_class);
-	    body = search_method(ruby_class, node->nd_mid, &origin);
-	    if (body){
-		if (RTEST(ruby_verbose) && ruby_class == origin && body->nd_cnt == 0 && body->nd_body) {
-		    rb_warning("method redefined; discarding old %s", rb_id2name(node->nd_mid));
-		}
-	    }
-
-	    if (SCOPE_TEST(SCOPE_PRIVATE) || node->nd_mid == init) {
-		noex = NOEX_PRIVATE;
-	    }
-	    else if (SCOPE_TEST(SCOPE_PROTECTED)) {
-		noex = NOEX_PROTECTED;
-	    }
-	    else {
-		noex = NOEX_PUBLIC;
-	    }
-	    if (body && origin == ruby_class && body->nd_body == 0) {
-		noex |= NOEX_NOSUPER;
-	    }
-
-	    defn = rb_copy_node_scope(node->nd_defn, ruby_cref);
-	    rb_add_method(ruby_class, node->nd_mid, defn, noex);
-	    if (scope_vmode == SCOPE_MODFUNC) {
-		rb_add_method(rb_singleton_class(ruby_class),
-			      node->nd_mid, defn, NOEX_PUBLIC);
-	    }
-	    result = Qnil;
-	}
+	if (node->nd_defn)
+          eval_defn(self,node);
 	break;
 
       case NODE_DEFS:
-	if (node->nd_defn) {
-	    VALUE recv = rb_eval(self, node->nd_recv);
-	    VALUE klass;
-	    NODE *body = 0, *defn;
-
-	    if (ruby_safe_level >= 4 && !OBJ_TAINTED(recv)) {
-		rb_raise(rb_eSecurityError, "Insecure: can't define singleton method");
-	    }
-	    if (FIXNUM_P(recv) || SYMBOL_P(recv)) {
-		rb_raise(rb_eTypeError,
-			 "can't define singleton method \"%s\" for %s",
-			 rb_id2name(node->nd_mid),
-			 rb_obj_classname(recv));
-	    }
-
-	    if (OBJ_FROZEN(recv)) rb_error_frozen("object");
-	    klass = rb_singleton_class(recv);
-	    if (st_lookup(RCLASS(klass)->m_tbl, node->nd_mid, &data)) {
-		body = (NODE *)data;
-		if (ruby_safe_level >= 4) {
-		    rb_raise(rb_eSecurityError, "redefining method prohibited");
-		}
-		if (RTEST(ruby_verbose)) {
-		    rb_warning("redefine %s", rb_id2name(node->nd_mid));
-		}
-	    }
-	    defn = rb_copy_node_scope(node->nd_defn, ruby_cref);
-	    rb_add_method(klass, node->nd_mid, defn,
-			  NOEX_PUBLIC|(body?body->nd_noex&NOEX_UNDEF:0));
-	    result = Qnil;
-	}
+	if (node->nd_defn) 
+          eval_defs(self,node);
 	break;
 
       case NODE_UNDEF:
@@ -4030,7 +4272,6 @@
 	    rb_raise(rb_eTypeError, "no class to undef method");
 	}
 	rb_undef(ruby_class, rb_to_id(rb_eval(self, node->u2.node)));
-	result = Qnil;
 	break;
 
       case NODE_ALIAS:
@@ -4039,134 +4280,26 @@
 	}
 	rb_alias(ruby_class, rb_to_id(rb_eval(self, node->u1.node)),
 		             rb_to_id(rb_eval(self, node->u2.node)));
-	result = Qnil;
 	break;
 
       case NODE_VALIAS:
 	rb_alias_variable(node->u1.id, node->u2.id);
-	result = Qnil;
 	break;
 
       case NODE_CLASS:
-	{
-	    VALUE super, klass, tmp, cbase;
-	    ID cname;
-	    int gen = Qfalse;
-
-	    cbase = class_prefix(self, node->nd_cpath);
-	    cname = node->nd_cpath->nd_mid;
-
-	    if (NIL_P(ruby_cbase)) {
-		rb_raise(rb_eTypeError, "no outer class/module");
-	    }
-	    if (node->nd_super) {
-	       super = rb_eval(self, node->nd_super);
-	       rb_check_inheritable(super);
-	    }
-	    else {
-		super = 0;
-	    }
-
-	    if (rb_const_defined_at(cbase, cname)) {
-		klass = rb_const_get_at(cbase, cname);
-		if (TYPE(klass) != T_CLASS) {
-		    rb_raise(rb_eTypeError, "%s is not a class",
-			     rb_id2name(cname));
-		}
-		if (super) {
-		    tmp = rb_class_real(RCLASS(klass)->super);
-		    if (tmp != super) {
-			rb_raise(rb_eTypeError, "superclass mismatch for class %s",
-				 rb_id2name(cname));
-		    }
-		    super = 0;
-		}
-		if (ruby_safe_level >= 4) {
-		    rb_raise(rb_eSecurityError, "extending class prohibited");
-		}
-	    }
-	    else {
-		if (!super) super = rb_cObject;
-		klass = rb_define_class_id(cname, super);
-		rb_set_class_path(klass, cbase, rb_id2name(cname));
-		rb_const_set(cbase, cname, klass);
-		gen = Qtrue;
-	    }
-	    if (ruby_wrapper) {
-		rb_extend_object(klass, ruby_wrapper);
-		rb_include_module(klass, ruby_wrapper);
-	    }
-	    if (super && gen) {
-		rb_class_inherited(super, klass);
-	    }
-	    result = module_setup(klass, node);
-	}
+        result = eval_class(self,node);
 	break;
 
       case NODE_MODULE:
-	{
-	    VALUE module, cbase;
-	    ID cname;
-
-	    if (NIL_P(ruby_cbase)) {
-		rb_raise(rb_eTypeError, "no outer class/module");
-	    }
-	    cbase = class_prefix(self, node->nd_cpath);
-	    cname = node->nd_cpath->nd_mid;
-	    if (rb_const_defined_at(cbase, cname)) {
-		module = rb_const_get_at(cbase, cname);
-		if (TYPE(module) != T_MODULE) {
-		    rb_raise(rb_eTypeError, "%s is not a module",
-			     rb_id2name(cname));
-		}
-		if (ruby_safe_level >= 4) {
-		    rb_raise(rb_eSecurityError, "extending module prohibited");
-		}
-	    }
-	    else {
-		module = rb_define_module_id(cname);
-		rb_set_class_path(module, cbase, rb_id2name(cname));
-		rb_const_set(cbase, cname, module);
-	    }
-	    if (ruby_wrapper) {
-		rb_extend_object(module, ruby_wrapper);
-		rb_include_module(module, ruby_wrapper);
-	    }
-
-	    result = module_setup(module, node);
-	}
+        result = eval_module(self,node);
 	break;
 
       case NODE_SCLASS:
-	{
-	    VALUE klass;
-
-	    result = rb_eval(self, node->nd_recv);
-	    if (FIXNUM_P(result) || SYMBOL_P(result)) {
-		rb_raise(rb_eTypeError, "no virtual class for %s",
-			 rb_obj_classname(result));
-	    }
-	    if (ruby_safe_level >= 4 && !OBJ_TAINTED(result))
-		rb_raise(rb_eSecurityError, "Insecure: can't extend object");
-	    klass = rb_singleton_class(result);
-
-	    if (ruby_wrapper) {
-		rb_extend_object(klass, ruby_wrapper);
-		rb_include_module(klass, ruby_wrapper);
-	    }
-
-	    result = module_setup(klass, node);
-	}
+        result = eval_sclass(self,node);
 	break;
 
       case NODE_DEFINED:
-	{
-	    char buf[20];
-	    const char *desc = is_defined(self, node->nd_head, buf);
-
-	    if (desc) result = rb_str_new2(desc);
-	    else result = Qnil;
-	}
+        result = eval_defined(self,node);
 	break;
 
       case NODE_NEWLINE:
@@ -4179,25 +4312,19 @@
       default:
 	unknown_node(node);
     }
-  finish:
-    CHECK_INTS;
-    if (contnode) {
-	node = contnode;
-	contnode = 0;
-	goto again;
-    }
-    return result;
+  }
+  return result;
 }
 
 static VALUE
 module_setup(module, n)
     VALUE module;
-    NODE *n;
+    NODE * volatile n;
 {
-    NODE * volatile node = n->nd_body;
+    NODE *node = n->nd_body;
     int state;
     struct FRAME frame;
-    VALUE result = Qnil;	/* OK */
+    VALUE result;
     TMP_PROTECT;
 
     frame = *ruby_frame;
@@ -4588,16 +4715,16 @@
     break_jump(Qnil);
 }
 
-NORETURN(static void rb_longjmp _((int, VALUE)));
+NORETURN(static void rb_longjmp _((volatile int, volatile VALUE)));
 static VALUE make_backtrace _((void));
 
 static void
 rb_longjmp(tag, mesg)
-    int tag;
-    VALUE mesg;
+    volatile int tag;
+    volatile VALUE mesg;
 {
     VALUE at;
-    rb_thread_t th = curr_thread;
+    volatile rb_thread_t th = curr_thread;
 
     if (rb_thread_set_raised(th)) {
 	ruby_errinfo = exception_error;
@@ -4730,14 +4857,12 @@
     int argc;
     VALUE *argv;
 {
-    VALUE mesg;
+    VALUE mesg = Qnil;
     ID exception;
     int n;
 
-    mesg = Qnil;
     switch (argc) {
       case 0:
-	mesg = Qnil;
 	break;
       case 1:
 	if (NIL_P(argv[0])) break;
@@ -4908,7 +5033,7 @@
 	    tt->dst = (VALUE)tt->frame->uniq;
 	    tt->retval = retval;
 	    JUMP_TAG(TAG_BREAK);
-	    break;
+
 	  case PROT_FUNC:
 	    tt = 0;
 	    continue;
@@ -4937,7 +5062,7 @@
 	    tt->dst = (VALUE)tt->frame->uniq;
 	    tt->retval = retval;
 	    JUMP_TAG(TAG_NEXT);
-	    break;
+
 	  default:
 	    break;
 	}
@@ -4956,19 +5081,21 @@
 
 static VALUE
 rb_yield_0(val, self, klass, flags, avalue)
-    VALUE val, self, klass;	/* OK */
-    int flags, avalue;
+    volatile VALUE val, self;
+    VALUE klass;
+    int flags;
+    volatile int avalue;
 {
-    NODE *node, *var;
+    NODE *var, *volatile node;
     volatile VALUE result = Qnil;
     volatile VALUE old_cref;
     volatile VALUE old_wrapper;
     struct BLOCK * volatile block;
     struct SCOPE * volatile old_scope;
-    int old_vmode;
+    volatile int old_vmode;
     struct FRAME frame;
     NODE *cnode = ruby_current_node;
-    int lambda = flags & YIELD_LAMBDA_CALL;
+    volatile int lambda = flags & YIELD_LAMBDA_CALL;
     int state;
 
     rb_need_block();
@@ -5078,56 +5205,49 @@
 
     PUSH_ITER(block->iter);
     PUSH_TAG(lambda ? PROT_NONE : PROT_YIELD);
-    if ((state = EXEC_TAG()) == 0) {
-      redo:
+    switch (state = EXEC_TAG()) {
+      case TAG_REDO:
+	state = 0;
+	CHECK_INTS;
+      case 0:
 	if (nd_type(node) == NODE_CFUNC || nd_type(node) == NODE_IFUNC) {
-	    switch (node->nd_state) {
-	      case YIELD_FUNC_LAMBDA:
-		if (!avalue) {
-		    val = (val == Qundef) ? rb_ary_new2(0) : rb_ary_new3(1, val);
-		}
-		break;
-	      case YIELD_FUNC_AVALUE:
-		if (!avalue) {
-		    val = svalue_to_avalue(val);
-		}
-		break;
-	      default:
-		if (avalue) {
-		    val = avalue_to_svalue(val);
-		}
-		if (val == Qundef && node->nd_state != YIELD_FUNC_SVALUE)
-		    val = Qnil;
+	  switch (node->nd_state) {
+	    case YIELD_FUNC_LAMBDA:
+	      if (!avalue) {
+                  val = (val == Qundef) ? rb_ary_new2(0) : rb_ary_new3(1, val);
+	      }
+	      break;
+	    case YIELD_FUNC_AVALUE:
+	      if (!avalue) {
+		  val = svalue_to_avalue(val);
+	      }
+	      break;
+	    default:
+	      if (avalue) {
+		  val = avalue_to_svalue(val);
+	      }
+	      if (val == Qundef && node->nd_state != YIELD_FUNC_SVALUE)
+		  val = Qnil;
 	    }
 	    result = (*node->nd_cfnc)(val, node->nd_tval, self);
-	}
-	else {
+	 }else
 	    result = rb_eval(self, node);
-	}
-    }
-    else {
-	switch (state) {
-	  case TAG_REDO:
-	    state = 0;
-	    CHECK_INTS;
-	    goto redo;
-	  case TAG_NEXT:
-	    if (!lambda) {
-		state = 0;
-		result = prot_tag->retval;
-	    }
-	    break;
-	  case TAG_BREAK:
-	    if (TAG_DST()) {
-		result = prot_tag->retval;
-	    }
-	    else {
-		lambda = Qtrue;	/* just pass TAG_BREAK */
-	    }
-	    break;
-	  default:
-	    break;
-	}
+          break;
+	case TAG_NEXT:
+	  if (!lambda) {
+	      state = 0;
+	      result = prot_tag->retval;
+	  }
+	  break;
+	case TAG_BREAK:
+	  if (TAG_DST()) {
+	      result = prot_tag->retval;
+	  }
+	  else {
+	      lambda = Qtrue;	/* just pass TAG_BREAK */
+	  }
+	default:
+	  break;
     }
     POP_TAG();
     POP_ITER();
@@ -5169,6 +5289,7 @@
 		    tt->retval = result;
 		    JUMP_TAG(TAG_BREAK);
 		}
+                if (tt->tag == PROT_THREAD) break;
 		tt = tt->prev;
 	    }
 	    proc_jump_error(TAG_BREAK, result);
@@ -5176,7 +5297,6 @@
 	/* fall through */
       default:
 	JUMP_TAG(state);
-	break;
     }
     ruby_current_node = cnode;
     return result;
@@ -5186,6 +5306,7 @@
 rb_yield(val)
     VALUE val;
 {
+    wipeBeforeYield();
     return rb_yield_0(val, 0, 0, 0, Qfalse);
 }
 
@@ -5234,6 +5355,7 @@
 loop_i()
 {
     for (;;) {
+        wipeBeforeYield();
 	rb_yield_0(Qundef, 0, 0, 0, Qfalse);
 	CHECK_INTS;
     }
@@ -5385,7 +5507,6 @@
 	    if (!lhs->nd_args) {
 		/* attr set */
 		ruby_current_node = lhs;
-		SET_CURRENT_SOURCE();
 		rb_call(CLASS_OF(recv), recv, lhs->nd_mid, 1, &val, scope, self);
 	    }
 	    else {
@@ -5395,7 +5516,6 @@
 		args = rb_eval(self, lhs->nd_args);
 		rb_ary_push(args, val);
 		ruby_current_node = lhs;
-		SET_CURRENT_SOURCE();
 		rb_call(CLASS_OF(recv), recv, lhs->nd_mid,
 			RARRAY(args)->len, RARRAY(args)->ptr, scope, self);
 	    }
@@ -5414,7 +5534,7 @@
     VALUE data1, data2;
 {
     int state;
-    volatile VALUE retval = Qnil;
+    VALUE retval;
     NODE *node = NEW_IFUNC(bl_proc, data2);
     VALUE self = ruby_top_self;
 
@@ -5438,12 +5558,7 @@
     POP_BLOCK();
     POP_TAG();
 
-    switch (state) {
-      case 0:
-	break;
-      default:
-	JUMP_TAG(state);
-    }
+    if (state) JUMP_TAG(state);
     return retval;
 }
 
@@ -5475,16 +5590,17 @@
 
 VALUE
 #ifdef HAVE_STDARG_PROTOTYPES
-rb_rescue2(VALUE (*b_proc)(ANYARGS), VALUE data1, VALUE (*r_proc)(ANYARGS), VALUE data2, ...)
+rb_rescue2(VALUE (* volatile b_proc)(ANYARGS), volatile VALUE data1, 
+           VALUE (* volatile r_proc)(ANYARGS), volatile VALUE data2, ...)
 #else
 rb_rescue2(b_proc, data1, r_proc, data2, va_alist)
-    VALUE (*b_proc)(ANYARGS), (*r_proc)(ANYARGS);
-    VALUE data1, data2;
+    VALUE (* volatile b_proc)(ANYARGS), (* volatile r_proc)(ANYARGS);
+    volatile VALUE data1, data2;
     va_dcl
 #endif
 {
     int state;
-    volatile VALUE result;
+    VALUE result;
     volatile VALUE e_info = ruby_errinfo;
     volatile int handle = Qfalse;
     VALUE eclass;
@@ -5543,9 +5659,9 @@
 rb_protect(proc, data, state)
     VALUE (*proc) _((VALUE));
     VALUE data;
-    int *state;
+    int * volatile state;
 {
-    VALUE result = Qnil;	/* OK */
+    VALUE result = Qnil;
     int status;
 
     PUSH_TAG(PROT_NONE);
@@ -5558,10 +5674,6 @@
     if (state) {
 	*state = status;
     }
-    if (status != 0) {
-	return Qnil;
-    }
-
     return result;
 }
 
@@ -5569,19 +5681,18 @@
 rb_ensure(b_proc, data1, e_proc, data2)
     VALUE (*b_proc)();
     VALUE data1;
-    VALUE (*e_proc)();
-    VALUE data2;
+    VALUE (* volatile e_proc)();
+    volatile VALUE data2;
 {
-    int state;
-    volatile VALUE result = Qnil;
-    VALUE retval;
+    int state;
+    VALUE result, retval;
 
     PUSH_TAG(PROT_NONE);
     if ((state = EXEC_TAG()) == 0) {
 	result = (*b_proc)(data1);
     }
     POP_TAG();
-    retval = prot_tag ? prot_tag->retval : Qnil;	/* save retval */
+    if (prot_tag) retval = prot_tag->retval;  /* save retval */
     if (!thread_no_ensure()) {
 	(*e_proc)(data2);
     }
@@ -5595,7 +5706,7 @@
     VALUE (*proc)();
     VALUE data;
 {
-    VALUE result = Qnil;	/* OK */
+    VALUE result;
     int status;
 
     DEFER_INTS;
@@ -5612,7 +5723,6 @@
     }
     ENABLE_INTS;
     if (status) JUMP_TAG(status);
-
     return result;
 }
 
@@ -5681,7 +5791,6 @@
     VALUE *argv;
     VALUE obj;
 {
-    ID id;
     VALUE exc = rb_eNoMethodError;
     const char *format = 0;
     NODE *cnode = ruby_current_node;
@@ -5692,8 +5801,6 @@
 
     stack_check();
 
-    id = SYM2ID(argv[0]);
-
     if (last_call_status & CSTAT_PRIV) {
 	format = "private method `%s' called for %s";
     }
@@ -5858,16 +5965,16 @@
 
 static VALUE
 rb_call0(klass, recv, id, oid, argc, argv, body, flags)
-    VALUE klass, recv;
-    ID    id;
+    volatile VALUE klass, recv;
+    volatile ID    id;
     ID    oid;
-    int argc;			/* OK */
-    VALUE *argv;		/* OK */
-    NODE * volatile body;
+    int argc;
+    VALUE *argv;
+    NODE *body;
     int flags;
 {
-    NODE *b2;		/* OK */
-    volatile VALUE result = Qnil;
+    NODE *b2;
+    VALUE result = Qnil;
     int itr;
     TMP_PROTECT;
     volatile int safe = -1;
@@ -5969,9 +6076,10 @@
 	    Data_Get_Struct(body->nd_cval, struct BLOCK, data);
 	    EXEC_EVENT_HOOK(RUBY_EVENT_CALL, data->body, recv, id, klass);
 	}
-	result = proc_invoke(body->nd_cval, rb_ary_new4(argc, argv), recv, klass);
+	result = proc_invoke(body->nd_cval, rb_ary_new4(argc,argv), recv,klass);
 	if (event_hooks) {
-	    EXEC_EVENT_HOOK(RUBY_EVENT_RETURN, ruby_current_node, recv, id, klass);
+	    EXEC_EVENT_HOOK(RUBY_EVENT_RETURN,
+                            ruby_current_node, recv, id, klass);
 	}
 	break;
 
@@ -5979,7 +6087,7 @@
 	{
 	    int state;
 	    VALUE *local_vars;	/* OK */
-	    NODE *saved_cref = 0;
+	    NODE * volatile saved_cref = 0;
 
 	    PUSH_SCOPE();
 	    if (body->nd_rval) {
@@ -6025,8 +6133,9 @@
 
 		    i = node->nd_cnt;
 		    if (i > argc) {
-			rb_raise(rb_eArgError, "wrong number of arguments (%d for %d)",
-				 argc, i);
+			rb_raise(rb_eArgError, 
+                                 "wrong number of arguments (%d for %d)",
+                                 argc, i);
 		    }
 		    if (!node->nd_rest) {
 			NODE *optnode = node->nd_opt;
@@ -6094,7 +6203,8 @@
 	    }
 	    POP_TAG();
 	    if (event_hooks) {
-		EXEC_EVENT_HOOK(RUBY_EVENT_RETURN, ruby_current_node, recv, id, klass);
+		EXEC_EVENT_HOOK(RUBY_EVENT_RETURN, ruby_current_node,
+                                recv, id, klass);
 	    }
 	    POP_VARS();
 	    POP_CLASS();
@@ -6108,21 +6218,18 @@
 	      case TAG_BREAK:
 	      case TAG_RETURN:
 		JUMP_TAG(state);
-		break;
 
 	      case TAG_RETRY:
 		if (rb_block_given_p()) JUMP_TAG(state);
 		/* fall through */
 	      default:
 		jump_tag_but_local_jump(state, result);
-		break;
 	    }
 	}
 	break;
 
       default:
 	unknown_node(body);
-	break;
     }
     POP_FRAME();
     POP_ITER();
@@ -6291,7 +6398,7 @@
     va_dcl
 #endif
 {
-    VALUE result = Qnil;	/* OK */
+    VALUE result;
     int status;
     va_list ar;
 
@@ -6507,12 +6614,13 @@
 
 static VALUE
 eval(self, src, scope, file, line)
-    VALUE self, src, scope;
-    const char *file;
+    VALUE self, src;
+    volatile VALUE scope;
+    const char * volatile file;
     int line;
 {
     struct BLOCK *data = NULL;
-    volatile VALUE result = Qnil;
+    VALUE result;
     struct SCOPE * volatile old_scope;
     struct BLOCK * volatile old_block;
     struct RVarmap * volatile old_dyna_vars;
@@ -6520,7 +6628,7 @@
     int volatile old_vmode;
     volatile VALUE old_wrapper;
     struct FRAME frame;
-    NODE *nodesave = ruby_current_node;
+    NODE * volatile nodesave = ruby_current_node;
     volatile int iter = ruby_frame->iter;
     volatile int safe = ruby_safe_level;
     int state;
@@ -6585,7 +6693,7 @@
 	    compile_error(0);
 	}
 	if (!NIL_P(result)) ruby_errinfo = result;
-	result = eval_node(self, node);
+	result = eval_tree(self, node);
     }
     POP_TAG();
     POP_CLASS();
@@ -6607,6 +6715,7 @@
 
 	    scope_dup(ruby_scope);
 	    for (tag=prot_tag; tag; tag=tag->prev) {
+                if (tag->tag == PROT_THREAD) break;
 		scope_dup(tag->scope);
 	    }
 	    for (vars = ruby_dyna_vars; vars; vars = vars->next) {
@@ -6718,12 +6827,13 @@
 static VALUE
 exec_under(func, under, cbase, args)
     VALUE (*func)();
-    VALUE under, cbase;
+    VALUE under;
+    volatile VALUE cbase;
     void *args;
 {
-    VALUE val = Qnil;		/* OK */
+    VALUE val;
     int state;
-    int mode;
+    volatile int mode;
     struct FRAME *f = ruby_frame;
 
     PUSH_CLASS(under);
@@ -6749,7 +6859,6 @@
     POP_FRAME();
     POP_CLASS();
     if (state) JUMP_TAG(state);
-
     return val;
 }
 
@@ -7009,9 +7118,9 @@
     volatile int prohibit_int = rb_prohibit_interrupt;
     volatile ID last_func;
     volatile VALUE wrapper = ruby_wrapper;
-    volatile VALUE self = ruby_top_self;
+    VALUE self = ruby_top_self;
     NODE *volatile last_node;
-    NODE *saved_cref = ruby_cref;
+    NODE *volatile saved_cref = ruby_cref;
 
     if (wrap && ruby_safe_level >= 4) {
 	StringValue(fname);
@@ -7061,7 +7170,7 @@
     ruby_current_node = 0;
     if (state == 0) {
 	NODE *node;
-	volatile int critical;
+        int critical;
 
 	DEFER_INTS;
 	ruby_in_eval++;
@@ -7073,7 +7182,7 @@
 	rb_thread_critical = critical;
 	ALLOW_INTS;
 	if (ruby_nerrs == 0) {
-	    eval_node(self, node);
+	    eval_tree(self, node);
 	}
     }
     ruby_frame->last_func = last_func;
@@ -7106,7 +7215,7 @@
 rb_load_protect(fname, wrap, state)
     VALUE fname;
     int wrap;
-    int *state;
+    int * volatile state;
 {
     int status;
 
@@ -7175,16 +7284,8 @@
 {
     VALUE v;
     const char *f, *e, *feature = *ftptr;
-    long i, len, elen;
+    long i, len = ext ? ext - feature : strlen(feature);
 
-    if (ext) {
-	len = ext - feature;
-	elen = strlen(ext);
-    }
-    else {
-	len = strlen(feature);
-	elen = 0;
-    }
     for (i = 0; i < RARRAY_LEN(rb_features); ++i) {
 	v = RARRAY_PTR(rb_features)[i];
 	f = StringValuePtr(v);
@@ -7264,6 +7365,9 @@
     rb_provide_feature(rb_str_new2(feature));
 }
 
+static int rb_thread_join0 _((rb_thread_t, double));
+int rb_thread_join _((VALUE, double));
+
 static char *
 load_lock(ftptr)
     const char *ftptr;
@@ -8135,7 +8239,7 @@
 void
 rb_exec_end_proc()
 {
-    struct end_proc_data *link, *tmp;
+    struct end_proc_data *tmp, *volatile link;
     int status;
     volatile int safe = ruby_safe_level;
 
@@ -8209,6 +8313,17 @@
     }
 }
 
+/* Hash (Thread => Backtrace) used to collect backtrace for each threads. */
+static VALUE backtrace_for_each_thread;
+
+static int backtrace_level_for_each_thread;
+
+static VALUE
+switch_thread_context_to_collect_backtrace(rb_thread_t next);
+
+static VALUE
+rb_f_caller_for_all_threads();
+
 void
 Init_eval()
 {
@@ -8254,6 +8369,7 @@
     rb_define_global_function("fail", rb_f_raise, -1);
 
     rb_define_global_function("caller", rb_f_caller, -1);
+    rb_define_global_function("caller_for_all_threads", rb_f_caller_for_all_threads, -1);
 
     rb_define_global_function("exit", rb_f_exit, -1);
     rb_define_global_function("abort", rb_f_abort, -1);
@@ -8858,8 +8974,9 @@
     int state;
     volatile int safe = ruby_safe_level;
     volatile VALUE old_wrapper = ruby_wrapper;
-    volatile int pcall, avalue = Qtrue;
-    volatile VALUE tmp = args;
+    volatile int pcall;
+    int avalue = Qtrue;
+    VALUE tmp = args;
     VALUE bvar = Qnil;
 
     if (rb_block_given_p() && ruby_frame->last_func) {
@@ -8921,7 +9038,7 @@
       case TAG_RETRY:
 	proc_jump_error(TAG_RETRY, Qnil); /* xxx */
 	JUMP_TAG(state);
-	break;
+
       case TAG_NEXT:
       case TAG_BREAK:
 	if (!pcall && result != Qundef) {
@@ -9165,15 +9282,15 @@
 
 static VALUE
 block_pass(self, node)
-    VALUE self;
-    NODE *node;
+    volatile VALUE self;
+    NODE *volatile node;
 {
-    VALUE proc = rb_eval(self, node->nd_body);	/* OK */
+    volatile VALUE proc = rb_eval(self, node->nd_body);
     VALUE b;
     struct BLOCK * volatile old_block;
     struct BLOCK _block;
     struct BLOCK *data;
-    volatile VALUE result = Qnil;
+    VALUE result;
     int state;
     volatile int orphan;
     volatile int safe = ruby_safe_level;
@@ -9220,20 +9337,24 @@
 
     PUSH_TAG(PROT_LOOP);
     state = EXEC_TAG();
-    if (state == 0) {
-      retry:
+    switch (state) {
+      case TAG_RETRY:
+        state = 0;
+      case 0:
 	proc_set_safe_level(proc);
 	if (safe > ruby_safe_level)
 	    ruby_safe_level = safe;
 	result = rb_eval(self, node->nd_iter);
-    }
-    else if (state == TAG_BREAK && TAG_DST()) {
-	result = prot_tag->retval;
-	state = 0;
-    }
-    else if (state == TAG_RETRY) {
-	state = 0;
-	goto retry;
+        break;
+      case TAG_BREAK:
+        result = Qnil;
+        if (TAG_DST()) {
+	  result = prot_tag->retval;
+	  state = 0;
+        }
+        break;
+      default:
+        result = Qnil;
     }
     POP_TAG();
     POP_ITER();
@@ -9250,7 +9371,6 @@
       default:
 	JUMP_TAG(state);
     }
-
     return result;
 }
 
@@ -9584,7 +9704,7 @@
     VALUE *argv;
     VALUE method;
 {
-    VALUE result = Qnil;	/* OK */
+    VALUE result;
     struct METHOD *data;
     int safe;
 
@@ -9879,12 +9999,9 @@
 bmcall(args, method)
     VALUE args, method;
 {
-    volatile VALUE a;
-    VALUE ret;
-
-    a = svalue_to_avalue(args);
-    ret = method_call(RARRAY(a)->len, RARRAY(a)->ptr, method);
-    a = Qnil; /* prevent tail call */
+    VALUE a = svalue_to_avalue(args);
+    VALUE ret = method_call(RARRAY(a)->len, RARRAY(a)->ptr, method);
+    RB_GC_GUARD(a);  /* ensure a is not GC'd during method_call */
     return ret;
 }
 
@@ -10001,6 +10118,7 @@
 	rb_raise(rb_eArgError, "wrong number of arguments (%d for 1)", argc);
     }
     orig = body;
+    SET_METHOD_SOURCE();
     if (RDATA(body)->dmark == (RUBY_DATA_FUNC)bm_mark) {
 	node = NEW_DMETHOD(method_unbind(body));
     }
@@ -10032,6 +10150,111 @@
     return orig;
 }
 
+
+#ifdef MBARI_API
+/*
+ * call-seq:
+ *    meth.__file__  => String  
+ *
+ * returns the filename containing this method's definition
+ *
+ * raises ArgumentError if method has no associated ruby source code
+ *
+ * <i>Only available when MBARI_API extentions are enabled at build time</i>
+ */
+ 
+static VALUE
+method_source_file_name(VALUE method)
+{
+    struct METHOD *data;
+    NODE *node;
+
+    Data_Get_Struct(method, struct METHOD, data);   
+    if ((node = data->body)) {
+      const char *filename = node->nd_file;
+      if (filename)
+        return rb_str_new2(filename);
+    }
+    rb_raise(rb_eArgError, "native Method");
+}
+
+/*
+ * call-seq:
+ *    meth.__line__  => Fixnum  
+ *
+ * returns the starting line number of this method
+ *
+ * raises ArgumentError if method has no associated ruby source code
+ *
+ * <i>Only available when MBARI_API extentions are enabled at build time</i>
+ */
+ 
+static VALUE
+method_source_line(VALUE method)
+{
+    struct METHOD *data;
+    NODE *node;
+
+    Data_Get_Struct(method, struct METHOD, data);
+    if ((node = data->body)) {
+      int lineno = nd_line(node);
+      if (lineno)
+        return INT2FIX(nd_line(node));
+    }
+    rb_raise(rb_eArgError, "native Method");
+}
+
+
+/*
+ * call-seq:
+ *    prc.__file__  => String  
+ *
+ * returns the filename where this proc is defined
+ *
+ * raises ArgumentError if proc has no associated ruby source
+ *
+ * <i>Only available when MBARI_API extentions are enabled at build time</i>
+ */
+ 
+static VALUE
+proc_source_file_name(VALUE block)
+{
+    struct BLOCK *data;
+    NODE *node;
+
+    Data_Get_Struct(block, struct BLOCK, data);
+    if ((node = data->frame.node) || (node = data->body))
+      return rb_str_new2(node->nd_file);
+    rb_raise(rb_eArgError, "native Proc");
+}
+
+
+/*
+ * call-seq:
+ *    prc.__line__  => Fixnum  
+ *
+ * returns the starting line number of this proc
+ *
+ * raises ArgumentError if proc has no associated ruby source code
+ *
+ * <i>Only available when MBARI_API extentions are enabled at build time</i>
+ */
+ 
+static VALUE
+proc_source_line(VALUE block)
+{
+    struct BLOCK *data;
+    NODE *node;
+    
+    Data_Get_Struct(block, struct BLOCK, data);
+    if ((node = data->frame.node) || (node = data->body))
+      return INT2FIX( nd_line(node) );
+    rb_raise(rb_eArgError, "native Proc");
+}
+
+#endif  /* MBARI_API */
+
+
 /*
  *  <code>Proc</code> objects are blocks of code that have been bound to
  *  a set of local variables. Once bound, the code may be called in
@@ -10116,6 +10339,15 @@
     rb_define_method(rb_cUnboundMethod, "owner", method_owner, 0);
     rb_define_method(rb_cUnboundMethod, "bind", umethod_bind, 1);
     rb_define_method(rb_cModule, "instance_method", rb_mod_method, 1);
+    
+#ifdef MBARI_API
+    rb_define_method(rb_cUnboundMethod, "__file__", method_source_file_name, 0);
+    rb_define_method(rb_cUnboundMethod, "__line__", method_source_line, 0);
+    rb_define_method(rb_cProc, "__file__", proc_source_file_name, 0);
+    rb_define_method(rb_cProc, "__line__", proc_source_line, 0);
+    rb_define_method(rb_cMethod, "__file__", method_source_file_name, 0);
+    rb_define_method(rb_cMethod, "__line__", method_source_line, 0);
+#endif
 }
 
 /*
@@ -10441,14 +10673,19 @@
     return (double)tv.tv_sec + (double)tv.tv_usec * 1e-6;
 }
 
-#define STACK(addr) (th->stk_pos<(VALUE*)(addr) && (VALUE*)(addr)<th->stk_pos+th->stk_len)
-#define ADJ(addr) (void*)(STACK(addr)?(((VALUE*)(addr)-th->stk_pos)+th->stk_ptr):(VALUE*)(addr))
+
+#define ADJ(addr) \
+   if ((size_t)((void *)addr - stkBase) < stkSize) addr=(void *)addr + stkShift
+
 static void
 thread_mark(th)
     rb_thread_t th;
 {
     struct FRAME *frame;
     struct BLOCK *block;
+    void *stkBase;
+    ptrdiff_t stkShift;
+    size_t stkSize;
 
     rb_gc_mark(th->result);
     rb_gc_mark(th->thread);
@@ -10483,15 +10720,26 @@
 	}
 #endif
     }
+
+    stkBase = (void *)th->stk_start;
+    stkSize = th->stk_len * sizeof(VALUE);
+#if STACK_GROW_DIRECTION == 0
+    if (rb_gc_stack_grow_direction < 0)
+#endif
+#if STACK_GROW_DIRECTION <= 0
+      stkBase -= stkSize;
+#endif
+    stkShift = (void *)th->stk_ptr - stkBase;
+    
     frame = th->frame;
     while (frame && frame != top_frame) {
-	frame = ADJ(frame);
+	ADJ(frame);
 	rb_gc_mark_frame(frame);
 	if (frame->tmp) {
 	    struct FRAME *tmp = frame->tmp;
 
 	    while (tmp && tmp != top_frame) {
-		tmp = ADJ(tmp);
+		ADJ(tmp);
 		rb_gc_mark_frame(tmp);
 		tmp = tmp->prev;
 	    }
@@ -10500,7 +10748,7 @@
     }
     block = th->block;
     while (block) {
-	block = ADJ(block);
+	ADJ(block);
 	rb_gc_mark_frame(&block->frame);
 	block = block->prev;
     }
@@ -10551,7 +10799,7 @@
         return;
 
     FOREACH_THREAD_FROM(main_thread, th) {
-	if (FL_TEST(th->thread, FL_MARK)) continue;
+	if (rb_gc_is_thread_marked(th->thread)) continue;
 	if (th->status == THREAD_STOPPED) {
 	    th->status = THREAD_TO_KILL;
 	    rb_gc_mark(th->thread);
@@ -10559,15 +10807,20 @@
     } END_FOREACH_FROM(main_thread, th);
 }
 
+
 static inline void
 stack_free(th)
     rb_thread_t th;
 {
-    if (th->stk_ptr) free(th->stk_ptr);
-    th->stk_ptr = 0;
+    if (th->stk_ptr) {
+      free(th->stk_ptr);
+      th->stk_ptr = 0;
+    }
 #ifdef __ia64
-    if (th->bstr_ptr) free(th->bstr_ptr);
-    th->bstr_ptr = 0;
+    if (th->bstr_ptr) {
+      free(th->bstr_ptr);
+      th->bstr_ptr = 0;
+    }
 #endif
 }
 
@@ -10584,6 +10837,8 @@
     if (th != main_thread) free(th);
 }
 
+#define THREAD_DATA(threadObject)  ((rb_thread_t)RDATA(threadObject)->data)
+
 static rb_thread_t
 rb_thread_check(data)
     VALUE data;
@@ -10592,7 +10847,7 @@
 	rb_raise(rb_eTypeError, "wrong argument type %s (expected Thread)",
 		 rb_obj_classname(data));
     }
-    return (rb_thread_t)RDATA(data)->data;
+    return THREAD_DATA(data);
 }
 
 static VALUE rb_thread_raise _((int, VALUE*, rb_thread_t));
@@ -10609,6 +10864,7 @@
 #define RESTORE_RAISE		5
 #define RESTORE_SIGNAL		6
 #define RESTORE_EXIT		7
+#define RESTORE_BACKTRACE	8
 
 extern VALUE *rb_gc_stack_start;
 #ifdef __ia64
@@ -10619,13 +10875,10 @@
 rb_thread_save_context(th)
     rb_thread_t th;
 {
-    VALUE *pos;
     size_t len;
     static VALUE tval;
 
-    len = ruby_stack_length(&pos);
-    th->stk_len = 0;
-    th->stk_pos = pos;
+    len = ruby_stack_length(th->stk_start,&th->stk_pos);
     if (len > th->stk_max) {
 	VALUE *ptr = realloc(th->stk_ptr, sizeof(VALUE) * len);
 	if (!ptr) rb_memerror();
@@ -10686,13 +10939,16 @@
 rb_thread_switch(n)
     int n;
 {
+#if STACK_WIPE_SITES & 1
+    rb_gc_wipe_stack();
+#endif
     rb_trap_immediate = (curr_thread->flags&0x100)?1:0;
     switch (n) {
       case 0:
 	return 0;
       case RESTORE_FATAL:
 	JUMP_TAG(TAG_FATAL);
-	break;
+
       case RESTORE_INTERRUPT:
 	rb_interrupt();
 	break;
@@ -10715,6 +10971,15 @@
 	}
 	rb_exc_raise(th_raise_exception);
 	break;
+      case RESTORE_BACKTRACE:
+        rb_hash_aset(backtrace_for_each_thread, curr_thread->thread, 
+                     backtrace(backtrace_level_for_each_thread));
+        if (curr_thread != main_thread) {
+            switch_thread_context_to_collect_backtrace(curr_thread->next);
+        } else { 
+	        /* Circled back to main thread, cycle is complete. */
+        }
+        break;
       case RESTORE_NORMAL:
       default:
 	break;
@@ -10722,8 +10987,8 @@
     return 1;
 }
 
-#define THREAD_SAVE_CONTEXT(th) \
-    (rb_thread_switch(ruby_setjmp(rb_thread_save_context(th), (th)->context)))
+#define THREAD_SAVE_CONTEXT(th) (rb_thread_switch( wipeAfter(\
+                  ruby_setjmp(rb_thread_save_context(th), (th)->context))))
 
 NORETURN(static void rb_thread_restore_context _((rb_thread_t,int)));
 NORETURN(NOINLINE(static void rb_thread_restore_context_0(rb_thread_t,int)));
@@ -10814,8 +11079,8 @@
 stack_extend(rb_thread_t th, int exit)
 {
 #define STACK_PAD_SIZE 1024
-    volatile VALUE space[STACK_PAD_SIZE], *sp = space;
-
+	volatile VALUE space[STACK_PAD_SIZE];
+ 
 #if !STACK_GROW_DIRECTION
     if (space < rb_gc_stack_start) {
         /* Stack grows downward */
@@ -10823,8 +11088,8 @@
 #if STACK_GROW_DIRECTION <= 0
 	if (space > th->stk_pos) {
 # ifdef HAVE_ALLOCA
-	    sp = ALLOCA_N(VALUE, &space[0] - th->stk_pos);
-	    space[0] = *sp;
+			(void)(volatile void *)
+	    ALLOCA_N(VALUE, &space[0] - th->stk_pos);
 # else
 	    stack_extend(th, exit);
 # endif
@@ -10838,8 +11103,8 @@
 #if STACK_GROW_DIRECTION >= 0
 	if (&space[STACK_PAD_SIZE] < th->stk_pos + th->stk_len) {
 # ifdef HAVE_ALLOCA
-	    sp = ALLOCA_N(VALUE, th->stk_pos + th->stk_len - &space[STACK_PAD_SIZE]);
-	    space[0] = *sp;
+			(void)(volatile void *)
+	    ALLOCA_N(VALUE, th->stk_pos + th->stk_len - &space[STACK_PAD_SIZE]);
 # else
 	    stack_extend(th, exit);
 # endif
@@ -10959,14 +11224,11 @@
     fd_set *dst, *src;
     int max;
 {
-    int n = 0;
     int i;
 
     for (i=0; i<=max; i++) {
-	if (FD_ISSET(i, src)) {
-	    n = i;
+	if (FD_ISSET(i, src))
 	    FD_SET(i, dst);
-	}
     }
 }
 
@@ -11523,9 +11785,6 @@
     return curr_thread->select_value;
 }
 
-static int rb_thread_join0 _((rb_thread_t, double));
-int rb_thread_join _((VALUE, double));
-
 static int
 rb_thread_join0(th, limit)
     rb_thread_t th;
@@ -11588,7 +11847,6 @@
     th->join = jth;
 }
 
-
 /*
  *  call-seq:
  *     thr.join          => thr
@@ -11640,8 +11898,8 @@
 
     rb_scan_args(argc, argv, "01", &limit);
     if (!NIL_P(limit)) delay = rb_num2dbl(limit);
-    if (!rb_thread_join0(rb_thread_check(thread), delay))
-	return Qnil;
+    if (!rb_thread_join0(THREAD_DATA(thread), delay))
+      return Qnil;
     return thread;
 }
 
@@ -11847,7 +12105,7 @@
 rb_thread_kill_bang(thread)
     VALUE thread;
 {
-    rb_thread_t th = rb_thread_check(thread);
+    rb_thread_t th = THREAD_DATA(thread);
     rb_kill_thread(th, THREAD_NO_ENSURE);
     return thread;
 }
@@ -12019,7 +12277,7 @@
 rb_thread_priority(thread)
     VALUE thread;
 {
-    return INT2NUM(rb_thread_check(thread)->priority);
+    return INT2NUM(THREAD_DATA(thread)->priority);
 }
 
 
@@ -12053,7 +12311,7 @@
     rb_thread_t th;
 
     rb_secure(4);
-    th = rb_thread_check(thread);
+    th = THREAD_DATA(thread);
 
     th->priority = NUM2INT(prio);
     rb_thread_schedule();
@@ -12079,7 +12337,7 @@
 {
     rb_thread_t th;
 
-    th = rb_thread_check(thread);
+    th = THREAD_DATA(thread);
     if (th == curr_thread) {
 	return INT2NUM(ruby_safe_level);
     }
@@ -12156,7 +12414,7 @@
 rb_thread_abort_exc(thread)
     VALUE thread;
 {
-    return rb_thread_check(thread)->abort?Qtrue:Qfalse;
+    return THREAD_DATA(thread)->abort?Qtrue:Qfalse;
 }
 
 
@@ -12174,7 +12432,7 @@
     VALUE thread, val;
 {
     rb_secure(4);
-    rb_thread_check(thread)->abort = RTEST(val);
+    THREAD_DATA(thread)->abort = RTEST(val);
     return val;
 }
 
@@ -12216,6 +12474,7 @@
     th->result = 0;\
     th->flags = 0;\
 \
+    th->stk_start = rb_gc_stack_start;\
     th->stk_ptr = 0;\
     th->stk_len = 0;\
     th->stk_max = 0;\
@@ -12462,6 +12721,15 @@
 		 "can't start a new thread (frozen ThreadGroup)");
     }
 
+    th->stk_start =   /* establish start of new thread's stack */
+#if STACK_GROW_DIRECTION > 0
+      (VALUE *)ruby_frame;
+#elif STACK_GROW_DIRECTION < 0
+      (VALUE *)(ruby_frame+1);
+#else
+      (VALUE *)(ruby_frame+((VALUE *)(&arg)<rb_gc_stack_start))
+#endif
+ 
     if (THREAD_SAVE_CONTEXT(curr_thread)) {
 	return thread;
     }
@@ -12489,6 +12757,8 @@
     PUSH_TAG(PROT_THREAD);
     if ((state = EXEC_TAG()) == 0) {
 	if (THREAD_SAVE_CONTEXT(th) == 0) {
+            ruby_frame->prev = top_frame;     /* hide parent thread's frames */
+            ruby_frame->tmp = 0;           
 	    curr_thread = th;
 	    th->result = (*fn)(arg, th);
 	}
@@ -12600,9 +12870,6 @@
     VALUE klass;
 {
     rb_thread_t th = rb_thread_alloc(klass);
-    volatile VALUE *pos;
-
-    pos = th->stk_pos;
     rb_obj_call_init(th->thread, argc, argv);
     if (th->stk_pos == 0) {
 	rb_raise(rb_eThreadError, "uninitialized thread - check `%s#initialize'",
@@ -12640,7 +12907,7 @@
     if (!rb_block_given_p()) {
 	rb_raise(rb_eThreadError, "must be called with a block");
     }
-    th = rb_thread_check(thread);
+    th = THREAD_DATA(thread);
     if (th->stk_max) {
 	NODE *node = th->node;
 	if (!node) {
@@ -12689,7 +12956,7 @@
 rb_thread_value(thread)
     VALUE thread;
 {
-    rb_thread_t th = rb_thread_check(thread);
+    rb_thread_t th = THREAD_DATA(thread);
 
     while (!rb_thread_join0(th, DELAY_INFTY));
 
@@ -12724,7 +12991,7 @@
 rb_thread_status(thread)
     VALUE thread;
 {
-    rb_thread_t th = rb_thread_check(thread);
+    rb_thread_t th = THREAD_DATA(thread);
 
     if (rb_thread_dead(th)) {
 	if (!NIL_P(th->errinfo) && (th->flags & RAISED_EXCEPTION))
@@ -12775,7 +13042,7 @@
 rb_thread_stop_p(thread)
     VALUE thread;
 {
-    rb_thread_t th = rb_thread_check(thread);
+    rb_thread_t th = THREAD_DATA(thread);
 
     if (rb_thread_dead(th)) return Qtrue;
     if (th->status == THREAD_STOPPED) return Qtrue;
@@ -13009,7 +13276,7 @@
     VALUE *argv;
     VALUE thread;
 {
-    rb_thread_t th = rb_thread_check(thread);
+    rb_thread_t th = THREAD_DATA(thread);
 
     if (ruby_safe_level > th->safe) {
 	rb_secure(4);
@@ -13125,7 +13392,7 @@
 rb_thread_key_p(thread, id)
     VALUE thread, id;
 {
-    rb_thread_t th = rb_thread_check(thread);
+    rb_thread_t th = THREAD_DATA(thread);
 
     if (!th->locals) return Qfalse;
     if (st_lookup(th->locals, rb_to_id(id), 0))
@@ -13161,7 +13428,7 @@
 rb_thread_keys(thread)
     VALUE thread;
 {
-    rb_thread_t th = rb_thread_check(thread);
+    rb_thread_t th = THREAD_DATA(thread);
     VALUE ary = rb_ary_new();
 
     if (th->locals) {
@@ -13182,7 +13449,7 @@
     VALUE thread;
 {
     const char *cname = rb_obj_classname(thread);
-    rb_thread_t th = rb_thread_check(thread);
+    rb_thread_t th = THREAD_DATA(thread);
     const char *status = thread_status_name(th->status);
     VALUE str;
     size_t len = strlen(cname)+7+16+9+1;
@@ -13220,10 +13487,10 @@
     rb_thread_t cc;
 {
     /* free continuation's stack if it has just died */
-    if (NIL_P(cc->thread)) return;
-    if (rb_thread_check(cc->thread)->status == THREAD_KILLED) {
-	cc->thread = Qnil;
-	rb_thread_die(cc);  /* can't possibly activate this stack */
+    if (!NIL_P(cc->thread) &&
+        THREAD_DATA(cc->thread)->status == THREAD_KILLED) {
+	  cc->thread = Qnil;
+	  rb_thread_die(cc);  /* can't possibly activate this stack */
     }
 }
 
@@ -13236,16 +13503,6 @@
     thread_mark(cc);
 }
 
-static rb_thread_t
-rb_cont_check(data)
-    VALUE data;
-{
-    if (TYPE(data) != T_DATA || RDATA(data)->dmark != (RUBY_DATA_FUNC)cc_mark) {
-	rb_raise(rb_eTypeError, "wrong argument type %s (expected Continuation)",
-		 rb_obj_classname(data));
-    }
-    return (rb_thread_t)RDATA(data)->data;
-}
 
 /*
  *  Document-class: Continuation
@@ -13296,6 +13553,32 @@
 
 VALUE rb_cCont;
 
+
+static rb_thread_t prep4callcc(void)
+{
+  rb_thread_t th;
+  struct tag *tag;
+  struct RVarmap *vars;
+
+  THREAD_ALLOC(th);
+  /* must finish th initialization before any possible gc */
+  th->thread = curr_thread->thread;    /* brent@mbari.org */
+  th->thgroup = cont_protect;
+
+  scope_dup(ruby_scope);
+  for (tag=prot_tag; tag; tag=tag->prev) {
+      if (tag->tag == PROT_THREAD) break;
+      scope_dup(tag->scope);
+  }
+
+  for (vars = ruby_dyna_vars; vars; vars = vars->next) {
+      if (FL_TEST(vars, DVAR_DONT_RECYCLE)) break;
+      FL_SET(vars, DVAR_DONT_RECYCLE);
+  }
+  return th;
+}
+
+
 /*
  *  call-seq:
  *     callcc {|cont| block }   =>  obj
@@ -13314,37 +13597,14 @@
 rb_callcc(self)
     VALUE self;
 {
-    volatile VALUE cont;
-    rb_thread_t th;
-    volatile rb_thread_t th_save;
-    struct tag *tag;
-    struct RVarmap *vars;
-
-    THREAD_ALLOC(th);
-    /* must finish th initialization before any possible gc.
-     * brent@mbari.org */
-    th->thread = curr_thread->thread;
-    th->thgroup = cont_protect;
-    cont = Data_Wrap_Struct(rb_cCont, cc_mark, thread_free, th);
-
-    scope_dup(ruby_scope);
-    for (tag=prot_tag; tag; tag=tag->prev) {
-	scope_dup(tag->scope);
-    }
-
-    for (vars = ruby_dyna_vars; vars; vars = vars->next) {
-	if (FL_TEST(vars, DVAR_DONT_RECYCLE)) break;
-	FL_SET(vars, DVAR_DONT_RECYCLE);
-    }
-    th_save = th;
-    if (THREAD_SAVE_CONTEXT(th)) {
-	return th_save->result;
-    }
-    else {
-	return rb_yield(cont);
-    }
+    volatile rb_thread_t th = prep4callcc();
+    return THREAD_SAVE_CONTEXT(th) ?
+      th->result
+          :
+      rb_yield(Data_Wrap_Struct(rb_cCont, cc_mark, thread_free, th));
 }
 
+
 /*
  *  call-seq:
  *     cont.call(args, ...) 
@@ -13367,7 +13627,7 @@
     VALUE *argv;
     VALUE cont;
 {
-    rb_thread_t th = rb_cont_check(cont);
+    rb_thread_t th = THREAD_DATA(cont);
 
     if (th->thread != curr_thread->thread) {
 	rb_raise(rb_eRuntimeError, "continuation called across threads");
@@ -13397,6 +13657,35 @@
 };
 
 
+#ifdef MBARI_API
+/*
+ *  call-seq:
+ *     cont.thread
+ *  
+ *  Returns the thread on which this continuation can be called
+ *  or nil if that thread has died
+ *
+ *     t = Thread.new {callcc{|c| $x=c}; sleep 5}
+ *     sleep 1
+ *     $x.thread                             #=> t
+ *     sleep 10
+ *     $x.thread                             #=> nil
+ *
+ *  <i>Only available when MBARI_API extentions are enabled at build time</i>
+ */
+static VALUE
+rb_cont_thread(cont)
+  VALUE cont;
+{
+  rb_thread_t th = THREAD_DATA(cont);
+  cc_purge(th);
+  return th->thread;
+}
+#endif
+
+
+
+
 /*
  * Document-class: ThreadGroup
  *
@@ -13649,8 +13938,9 @@
     VALUE obj;
     VALUE arg;
 {
-    VALUE hash = rb_thread_local_aref(rb_thread_current(), recursive_key);
-    VALUE objid = rb_obj_id(obj);
+    volatile VALUE hash = 
+      rb_thread_local_aref(rb_thread_current(), recursive_key);
+    volatile VALUE objid = rb_obj_id(obj);
 
     if (recursive_check(hash, objid)) {
 	return (*func) (obj, arg, Qtrue);
@@ -13746,6 +14036,9 @@
     rb_undef_method(CLASS_OF(rb_cCont), "new");
     rb_define_method(rb_cCont, "call", rb_cont_call, -1);
     rb_define_method(rb_cCont, "[]", rb_cont_call, -1);
+#ifdef MBARI_API
+    rb_define_method(rb_cCont, "thread", rb_cont_thread, 0);
+#endif
     rb_define_global_function("callcc", rb_callcc, 0);
     rb_global_variable(&cont_protect);
 
@@ -13797,14 +14090,15 @@
 
 static VALUE
 rb_f_catch(dmy, tag)
-    VALUE dmy, tag;
+    VALUE dmy;
+    volatile VALUE tag;
 {
     int state;
-    VALUE val = Qnil;		/* OK */
+    VALUE val;
 
     tag = ID2SYM(rb_to_id(tag));
     PUSH_TAG(tag);
-    if ((state = EXEC_TAG()) == 0) {
+    if ((state = wipeAfter(EXEC_TAG_0())) == 0) {
 	val = rb_yield_0(tag, 0, 0, 0, Qfalse);
     }
     else if (state == TAG_THROW && tag == prot_tag->dst) {
@@ -13813,7 +14107,6 @@
     }
     POP_TAG();
     if (state) JUMP_TAG(state);
-
     return val;
 }
 
@@ -13872,6 +14165,9 @@
     if (!tt) {
 	rb_name_error(SYM2ID(tag), "uncaught throw `%s'", rb_id2name(SYM2ID(tag)));
     }
+#if STACK_WIPE_SITES & 0x800
+    rb_gc_update_stack_extent();
+#endif
     rb_trap_restore_mask();
     JUMP_TAG(TAG_THROW);
 #ifndef __GNUC__
@@ -13890,3 +14186,74 @@
     argv[1] = val;
     rb_f_throw(2, argv);
 }
+
+static VALUE
+switch_thread_context_to_collect_backtrace(rb_thread_t next)
+{
+    if (THREAD_SAVE_CONTEXT(curr_thread)) {
+        return Qnil;
+    }
+    curr_thread = next;
+    rb_thread_restore_context(next, RESTORE_BACKTRACE);
+    return Qnil;
+}
+
+
+/*
+ *  call-seq:
+ *     caller_for_all_threads(start=1)    => array
+ *  
+ *  Returns the current execution stack for all threads 
+ *  ---a hash whose keys are thread instances and values
+ *  the thread caller backtrace.
+ *
+ *  Backtraces are array of hashes indicating location on the 
+ *  stack. Hash keys include ``<em>:line</em>'' or ``<em>:file</em>''
+ *  and ``<em>:method'</em>''. 
+ *
+ *  The optional _start_ parameter
+ *  determines the number of initial stack entries to omit from the
+ *  result.
+ *     
+ *     def a(skip)
+ *       caller_for_all_threads(skip)
+ *     end
+ *     def b(skip)
+ *       a(skip)
+ *     end
+ *     def c(skip)
+ *       b(skip)
+ *     end
+ *     c(0)   #=> ["prog:2:in `a'", "prog:5:in `b'", "prog:8:in `c'", "prog:10"]
+ *     c(1)   #=> ["prog:5:in `b'", "prog:8:in `c'", "prog:11"]
+ *     c(2)   #=> ["prog:8:in `c'", "prog:12"]
+ *     c(3)   #=> ["prog:13"]
+ */
+static VALUE
+rb_f_caller_for_all_threads(argc, argv)
+    int argc;
+    VALUE *argv;
+{
+    volatile int critical;
+    VALUE level;
+	VALUE result;
+
+    rb_scan_args(argc, argv, "01", &level);
+    backtrace_level_for_each_thread = NIL_P(level) ? 0 : NUM2INT(level);
+	if (backtrace_level_for_each_thread < 0) {
+		rb_raise(rb_eArgError, "negative level (%d)", backtrace_level_for_each_thread);
+	}
+
+	critical = rb_thread_critical;
+	rb_thread_critical = Qtrue;
+
+    backtrace_for_each_thread = rb_hash_new();
+    switch_thread_context_to_collect_backtrace(main_thread->next);
+
+	result = backtrace_for_each_thread;
+	backtrace_for_each_thread = Qnil;
+	backtrace_for_each_thread = 0;
+		
+	rb_thread_critical = critical;
+    return result;
+}
--- a/ext/Setup
+++ b/ext/Setup
@@ -20,6 +20,7 @@
 #pty
 #openssl
 #racc/cparse
+#rational
 #readline
 #sdbm
 #socket
--- a/ext/Setup.atheos
+++ b/ext/Setup.atheos
@@ -20,6 +20,7 @@
 pty
 #openssl
 racc/parse
+rational
 readline
 sdbm
 socket
--- a/ext/Setup.dj
+++ b/ext/Setup.dj
@@ -20,6 +20,7 @@
 #pty
 #openssl
 racc/cparse
+rational
 readline
 sdbm
 #socket
--- a/ext/Setup.emx
+++ b/ext/Setup.emx
@@ -20,6 +20,7 @@
 #pty
 #openssl
 racc/cparse
+rational
 #readline
 #sdbm
 socket
--- a/ext/Setup.nt
+++ b/ext/Setup.nt
@@ -20,6 +20,7 @@
 #pty
 #openssl
 racc/cparse
+rational
 #readline
 sdbm
 socket
--- a/ext/Setup.x68
+++ b/ext/Setup.x68
@@ -20,6 +20,7 @@
 #pty
 #openssl
 racc/cparse
+rational
 #readline
 #sdbm
 #socket
--- a/ext/openssl/ossl_ssl.c
+++ b/ext/openssl/ossl_ssl.c
@@ -1205,7 +1205,7 @@
     num = sk_X509_num(chain);
     ary = rb_ary_new2(num);
     for (i = 0; i < num; i++){
-	cert = sk_X509_value(chain, i);
+	cert = (X509*)sk_X509_value(chain, i);
 	rb_ary_push(ary, ossl_x509_new(cert));
     }
 
--- /dev/null
+++ b/ext/rational/extconf.rb
@@ -0,0 +1,3 @@
+require 'mkmf'
+
+create_makefile('rational')
--- /dev/null
+++ b/ext/rational/lib/rational.rb
@@ -0,0 +1,560 @@
+#
+#   rational.rb -
+#       $Release Version: 0.5 $
+#       $Revision: 1.7 $
+#       $Date: 1999/08/24 12:49:28 $
+#       by Keiju ISHITSUKA(SHL Japan Inc.)
+#
+# Documentation by Kevin Jackson and Gavin Sinclair.
+# 
+# Performance improvements by Kurt Stephens.
+#
+# When you <tt>require 'rational'</tt>, all interactions between numbers
+# potentially return a rational result.  For example:
+#
+#   1.quo(2)              # -> 0.5
+#   require 'rational'
+#   1.quo(2)              # -> Rational(1,2)
+# 
+# See Rational for full documentation.
+#
+
+# Pull in some optimization
+require "rational.so"
+
+#
+# Creates a Rational number (i.e. a fraction).  +a+ and +b+ should be Integers:
+# 
+#   Rational(1,3)           # -> 1/3
+#
+# Note: trying to construct a Rational with floating point or real values
+# produces errors:
+#
+#   Rational(1.1, 2.3)      # -> NoMethodError
+#
+def Rational(a, b = 1)
+  if a.kind_of?(Rational) && b == 1
+    a
+  else
+    Rational.reduce(a, b)
+  end
+end
+
+#
+# Rational implements a rational class for numbers.
+#
+# <em>A rational number is a number that can be expressed as a fraction p/q
+# where p and q are integers and q != 0.  A rational number p/q is said to have
+# numerator p and denominator q.  Numbers that are not rational are called
+# irrational numbers.</em> (http://mathworld.wolfram.com/RationalNumber.html)
+#
+# To create a Rational Number:
+#   Rational(a,b)             # -> a/b
+#   Rational.new!(a,b)        # -> a/b
+#
+# Examples:
+#   Rational(5,6)             # -> 5/6
+#   Rational(5)               # -> 5/1
+# 
+# Rational numbers are reduced to their lowest terms:
+#   Rational(6,10)            # -> 3/5
+#
+# But not if you use the unusual method "new!":
+#   Rational.new!(6,10)       # -> 6/10
+#
+# Division by zero is obviously not allowed:
+#   Rational(3,0)             # -> ZeroDivisionError
+#
+class Rational < Numeric
+  @RCS_ID='-$Id: rational.rb,v 1.7 1999/08/24 12:49:28 keiju Exp keiju $-'
+
+  #
+  # Reduces the given numerator and denominator to their lowest terms.  Use
+  # Rational() instead.
+  #
+  def Rational.reduce(num, den = 1)
+    raise ZeroDivisionError, "denominator is zero" if den == 0
+
+    if den < 0
+      num = -num
+      den = -den
+    end
+    gcd = num.gcd(den)
+    num = num.div(gcd)
+    den = den.div(gcd)
+    if den == 1 && defined?(Unify)
+      num
+    else
+      new!(num, den)
+    end
+  end
+
+  #
+  # Implements the constructor.  This method does not reduce to lowest terms or
+  # check for division by zero.  Therefore #Rational() should be preferred in
+  # normal use.
+  #
+  def Rational.new!(num, den = 1)
+    new(num, den)
+  end
+
+  private_class_method :new
+
+  #
+  # This method is actually private.
+  #
+  def initialize(num, den)
+    if den < 0
+      num = -num
+      den = -den
+    end
+    @numerator = num.to_i
+    @denominator = den.to_i
+  end
+
+  #
+  # Returns the addition of this value and +a+.
+  #
+  # Examples:
+  #   r = Rational(3,4)      # -> Rational(3,4)
+  #   r + 1                  # -> Rational(7,4)
+  #   r + 0.5                # -> 1.25
+  #
+  def + (a)
+    case a
+    when Rational # => Rational | Integer
+      Rational(@numerator * a.denominator + a.numerator * @denominator, @denominator * a.denominator)
+    when Integer  # => Rational
+      Rational.reduce(@numerator + a * @denominator, @denominator)
+    when Float
+      self.to_f + a
+    else
+      x, y = a.coerce(self)
+      x + y
+    end
+  end
+
+  #
+  # Returns the difference of this value and +a+.
+  # subtracted.
+  #
+  # Examples:
+  #   r = Rational(3,4)    # -> Rational(3,4)
+  #   r - 1                # -> Rational(-1,4)
+  #   r - 0.5              # -> 0.25
+  #
+  def - (a)
+    case a
+    when Rational # => Rational | Integer
+      Rational(@numerator * a.denominator - a.numerator * @denominator, @denominator * a.denominator)
+    when Integer  # => Rational
+      Rational.reduce(@numerator - a * @denominator, @denominator)
+    when Float
+      self.to_f - a
+    else
+      x, y = a.coerce(self)
+      x - y
+    end
+  end
+
+  #
+  # Unary Minus--Returns the receiver's value, negated.
+  #
+  def -@
+    Rational.new!(-@numerator, @denominator)
+  end
+
+  #
+  # Returns the product of this value and +a+.
+  #
+  # Examples:
+  #   r = Rational(3,4)    # -> Rational(3,4)
+  #   r * 2                # -> Rational(3,2)
+  #   r * 4                # -> Rational(3,1)
+  #   r * 0.5              # -> 0.375
+  #   r * Rational(1,2)    # -> Rational(3,8)
+  #
+  def * (a)
+    case a
+    when Rational
+      Rational(@numerator * a.numerator, @denominator * a.denominator)
+    when Integer
+      Rational(@numerator * a, @denominator)
+    when Float
+      self.to_f * a
+    else
+      x, y = a.coerce(self)
+      x * y
+    end
+  end
+
+  #
+  # Returns the quotient of this value and +a+.
+  #   r = Rational(3,4)    # -> Rational(3,4)
+  #   r / 2                # -> Rational(3,8)
+  #   r / 2.0              # -> 0.375
+  #   r / Rational(1,2)    # -> Rational(3,2)
+  #
+  def / (a)
+    case a
+    when Rational
+      Rational(@numerator * a.denominator, @denominator * a.numerator)
+    when Integer
+      raise ZeroDivisionError, "division by zero" if a == 0
+      Rational(@numerator, @denominator * a)
+    when Float
+      self.to_f / a
+    else
+      x, y = a.coerce(self)
+      x / y
+    end
+  end
+
+  #
+  # Returns this value raised to the given power.
+  #
+  # Examples:
+  #   r = Rational(3,4)    # -> Rational(3,4)
+  #   r ** 2               # -> Rational(9,16)
+  #   r ** 2.0             # -> 0.5625
+  #   r ** Rational(1,2)   # -> 0.866025403784439
+  #
+  def ** (other)
+    case other
+    when Rational, Float
+      self.to_f ** other
+    when Integer
+      if other > 0
+	Rational.new!(@numerator ** other, @denominator ** other)
+      elsif other < 0
+	Rational.new!(@denominator ** -other, @numerator ** -other)
+      else
+	Rational.new!(1, 1) # why not Fixnum 1?
+      end
+    else
+      x, y = other.coerce(self)
+      x ** y
+    end
+  end
+
+  def div(other)
+    (self / other).floor
+  end
+
+  #
+  # Returns the remainder when this value is divided by +other+.
+  #
+  # Examples:
+  #   r = Rational(7,4)    # -> Rational(7,4)
+  #   r % Rational(1,2)    # -> Rational(1,4)
+  #   r % 1                # -> Rational(3,4)
+  #   r % Rational(1,7)    # -> Rational(1,28)
+  #   r % 0.26             # -> 0.19
+  #
+  def % (other)
+    value = (self / other).floor
+    self - other * value
+  end
+
+  #
+  # Returns the quotient _and_ remainder.
+  #
+  # Examples:
+  #   r = Rational(7,4)        # -> Rational(7,4)
+  #   r.divmod Rational(1,2)   # -> [3, Rational(1,4)]
+  #
+  def divmod(other)
+    value = (self / other).floor
+    [value, self - other * value]
+  end
+
+  #
+  # Returns the absolute value.
+  #
+  def abs
+    if @numerator > 0
+      self
+    else
+      Rational.new!(-@numerator, @denominator)
+    end
+  end
+
+  # Returns true or false.
+  def zero?
+    @numerator.zero?
+  end
+
+  # See Numeric#nonzero?
+  def nonzero?
+    @numerator.nonzero? ? self : nil
+  end
+
+
+  #
+  # Returns +true+ iff this value is numerically equal to +other+.
+  #
+  # But beware:
+  #   Rational(1,2) == Rational(4,8)          # -> true
+  #   Rational(1,2) == Rational.new!(4,8)     # -> false
+  #
+  # Don't use Rational.new!
+  #
+  def == (other)
+    case other
+    when Rational
+      @numerator == other.numerator && @denominator == other.denominator
+    when Integer
+      @numerator == other && @denominator == 1
+    when Float
+      self.to_f == other
+    else
+      other == self
+    end
+  end
+
+  #
+  # Standard comparison operator.
+  #
+  def <=> (other)
+    case other
+    when Rational
+      @numerator * other.denominator <=> other.numerator * @denominator
+    when Integer
+      @numerator <=> other * @denominator
+    when Float
+      self.to_f <=> other
+    else
+      x, y = other.coerce(self) rescue return nil
+      x <=> y
+    end
+  end
+
+  def coerce(other)
+    case other
+    when Float
+      return other, self.to_f
+    when Integer
+      return Rational.new!(other, 1), self
+    else
+      super
+    end
+  end
+
+  #
+  # Converts the rational to an Integer.  Not the _nearest_ integer, the
+  # truncated integer.  Study the following example carefully:
+  #   Rational(+7,4).to_i             # -> 1
+  #   Rational(-7,4).to_i             # -> -1
+  #   (-1.75).to_i                    # -> -1
+  #
+  # In other words:
+  #   Rational(-7,4) == -1.75                 # -> true
+  #   Rational(-7,4).to_i == (-1.75).to_i     # -> true
+  #
+
+
+  def floor()
+    @numerator.div(@denominator)
+  end
+
+  def ceil()
+    -((-@numerator).div(@denominator))
+  end
+
+  def truncate()
+    if @numerator < 0
+      -((-@numerator).div(@denominator))
+    else
+      @numerator.div(@denominator)
+    end
+  end
+
+  alias_method :to_i, :truncate
+
+  def round()
+    if @numerator < 0
+      -((@numerator * -2 + @denominator).div(@denominator * 2))
+    else
+      ((@numerator * 2 + @denominator).div(@denominator * 2))
+    end
+  end
+
+  #
+  # Converts the rational to a Float.
+  #
+  def to_f
+    @numerator.fdiv(@denominator)
+  end
+
+  #
+  # Returns a string representation of the rational number.
+  #
+  # Example:
+  #   Rational(3,4).to_s          #  "3/4"
+  #   Rational(8).to_s            #  "8"
+  #
+  def to_s
+    if @denominator == 1
+      @numerator.to_s
+    else
+      "#{@numerator}/#{@denominator}"
+    end
+  end
+
+  #
+  # Returns +self+.
+  #
+  def to_r
+    self
+  end
+
+  #
+  # Returns a reconstructable string representation:
+  #
+  #   Rational(5,8).inspect     # -> "Rational(5, 8)"
+  #
+  def inspect
+    "Rational(#{@numerator.inspect}, #{@denominator.inspect})"
+  end
+
+  #
+  # Returns a hash code for the object.
+  #
+  def hash
+    @numerator.hash ^ @denominator.hash
+  end
+
+  attr :numerator
+  attr :denominator
+
+  private :initialize
+end
+
+class Integer
+  #
+  # In an integer, the value _is_ the numerator of its rational equivalent.
+  # Therefore, this method returns +self+.
+  #
+  def numerator
+    self
+  end
+
+  #
+  # In an integer, the denominator is 1.  Therefore, this method returns 1.
+  #
+  def denominator
+    1
+  end
+
+  #
+  # Returns a Rational representation of this integer.
+  #
+  def to_r
+    Rational(self, 1)
+  end
+
+  #
+  # Returns the <em>greatest common denominator</em> of the two numbers (+self+
+  # and +n+).
+  #
+  # Examples:
+  #   72.gcd 168           # -> 24
+  #   19.gcd 36            # -> 1
+  #
+  # The result is positive, no matter the sign of the arguments.
+  #
+  def gcd(other)
+    min = self.abs
+    max = other.abs
+    while min > 0
+      tmp = min
+      min = max % min
+      max = tmp
+    end
+    max
+  end
+
+  #
+  # Returns the <em>lowest common multiple</em> (LCM) of the two arguments
+  # (+self+ and +other+).
+  #
+  # Examples:
+  #   6.lcm 7        # -> 42
+  #   6.lcm 9        # -> 18
+  #
+  def lcm(other)
+    if self.zero? or other.zero?
+      0
+    else
+      (self.div(self.gcd(other)) * other).abs
+    end
+  end
+
+  #
+  # Returns the GCD _and_ the LCM (see #gcd and #lcm) of the two arguments
+  # (+self+ and +other+).  This is more efficient than calculating them
+  # separately.
+  #
+  # Example:
+  #   6.gcdlcm 9     # -> [3, 18]
+  #
+  def gcdlcm(other)
+    gcd = self.gcd(other)
+    if self.zero? or other.zero?
+      [gcd, 0]
+    else
+      [gcd, (self.div(gcd) * other).abs]
+    end
+  end
+end
+
+class Fixnum
+  remove_method :quo
+
+  # If Rational is defined, returns a Rational number instead of a Float.
+  def quo(other)
+    Rational.new!(self, 1) / other
+  end
+  alias rdiv quo
+
+  # Returns a Rational number if the result is in fact rational (i.e. +other+ < 0).
+  def rpower (other)
+    if other >= 0
+      self.power!(other)
+    else
+      Rational.new!(self, 1)**other
+    end
+  end
+
+end
+
+class Bignum
+  remove_method :quo
+
+  # If Rational is defined, returns a Rational number instead of a Float.
+  def quo(other)
+    Rational.new!(self, 1) / other
+  end
+  alias rdiv quo
+
+  # Returns a Rational number if the result is in fact rational (i.e. +other+ < 0).
+  def rpower (other)
+    if other >= 0
+      self.power!(other)
+    else
+      Rational.new!(self, 1)**other
+    end
+  end
+
+end
+
+unless defined? 1.power!
+  class Fixnum
+    alias power! **
+    alias ** rpower
+  end
+  class Bignum
+    alias power! **
+    alias ** rpower
+  end
+end
--- /dev/null
+++ b/ext/rational/rational.c
@@ -0,0 +1,42 @@
+#include "ruby.h"
+
+/*
+ * call-seq:
+ *    fixnum.gcd(fixnum)  ->  fixnum
+ *
+ * Fixnum-specific optimized version of Integer#gcd.  Delegates to
+ * Integer#gcd as necessary.
+ */
+static VALUE
+fix_gcd(self, other)
+    VALUE self, other;
+{
+    long a, b, min, max;
+
+    /*
+     * Note: Cannot handle values <= FIXNUM_MIN here due to overflow during negation.
+     */
+    if (!FIXNUM_P(other) ||
+	(a = FIX2LONG(self)) <= FIXNUM_MIN ||
+	(b = FIX2LONG(other)) <= FIXNUM_MIN ) {
+	/* Delegate to Integer#gcd */
+	return rb_call_super(1, &other);
+    }
+
+    min = a < 0 ? -a : a;
+    max = b < 0 ? -b : b;
+
+    while (min > 0) {
+	long tmp = min;
+	min = max % min;
+	max = tmp;
+    }
+
+    return LONG2FIX(max);
+}
+
+void
+Init_rational()
+{
+    rb_define_method(rb_cFixnum, "gcd", fix_gcd, 1);
+}
--- a/ext/readline/readline.c
+++ b/ext/readline/readline.c
@@ -119,7 +119,7 @@
 	result = rb_tainted_str_new2(buff);
     else
 	result = Qnil;
-    if (buff) free(buff);
+    if (buff) system_free(buff);
     return result;
 }
 
@@ -169,6 +169,7 @@
     char **result;
     int case_fold;
     int i, matches;
+    size_t len;
 
     proc = rb_attr_get(mReadline, completion_proc);
     if (NIL_P(proc))
@@ -183,16 +184,19 @@
     matches = RARRAY(ary)->len;
     if (matches == 0)
 	return NULL;
-    result = ALLOC_N(char *, matches + 2);
+    result = system_malloc(sizeof(char *) * (matches + 2));
     for (i = 0; i < matches; i++) {
 	temp = rb_obj_as_string(RARRAY(ary)->ptr[i]);
-	result[i + 1] = ALLOC_N(char, RSTRING(temp)->len + 1);
+	result[i + 1] = system_malloc(sizeof(char) * (RSTRING(temp)->len + 1));
 	strcpy(result[i + 1], RSTRING(temp)->ptr);
     }
     result[matches + 1] = NULL;
 
     if (matches == 1) {
-        result[0] = strdup(result[1]);
+	len = strlen(result[1]);
+	result[0] = (char *) system_malloc(sizeof(char) * (len + 1));
+	memcpy(result[0], result[1], sizeof(char) * len);
+	result[0][len] = '\0';
     }
     else {
 	register int i = 1;
@@ -218,7 +222,7 @@
 	    if (low > si) low = si;
 	    i++;
 	}
-	result[0] = ALLOC_N(char, low + 1);
+	result[0] = system_malloc(sizeof(char) * (low + 1));
 	strncpy(result[0], result[1], low);
 	result[0][low] = '\0';
     }
@@ -605,8 +609,8 @@
     entry = remove_history(index);
     if (entry) {
         val = rb_tainted_str_new2(entry->line);
-        free(entry->line);
-        free(entry);
+        system_free((void *) entry->line);
+        system_free(entry);
         return val;
     }
     return Qnil;
@@ -705,9 +709,9 @@
 	result = rb_ary_new();
 	for (i = 0; matches[i]; i++) {
 	    rb_ary_push(result, rb_tainted_str_new2(matches[i]));
-	    free(matches[i]);
+	    system_free(matches[i]);
 	}
-	free(matches);
+	system_free(matches);
 	if (RARRAY(result)->len >= 2)
 	    rb_ary_shift(result);
     }
@@ -732,9 +736,9 @@
 	result = rb_ary_new();
 	for (i = 0; matches[i]; i++) {
 	    rb_ary_push(result, rb_tainted_str_new2(matches[i]));
-	    free(matches[i]);
+	    system_free(matches[i]);
 	}
-	free(matches);
+	system_free(matches);
 	if (RARRAY(result)->len >= 2)
 	    rb_ary_shift(result);
     }
--- /dev/null
+++ b/fastmarktable.c
@@ -0,0 +1,83 @@
+/**
+ * A mark table, used during a mark-and-sweep garbage collection cycle.
+ *
+ * This implementation is faster than marktable.c, but is *not*
+ * copy-on-write friendly. It stores mark information directly inside objects.
+ */
+#ifndef _FAST_MARK_TABLE_C_
+#define _FAST_MARK_TABLE_C_
+
+static void
+rb_fast_mark_table_init() {
+}
+
+static void
+rb_fast_mark_table_prepare() {
+}
+
+static void
+rb_fast_mark_table_finalize() {
+}
+
+static inline void
+rb_fast_mark_table_add(RVALUE *object) {
+	object->as.basic.flags |= FL_MARK;
+}
+
+static inline void
+rb_fast_mark_table_heap_add(struct heaps_slot *hs, RVALUE *object) {
+	object->as.basic.flags |= FL_MARK;
+}
+
+static inline int
+rb_fast_mark_table_contains(RVALUE *object) {
+	return object->as.basic.flags & FL_MARK;
+}
+
+static inline int
+rb_fast_mark_table_heap_contains(struct heaps_slot *hs, RVALUE *object) {
+	return object->as.basic.flags & FL_MARK;
+}
+
+static inline void
+rb_fast_mark_table_remove(RVALUE *object) {
+	object->as.basic.flags &= ~FL_MARK;
+}
+
+static inline void
+rb_fast_mark_table_heap_remove(struct heaps_slot *hs, RVALUE *object) {
+	object->as.basic.flags &= ~FL_MARK;
+}
+
+static inline void
+rb_fast_mark_table_add_filename(char *filename) {
+	filename[-1] = 1;
+}
+
+static inline int
+rb_fast_mark_table_contains_filename(const char *filename) {
+	return filename[-1];
+}
+
+static inline void
+rb_fast_mark_table_remove_filename(char *filename) {
+	filename[-1] = 0;
+}
+
+static void
+rb_use_fast_mark_table() {
+	rb_mark_table_init          = rb_fast_mark_table_init;
+	rb_mark_table_prepare       = rb_fast_mark_table_prepare;
+	rb_mark_table_finalize      = rb_fast_mark_table_finalize;
+	rb_mark_table_add           = rb_fast_mark_table_add;
+	rb_mark_table_heap_add      = rb_fast_mark_table_heap_add;
+	rb_mark_table_contains      = rb_fast_mark_table_contains;
+	rb_mark_table_heap_contains = rb_fast_mark_table_heap_contains;
+	rb_mark_table_remove        = rb_fast_mark_table_remove;
+	rb_mark_table_heap_remove   = rb_fast_mark_table_heap_remove;
+	rb_mark_table_add_filename  = rb_fast_mark_table_add_filename;
+	rb_mark_table_contains_filename = rb_fast_mark_table_contains_filename;
+	rb_mark_table_remove_filename   = rb_fast_mark_table_remove_filename;
+}
+
+#endif /* _FAST_MARK_TABLE_C_ */
--- a/gc.c
+++ b/gc.c
@@ -20,8 +20,15 @@
 #include "re.h"
 #include <stdio.h>
 #include <setjmp.h>
+#include <math.h>
 #include <sys/types.h>
 
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <stdarg.h>
+
 #ifdef HAVE_SYS_TIME_H
 #include <sys/time.h>
 #endif
@@ -43,72 +50,115 @@
 int _setjmp(), _longjmp();
 #endif
 
-/* Make alloca work the best possible way.  */
-#ifdef __GNUC__
-# ifndef atarist
-#  ifndef alloca
-#   define alloca __builtin_alloca
-#  endif
-# endif /* atarist */
-#else
-# ifdef HAVE_ALLOCA_H
-#  include <alloca.h>
-# else
-#  ifndef _AIX
-#   ifndef alloca /* predefined by HP cc +Olibcalls */
-void *alloca ();
-#   endif
-#  endif /* AIX */
-# endif /* HAVE_ALLOCA_H */
-#endif /* __GNUC__ */
+#define T_DEFERRED 0x3a
 
 #ifndef GC_MALLOC_LIMIT
 #if defined(MSDOS) || defined(__human68k__)
 #define GC_MALLOC_LIMIT 200000
 #else
-#define GC_MALLOC_LIMIT 8000000
+#define GC_MALLOC_LIMIT (2000000*sizeof(VALUE))
 #endif
 #endif
 
-static unsigned long malloc_increase = 0;
-static unsigned long malloc_limit = GC_MALLOC_LIMIT;
-static void run_final();
-static VALUE nomem_error;
-static void garbage_collect();
+#ifndef GC_LEVEL_MAX  /*maximum # of VALUEs on 'C' stack during GC*/
+#define GC_LEVEL_MAX  8000
+#endif
+#ifndef GC_STACK_PAD
+#define GC_STACK_PAD  200  /* extra padding VALUEs for GC stack */
+#endif
+#define GC_STACK_MAX  (GC_LEVEL_MAX+GC_STACK_PAD)
 
-int ruby_gc_stress = 0;
+static VALUE *stack_limit, *gc_stack_limit;
 
-NORETURN(void rb_exc_jump _((VALUE)));
+static size_t malloc_increase = 0;
+static size_t malloc_limit = GC_MALLOC_LIMIT;
 
-void
-rb_memerror()
+#ifdef MBARI_API
+/*
+ *  call-seq:
+ *     GC.limit    => increase limit in bytes
+ *
+ *  Get the # of bytes that may be allocated before triggering
+ *  a mark and sweep by the garbarge collector to reclaim unused storage.
+ *
+ *  <i>Only available when MBARI_API extentions are enabled at build time</i>
+ */
+static VALUE gc_getlimit(VALUE mod)
 {
-    rb_thread_t th = rb_curr_thread;
+  return ULONG2NUM(malloc_limit);
+}
 
-    if (!nomem_error ||
-	(rb_thread_raised_p(th, RAISED_NOMEMORY) && rb_safe_level() < 4)) {
-	fprintf(stderr, "[FATAL] failed to allocate memory\n");
-	exit(1);
-    }
-    if (rb_thread_raised_p(th, RAISED_NOMEMORY)) {
-	rb_exc_jump(nomem_error);
-    }
-    rb_thread_raised_set(th, RAISED_NOMEMORY);
-    rb_exc_raise(nomem_error);
+/*
+ *  call-seq:
+ *     GC.limit=   => updated increase limit in bytes
+ *
+ *  Set the # of bytes that may be allocated before triggering
+ *  a mark and sweep by the garbarge collector to reclaim unused storage.
+ *  Attempts to set the GC.limit= less than 0 will be ignored.
+ *
+ *     GC.limit=5000000   #=> 5000000
+ *     GC.limit           #=> 5000000
+ *     GC.limit=-50       #=> 5000000
+ *     GC.limit=0         #=> 0  #functionally equivalent to GC.stress=true
+ *
+ *  <i>Only available when MBARI_API extentions are enabled at build time</i>
+ */
+static VALUE gc_setlimit(VALUE mod, VALUE newLimit)
+{
+  long limit = NUM2LONG(newLimit);
+  rb_secure(2);
+  if (limit < 0) return gc_getlimit(mod);
+  malloc_limit = limit;
+  return newLimit;
+}
+
+
+/*
+ *  call-seq:
+ *     GC.growth
+ *
+ *  Get # of bytes that have been allocated since the last mark & sweep
+ *
+ *  <i>Only available when MBARI_API extentions are enabled at build time</i>
+ */
+static VALUE gc_growth(VALUE mod)
+{
+  return ULONG2NUM(malloc_increase);
 }
 
+
+/*
+ *  call-seq:
+ *     GC.exorcise
+ *
+ *  Purge ghost references from recently freed stack space
+ *
+ *  <i>Only available when MBARI_API extentions are enabled at build time</i>
+ */
+static VALUE gc_exorcise(VALUE mod)
+{
+  rb_gc_wipe_stack();
+  return Qnil;
+}
+
+#endif /* MBARI_API */
+
+
+static size_t unstressed_malloc_limit = GC_MALLOC_LIMIT;
+
 /*
  *  call-seq:
  *    GC.stress                 => true or false
  *
  *  returns current status of GC stress mode.
+ *
  */
 
 static VALUE
 gc_stress_get(self)
     VALUE self;
 {
-    return ruby_gc_stress ? Qtrue : Qfalse;
+    return malloc_limit ? Qfalse : Qtrue;
 }
 
 /*
@@ -121,6 +171,7 @@
  *  all memory and object allocation.
  *
  *  Since it makes Ruby very slow, it is only for debugging.
+ *
  */
 
 static VALUE
@@ -128,10 +179,57 @@
     VALUE self, bool;
 {
     rb_secure(2);
-    ruby_gc_stress = RTEST(bool);
+    if (!RTEST(bool))
+      malloc_limit = unstressed_malloc_limit;
+    else if (malloc_limit > 0) {
+      unstressed_malloc_limit = malloc_limit;
+      malloc_limit = 0;
+    }
     return bool;
 }
 
+static void run_final();
+static VALUE nomem_error;
+static void garbage_collect();
+
+
+NORETURN(void rb_exc_jump _((VALUE)));
+
+static unsigned long live_objects = 0;
+unsigned long rb_os_live_objects()
+{ return live_objects; }
+
+#if defined(HAVE_LONG_LONG)
+static unsigned long long allocated_objects = 0;
+unsigned long long rb_os_allocated_objects()
+{ return allocated_objects; }
+#else
+static unsigned long allocated_objects = 0;
+unsigned long rb_os_allocated_objects()
+{ return allocated_objects; }
+#endif
+
+void
+rb_memerror()
+{
+    rb_thread_t th = rb_curr_thread;
+
+    if (!nomem_error ||
+	(rb_thread_raised_p(th, RAISED_NOMEMORY) && rb_safe_level() < 4)) {
+	fprintf(stderr, "[FATAL] failed to allocate memory\n");
+	exit(1);
+    }
+    if (rb_thread_raised_p(th, RAISED_NOMEMORY)) {
+	rb_exc_jump(nomem_error);
+    }
+    rb_thread_raised_set(th, RAISED_NOMEMORY);
+    rb_exc_raise(nomem_error);
+}
+
+static long gc_allocated_size = 0;
+static long gc_num_allocations = 0;
+static int gc_statistics = 0;
+
 void *
 ruby_xmalloc(size)
     long size;
@@ -143,8 +241,9 @@
     }
     if (size == 0) size = 1;
 
-    if (ruby_gc_stress || (malloc_increase+size) > malloc_limit) {
+    if ((malloc_increase+=size) > malloc_limit) {
 	garbage_collect();
+        malloc_increase = size;
     }
     RUBY_CRITICAL(mem = malloc(size));
     if (!mem) {
@@ -154,8 +253,15 @@
 	    rb_memerror();
 	}
     }
-    malloc_increase += size;
+    
+    if (gc_statistics) {
+	gc_allocated_size += size;
+	gc_num_allocations += 1;
+    }
 
+#if STACK_WIPE_SITES & 0x100
+    rb_gc_update_stack_extent();
+#endif
     return mem;
 }
 
@@ -183,7 +289,10 @@
     }
     if (!ptr) return xmalloc(size);
     if (size == 0) size = 1;
-    if (ruby_gc_stress) garbage_collect();
+    if ((malloc_increase+=size) > malloc_limit) {
+	garbage_collect();
+        malloc_increase = size;
+    }
     RUBY_CRITICAL(mem = realloc(ptr, size));
     if (!mem) {
 	garbage_collect();
@@ -192,8 +301,9 @@
 	    rb_memerror();
         }
     }
-    malloc_increase += size;
-
+#if STACK_WIPE_SITES & 0x200
+    rb_gc_update_stack_extent();
+#endif
     return mem;
 }
 
@@ -205,13 +315,167 @@
 	RUBY_CRITICAL(free(x));
 }
 
+#if HAVE_LONG_LONG
+    #define GC_TIME_TYPE LONG_LONG
+#else
+    #define GC_TIME_TYPE long
+#endif
+
 extern int ruby_in_compile;
 static int dont_gc;
+static GC_TIME_TYPE gc_time = 0;
+static int gc_collections = 0;
 static int during_gc;
 static int need_call_final = 0;
 static st_table *finalizer_table = 0;
 
 
+/************************************************************
+ * Heap and copy-on-write debugging support functions
+ ************************************************************/
+
+/* Compound structure, containing debugging options. */
+static struct {
+    FILE *terminal;
+    
+    /* Whether to allocate Ruby heaps by mmapping a file. This makes it easier to see how many
+     * bytes in heaps have been made dirty, using memory analysis tools.
+     */
+    int alloc_heap_with_file;
+
+    /* Whether to ask the user to press Enter, before garbage collection starts.
+     * Can be used to check how many pages are made dirty by the garbage collector.
+     */
+    int prompt_before_gc;
+    
+    /* Whether to ask the user to press Enter before the sweep phase of the garbage
+     * collector starts. */
+    int prompt_before_sweep;
+    
+    /* Whether to ask the user to press Enter after the sweep phase of the garbage
+     * collector starts. */
+    int prompt_after_sweep;
+    
+    int print_sweeped_objects;
+} debug_options;
+
+#define OPTION_ENABLED(name) (getenv((name)) && *getenv((name)) && *getenv((name)) != '0')
+
+static VALUE
+rb_gc_init_debugging(VALUE self)
+{
+    if (debug_options.terminal != NULL) {
+	fclose(debug_options.terminal);
+	debug_options.terminal = NULL;
+    }
+    if (getenv("RD_TERMINAL")) {
+	debug_options.terminal = fopen(getenv("RD_TERMINAL"), "a+");
+	if (debug_options.terminal == NULL) {
+	    int e = errno;
+	    fprintf(stderr, "Cannot open %s: %s (%d)\n", getenv("RD_TERMINAL"), strerror(e), e);
+	    fflush(stderr);
+	}
+    }
+    debug_options.alloc_heap_with_file  = OPTION_ENABLED("RD_ALLOC_HEAP_WITH_FILE");
+    debug_options.prompt_before_gc      = OPTION_ENABLED("RD_PROMPT_BEFORE_GC");
+    debug_options.prompt_before_sweep   = OPTION_ENABLED("RD_PROMPT_BEFORE_SWEEP");
+    debug_options.prompt_after_sweep    = OPTION_ENABLED("RD_PROMPT_AFTER_SWEEP");
+    debug_options.print_sweeped_objects = OPTION_ENABLED("RD_PRINT_SWEEPED_OBJECTS");
+    return Qnil;
+}
+
+static void
+debug_print(const char *message, ...)
+{
+    va_list ap;
+    
+    va_start(ap, message);
+    if (debug_options.terminal != NULL) {
+	vfprintf(debug_options.terminal, message, ap);
+	fflush(debug_options.terminal);
+    } else {
+	vfprintf(stderr, message, ap);
+	fflush(stderr);
+    }
+    va_end(ap);
+}
+
+#define debug_prompt(prompt) \
+    do { \
+	if (debug_options.terminal != NULL) { \
+	    fprintf(debug_options.terminal, prompt); \
+	    fflush(debug_options.terminal); \
+	    getc(debug_options.terminal); \
+	} else { \
+	    fprintf(stderr, prompt); \
+	    fflush(stderr); \
+	    getchar(); \
+	} \
+    } while (0)
+
+
+/************************************
+ * Heap (de)allocation functions
+ ************************************/
+
+typedef struct {
+    int fd;
+    size_t size;
+} FileHeapAllocatorMetaData;
+
+static void *
+alloc_ruby_heap_with_file(size_t size)
+{
+    FileHeapAllocatorMetaData meta;
+    meta.fd = open("/dev/zero", O_RDONLY);
+    meta.size = size;
+    if (meta.fd == -1) {
+	return NULL;
+    } else {
+	void *memory = mmap(NULL, size + sizeof(meta), PROT_READ | PROT_WRITE,
+	                    MAP_PRIVATE, meta.fd, 0);
+	if (memory == NULL) {
+	    return NULL;
+	} else {
+	    memcpy(memory, &meta, sizeof(meta));
+	    return memory + sizeof(meta);
+	}
+    }
+}
+
+static void *
+alloc_ruby_heap(size_t size)
+{
+    if (debug_options.alloc_heap_with_file) {
+	return alloc_ruby_heap_with_file(size);
+    } else {
+	return malloc(size);
+    }
+}
+
+static void
+free_ruby_heap_with_file(void *heap)
+{
+    FileHeapAllocatorMetaData *meta = (FileHeapAllocatorMetaData *)
+        (heap - sizeof(FileHeapAllocatorMetaData));
+    close(meta->fd);
+    munmap(heap, meta->size + sizeof(FileHeapAllocatorMetaData));
+}
+
+static void
+free_ruby_heap(void *heap)
+{
+    if (debug_options.alloc_heap_with_file) {
+	free_ruby_heap_with_file(heap);
+    } else {
+	free(heap);
+    }
+}
+
+
+/*******************************************************************/
+
+
 /*
  *  call-seq:
  *     GC.enable    => true or false
@@ -255,6 +519,140 @@
     return old;
 }
 
+/*
+ *  call-seq:
+ *     GC.enable_stats    => true or false
+ *
+ *  Enables garbage collection statistics, returning <code>true</code> if garbage
+ *  collection statistics was already enabled.
+ *
+ *     GC.enable_stats   #=> false or true
+ *     GC.enable_stats   #=> true
+ *
+ */
+
+VALUE
+rb_gc_enable_stats()
+{
+    int old = gc_statistics;
+    gc_statistics = Qtrue;
+    return old;
+}
+
+/*
+ *  call-seq:
+ *     GC.disable_stats    => true or false
+ *
+ *  Disables garbage collection statistics, returning <code>true</code> if garbage
+ *  collection statistics was already disabled.
+ *
+ *     GC.disable_stats   #=> false or true
+ *     GC.disable_stats   #=> true
+ *
+ */
+
+VALUE
+rb_gc_disable_stats()
+{
+    int old = gc_statistics;
+    gc_statistics = Qfalse;
+    gc_allocated_size = 0;
+    gc_num_allocations = 0;
+    return old;
+}
+
+/*
+ *  call-seq:
+ *     GC.clear_stats    => nil
+ *
+ *  Clears garbage collection statistics, returning nil. This resets the number
+ *  of collections (GC.collections) and the time used (GC.time) to 0.
+ *
+ *     GC.clear_stats    #=> nil
+ *
+ */
+
+VALUE
+rb_gc_clear_stats()
+{
+    gc_collections = 0;
+    gc_time = 0;
+    gc_allocated_size = 0;
+    gc_num_allocations = 0;
+    return Qnil; 
+}
+
+/*
+ *  call-seq:
+ *     GC.allocated_size    => Integer
+ *
+ *  Returns the size of memory (in bytes) allocated since GC statistics collection
+ *  was enabled.
+ *
+ *     GC.allocated_size    #=> 35
+ *
+ */
+VALUE
+rb_gc_allocated_size()
+{
+    return INT2NUM(gc_allocated_size);
+}
+
+/*
+ *  call-seq:
+ *     GC.num_allocations    => Integer
+ *
+ *  Returns the number of memory allocations since GC statistics collection
+ *  was enabled.
+ *
+ *     GC.num_allocations    #=> 150
+ *
+ */
+VALUE
+rb_gc_num_allocations()
+{
+    return INT2NUM(gc_num_allocations);
+}
+
+/*
+ *  call-seq:
+ *     GC.collections    => Integer
+ *
+ *  Returns the number of garbage collections performed while GC statistics collection
+ *  was enabled.
+ *
+ *     GC.collections    #=> 35
+ *
+ */
+
+VALUE
+rb_gc_collections()
+{
+    return INT2NUM(gc_collections);
+}
+
+/*
+ *  call-seq:
+ *     GC.time    => Integer
+ *
+ *  Returns the time spent during garbage collection while GC statistics collection
+ *  was enabled (in micro seconds).
+ *
+ *     GC.time    #=> 20000
+ *
+ */
+
+VALUE
+rb_gc_time()
+{
+#if HAVE_LONG_LONG
+    return LL2NUM(gc_time);
+#else
+    return LONG2NUM(gc_time);
+#endif
+}
+
+
 VALUE rb_mGC;
 
 static struct gc_list {
@@ -346,22 +744,181 @@
 static RVALUE *freelist = 0;
 static RVALUE *deferred_final_list = 0;
 
-#define HEAPS_INCREMENT 10
+static int heaps_increment = 10;
 static struct heaps_slot {
     void *membase;
     RVALUE *slot;
     int limit;
+    RVALUE *slotlimit;
+    int *marks;
+    int marks_size;
 } *heaps;
 static int heaps_length = 0;
 static int heaps_used   = 0;
 
-#define HEAP_MIN_SLOTS 10000
-static int heap_slots = HEAP_MIN_SLOTS;
+static int heap_min_slots = 10000;
+static int heap_slots = 10000;
+
+static int heap_free_min = 4096;
+static int heap_slots_increment = 10000;
+static double heap_slots_growth_factor = 1.8;
+
+static int verbose_gc_stats = Qfalse;
 
-#define FREE_MIN  4096
+static FILE* gc_data_file = NULL;
 
 static RVALUE *himem, *lomem;
 
+#include "marktable.h"
+#include "marktable.c"
+#include "fastmarktable.c"
+
+static int gc_cycles = 0;
+
+static void set_gc_parameters()
+{
+    char *gc_stats_ptr, *min_slots_ptr, *free_min_ptr, *heap_slots_incr_ptr,
+      *heap_incr_ptr, *malloc_limit_ptr, *gc_heap_file_ptr, *heap_slots_growth_factor_ptr;
+
+    gc_data_file = stderr;
+
+    gc_stats_ptr = getenv("RUBY_GC_STATS");
+    if (gc_stats_ptr != NULL) {
+	int gc_stats_i = atoi(gc_stats_ptr);
+	if (gc_stats_i > 0) {
+	    verbose_gc_stats = Qtrue;
+	}
+    }
+
+    gc_heap_file_ptr = getenv("RUBY_GC_DATA_FILE");
+    if (gc_heap_file_ptr != NULL) {
+	FILE* data_file = fopen(gc_heap_file_ptr, "w");
+	if (data_file != NULL) {
+	    gc_data_file = data_file;
+	}
+	else {
+	    fprintf(stderr,
+		    "can't open gc log file %s for writing, using default\n", gc_heap_file_ptr);
+	}
+    }
+
+    min_slots_ptr = getenv("RUBY_HEAP_MIN_SLOTS");
+    if (min_slots_ptr != NULL) {
+	int min_slots_i = atoi(min_slots_ptr);
+        if (verbose_gc_stats) {
+	    fprintf(gc_data_file, "RUBY_HEAP_MIN_SLOTS=%s\n", min_slots_ptr);
+        }
+	if (min_slots_i > 0) {
+	    heap_slots = min_slots_i;
+	    heap_min_slots = min_slots_i;
+	}
+    }
+
+    free_min_ptr = getenv("RUBY_HEAP_FREE_MIN");
+    if (free_min_ptr != NULL) {
+	int free_min_i = atoi(free_min_ptr);
+        if (verbose_gc_stats) {
+	    fprintf(gc_data_file, "RUBY_HEAP_FREE_MIN=%s\n", free_min_ptr);
+	}
+	if (free_min_i > 0) {
+	    heap_free_min = free_min_i;
+	}
+    }
+
+    heap_incr_ptr = getenv("RUBY_HEAP_INCREMENT");
+    if (heap_incr_ptr != NULL) {
+	int heap_incr_i = atoi(heap_incr_ptr);
+        if (verbose_gc_stats) {
+	    fprintf(gc_data_file, "RUBY_HEAP_INCREMENT=%s\n", heap_incr_ptr);
+	}
+	if (heap_incr_i > 0) {
+	    heaps_increment = heap_incr_i;
+	}
+    }
+
+    heap_slots_incr_ptr = getenv("RUBY_HEAP_SLOTS_INCREMENT");
+    if (heap_slots_incr_ptr != NULL) {
+	int heap_slots_incr_i = atoi(heap_slots_incr_ptr);
+        if (verbose_gc_stats) {
+	    fprintf(gc_data_file, "RUBY_HEAP_SLOTS_INCREMENT=%s\n", heap_slots_incr_ptr);
+	}
+	if (heap_slots_incr_i > 0) {
+	    heap_slots_increment = heap_slots_incr_i;
+	}
+    }
+    heap_slots_growth_factor_ptr = getenv("RUBY_HEAP_SLOTS_GROWTH_FACTOR");
+    if (heap_slots_growth_factor_ptr != NULL) {
+	double heap_slots_growth_factor_d = atof(heap_slots_growth_factor_ptr);
+        if (verbose_gc_stats) {
+	    fprintf(gc_data_file, "RUBY_HEAP_SLOTS_GROWTH_FACTOR=%s\n", heap_slots_growth_factor_ptr);
+	}
+	if (heap_slots_growth_factor_d > 0) {
+	    heap_slots_growth_factor = heap_slots_growth_factor_d;
+	}
+    }
+
+    malloc_limit_ptr = getenv("RUBY_GC_MALLOC_LIMIT");
+    if (malloc_limit_ptr != NULL) {
+	int malloc_limit_i = atol(malloc_limit_ptr);
+        if (verbose_gc_stats) {
+	    fprintf(gc_data_file, "RUBY_GC_MALLOC_LIMIT=%s\n", malloc_limit_ptr);
+	}
+	if (malloc_limit_i > 0) {
+	    malloc_limit = malloc_limit_i;
+	}
+    }
+}
+
+/*
+ *  call-seq:
+ *     GC.dump    => nil
+ *
+ *  dumps information about the current GC data structures to the GC log file
+ *
+ *     GC.dump    #=> nil
+ *
+ */
+
+VALUE
+rb_gc_dump()
+{
+    int i;
+
+    for (i = 0; i < heaps_used; i++) {
+	int heap_size = heaps[i].limit;
+	fprintf(gc_data_file, "HEAP[%2d]: size=%7d\n", i, heap_size);
+    }
+
+    return Qnil;
+}
+
+/*
+ *  call-seq:
+ *     GC.log String  => String
+ *
+ *  Logs string to the GC data file and returns it.
+ *
+ *     GC.log "manual GC call"    #=> "manual GC call"
+ *
+ */
+
+VALUE
+rb_gc_log(self, original_str)
+     VALUE self, original_str;
+{
+    if (original_str == Qnil) {
+        fprintf(gc_data_file, "\n");
+    }
+    else {
+        VALUE str = StringValue(original_str);
+        char *p = RSTRING(str)->ptr;
+        fprintf(gc_data_file, "%s\n", p);
+    }
+    return original_str;
+}
+
+
+
 static void
 add_heap()
 {
@@ -372,7 +929,7 @@
 	struct heaps_slot *p;
 	int length;
 
-	heaps_length += HEAPS_INCREMENT;
+	heaps_length += heaps_increment;
 	length = heaps_length*sizeof(struct heaps_slot);
 	RUBY_CRITICAL(
 	    if (heaps_used > 0) {
@@ -386,12 +943,12 @@
     }
 
     for (;;) {
-	RUBY_CRITICAL(p = (RVALUE*)malloc(sizeof(RVALUE)*(heap_slots+1)));
+	RUBY_CRITICAL(p = (RVALUE*)alloc_ruby_heap(sizeof(RVALUE)*(heap_slots+1)));
 	if (p == 0) {
-	    if (heap_slots == HEAP_MIN_SLOTS) {
+	    if (heap_slots == heap_min_slots) {
 		rb_memerror();
 	    }
-	    heap_slots = HEAP_MIN_SLOTS;
+	    heap_slots = heap_min_slots;
 	    continue;
 	}
         heaps[heaps_used].membase = p;
@@ -401,14 +958,18 @@
             p = (RVALUE*)((VALUE)p + sizeof(RVALUE) - ((VALUE)p % sizeof(RVALUE)));
         heaps[heaps_used].slot = p;
         heaps[heaps_used].limit = heap_slots;
+        heaps[heaps_used].slotlimit = p + heap_slots;
+        heaps[heaps_used].marks_size = (int) (ceil(heap_slots / (sizeof(int) * 8.0)));
+        heaps[heaps_used].marks = (int *) calloc(heaps[heaps_used].marks_size, sizeof(int));
 	break;
     }
     pend = p + heap_slots;
     if (lomem == 0 || lomem > p) lomem = p;
     if (himem < pend) himem = pend;
     heaps_used++;
-    heap_slots *= 1.8;
-    if (heap_slots <= 0) heap_slots = HEAP_MIN_SLOTS;
+    heap_slots += heap_slots_increment;
+    heap_slots_increment *= heap_slots_growth_factor;
+    if (heap_slots <= 0) heap_slots = heap_min_slots;
 
     while (p < pend) {
 	p->as.free.flags = 0;
@@ -433,7 +994,7 @@
     if (during_gc)
 	rb_bug("object allocation during garbage collection phase");
 
-    if (ruby_gc_stress || !freelist) garbage_collect();
+    if (!malloc_limit || !freelist) garbage_collect();
 
     obj = (VALUE)freelist;
     freelist = freelist->as.free.next;
@@ -442,6 +1003,8 @@
     RANY(obj)->file = ruby_sourcefile;
     RANY(obj)->line = ruby_sourceline;
 #endif
+    live_objects++;
+    allocated_objects++;
     return obj;
 }
 
@@ -468,6 +1031,9 @@
 VALUE *rb_gc_register_stack_start = 0;
 #endif
 
+VALUE *rb_gc_stack_end = (VALUE *)STACK_GROW_DIRECTION;
+
+
 #ifdef DJGPP
 /* set stack size (http://www.delorie.com/djgpp/v2faq/faq15_9.html) */
 unsigned int _stklen = 0x180000; /* 1.5 kB */
@@ -485,77 +1051,90 @@
 # define STACK_LEVEL_MAX 655300
 #endif
 
-#ifdef C_ALLOCA
-# define SET_STACK_END VALUE stack_end; alloca(0);
+#ifndef nativeAllocA
+  /* portable way to return an approximate stack pointer */
+NOINLINE(VALUE *__sp(void));
+VALUE *__sp(void) {
+  VALUE tos;
+  return &tos;
+}
+# define SET_STACK_END VALUE stack_end
 # define STACK_END (&stack_end)
 #else
-# if defined(__GNUC__) && defined(USE_BUILTIN_FRAME_ADDRESS) && !defined(__ia64)
-#  if ( __GNUC__ == 3 && __GNUC_MINOR__ > 0 ) || __GNUC__ > 3
-__attribute__ ((noinline))
-#  endif
-static void
-stack_end_address(VALUE **stack_end_p)
-{
-    VALUE stack_end;
-    *stack_end_p = &stack_end;
-}
-#  define  SET_STACK_END    VALUE *stack_end; stack_end_address(&stack_end)
-# else
-#  define  SET_STACK_END    VALUE *stack_end = alloca(1)
-# endif
-# define STACK_END (stack_end)
+# define SET_STACK_END ((void)0)
+# define STACK_END __sp()
 #endif
+
 #if STACK_GROW_DIRECTION < 0
-# define STACK_LENGTH  (rb_gc_stack_start - STACK_END)
+# define STACK_LENGTH(start)  ((start) - STACK_END)
 #elif STACK_GROW_DIRECTION > 0
-# define STACK_LENGTH  (STACK_END - rb_gc_stack_start + 1)
+# define STACK_LENGTH(start)  (STACK_END - (start) + 1)
 #else
-# define STACK_LENGTH  ((STACK_END < rb_gc_stack_start) ? rb_gc_stack_start - STACK_END\
-                                           : STACK_END - rb_gc_stack_start + 1)
+# define STACK_LENGTH(start)  ((STACK_END < (start)) ? \
+                                 (start) - STACK_END : STACK_END - (start) + 1)
 #endif
+
 #if STACK_GROW_DIRECTION > 0
-# define STACK_UPPER(x, a, b) a
+# define STACK_UPPER(a, b) a
 #elif STACK_GROW_DIRECTION < 0
-# define STACK_UPPER(x, a, b) b
+# define STACK_UPPER(a, b) b
 #else
-static int grow_direction;
+int rb_gc_stack_grow_direction;
 static int
 stack_grow_direction(addr)
     VALUE *addr;
 {
     SET_STACK_END;
-
-    if (STACK_END > addr) return grow_direction = 1;
-    return grow_direction = -1;
+    return rb_gc_stack_grow_direction = STACK_END > addr ? 1 : -1;
 }
-# define stack_growup_p(x) ((grow_direction ? grow_direction : stack_grow_direction(x)) > 0)
-# define STACK_UPPER(x, a, b) (stack_growup_p(x) ? a : b)
+# define STACK_UPPER(a, b) (rb_gc_stack_grow_direction > 0 ? a : b)
 #endif
 
-#define GC_WATER_MARK 512
-
-#define CHECK_STACK(ret) do {\
-    SET_STACK_END;\
-    (ret) = (STACK_LENGTH > STACK_LEVEL_MAX + GC_WATER_MARK);\
-} while (0)
-
 size_t
-ruby_stack_length(p)
-    VALUE **p;
+ruby_stack_length(start, base)
+    VALUE *start, **base;
 {
     SET_STACK_END;
-    if (p) *p = STACK_UPPER(STACK_END, rb_gc_stack_start, STACK_END);
-    return STACK_LENGTH;
+    if (base) *base = STACK_UPPER(start, STACK_END);
+    return STACK_LENGTH(start);
 }
 
 int
 ruby_stack_check()
 {
-    int ret;
+    SET_STACK_END;
+    return __stack_past(stack_limit, STACK_END);
+}
 
-    CHECK_STACK(ret);
-    return ret;
+/*
+  Zero memory that was (recently) part of the stack, but is no longer.
+  Invoke when stack is deep to mark its extent and when it's shallow to wipe it.
+*/
+#if STACK_WIPE_METHOD != 4
+#if STACK_WIPE_METHOD
+void rb_gc_wipe_stack(void)
+{
+  VALUE *stack_end = rb_gc_stack_end;
+  VALUE *sp = __sp();
+  rb_gc_stack_end = sp;
+#if STACK_WIPE_METHOD == 1
+#warning clearing of "ghost references" from the call stack has been disabled
+#elif STACK_WIPE_METHOD == 2  /* alloca ghost stack before clearing it */
+  if (__stack_past(sp, stack_end)) {
+    size_t bytes = __stack_depth((char *)stack_end, (char *)sp);
+    STACK_UPPER(sp = nativeAllocA(bytes), stack_end = nativeAllocA(bytes));
+    __stack_zero(stack_end, sp);
+  }
+#elif STACK_WIPE_METHOD == 3    /* clear unallocated area past stack pointer */
+  __stack_zero(stack_end, sp);  /* will crash if compiler pushes a temp. here */
+#else
+#error unsupported method of clearing ghost references from the stack
+#endif
 }
+#else
+#warning clearing of "ghost references" from the call stack completely disabled
+#endif
+#endif
 
 #define MARK_STACK_MAX 1024
 static VALUE mark_stack[MARK_STACK_MAX];
@@ -571,6 +1150,17 @@
 
 #define MARK_STACK_EMPTY (mark_stack_ptr == mark_stack)
 
+static inline void
+push_mark_stack(VALUE ptr)
+{
+    if (!mark_stack_overflow) {
+	if (mark_stack_ptr - mark_stack < MARK_STACK_MAX)
+	    *mark_stack_ptr++ = ptr;
+	else
+	    mark_stack_overflow = 1;
+    }
+}
+    
 static st_table *source_filenames;
 
 char *
@@ -596,7 +1186,7 @@
     char *f;
 {
     if (f) {
-	f[-1] = 1;
+	rb_mark_table_add_filename(f);
     }
 }
 
@@ -604,32 +1194,33 @@
 sweep_source_filename(key, value)
     char *key, *value;
 {
-    if (*value) {
-	*value = 0;
+    if (rb_mark_table_contains_filename(value + 1)) {
+	rb_mark_table_remove_filename(value + 1);
 	return ST_CONTINUE;
     }
     else {
+	rb_mark_table_remove_filename(value + 1);
 	free(value);
 	return ST_DELETE;
     }
 }
 
-static void gc_mark _((VALUE ptr, int lev));
-static void gc_mark_children _((VALUE ptr, int lev));
+#define gc_mark(ptr) rb_gc_mark(ptr)
+static void gc_mark_children _((VALUE ptr));
 
 static void
 gc_mark_all()
 {
     RVALUE *p, *pend;
-    int i;
+    struct heaps_slot *heap = heaps+heaps_used;
 
     init_mark_stack();
-    for (i = 0; i < heaps_used; i++) {
-	p = heaps[i].slot; pend = p + heaps[i].limit;
+    while (--heap >= heaps) {
+	p = heap->slot; pend = p + heap->limit;
 	while (p < pend) {
-	    if ((p->as.basic.flags & FL_MARK) &&
-		(p->as.basic.flags != FL_MARK)) {
-		gc_mark_children((VALUE)p, 0);
+	    if (rb_mark_table_heap_contains(heap, p) &&
+	        BUILTIN_TYPE(p) != T_DEFERRED) {
+		gc_mark_children((VALUE)p);
 	    }
 	    p++;
 	}
@@ -639,194 +1230,145 @@
 static void
 gc_mark_rest()
 {
+    size_t stackLen = mark_stack_ptr - mark_stack;
+#ifdef nativeAllocA
+    VALUE *tmp_arry = nativeAllocA(stackLen*sizeof(VALUE));
+#else
     VALUE tmp_arry[MARK_STACK_MAX];
-    VALUE *p;
-
-    p = (mark_stack_ptr - mark_stack) + tmp_arry;
-    MEMCPY(tmp_arry, mark_stack, VALUE, MARK_STACK_MAX);
+#endif
+    VALUE *p = tmp_arry + stackLen;
+    
+    MEMCPY(tmp_arry, mark_stack, VALUE, stackLen);
 
     init_mark_stack();
-    while(p != tmp_arry){
-	p--;
-	gc_mark_children(*p, 0);
-    }
+    while(--p >= tmp_arry) gc_mark_children(*p);
 }
 
 static inline int
 is_pointer_to_heap(ptr)
     void *ptr;
 {
-    register RVALUE *p = RANY(ptr);
-    register RVALUE *heap_org;
-    register long i;
+    RVALUE *p = RANY(ptr);
+    struct heaps_slot *heap;
 
-    if (p < lomem || p > himem) return Qfalse;
-    if ((VALUE)p % sizeof(RVALUE) != 0) return Qfalse;
+    if (p < lomem || p > himem || (VALUE)p % sizeof(RVALUE)) return Qfalse;
 
     /* check if p looks like a pointer */
-    for (i=0; i < heaps_used; i++) {
-	heap_org = heaps[i].slot;
-	if (heap_org <= p && p < heap_org + heaps[i].limit)
-	    return Qtrue;
-    }
+    heap = heaps+heaps_used;
+    while (--heap >= heaps) 
+      if (p >= heap->slot && p < heap->slot + heap->limit)
+        return Qtrue;
     return Qfalse;
 }
 
 static void
 mark_locations_array(x, n)
-    register VALUE *x;
-    register long n;
+    VALUE *x;
+    size_t n;
 {
     VALUE v;
     while (n--) {
         v = *x;
 	if (is_pointer_to_heap((void *)v)) {
-	    gc_mark(v, 0);
+	    gc_mark(v);
 	}
 	x++;
     }
 }
 
-void
+inline void
 rb_gc_mark_locations(start, end)
     VALUE *start, *end;
 {
-    long n;
-
-    n = end - start;
-    mark_locations_array(start,n);
+    mark_locations_array(start,end - start);
 }
 
 static int
-mark_entry(key, value, lev)
+mark_entry(key, value)
     ID key;
     VALUE value;
-    int lev;
 {
-    gc_mark(value, lev);
+    gc_mark(value);
     return ST_CONTINUE;
 }
 
-static void
-mark_tbl(tbl, lev)
-    st_table *tbl;
-    int lev;
-{
-    if (!tbl) return;
-    st_foreach(tbl, mark_entry, lev);
-}
-
 void
 rb_mark_tbl(tbl)
     st_table *tbl;
 {
-    mark_tbl(tbl, 0);
+    if (!tbl) return;
+    st_foreach(tbl, mark_entry, 0);
 }
+#define mark_tbl(tbl)  rb_mark_tbl(tbl)
 
 static int
-mark_key(key, value, lev)
+mark_key(key, value)
     VALUE key, value;
-    int lev;
 {
-    gc_mark(key, lev);
+    gc_mark(key);
     return ST_CONTINUE;
 }
 
-static void
-mark_set(tbl, lev)
-    st_table *tbl;
-    int lev;
-{
-    if (!tbl) return;
-    st_foreach(tbl, mark_key, lev);
-}
-
 void
 rb_mark_set(tbl)
     st_table *tbl;
 {
-    mark_set(tbl, 0);
+    if (!tbl) return;
+    st_foreach(tbl, mark_key, 0);
 }
 
 static int
-mark_keyvalue(key, value, lev)
+mark_keyvalue(key, value)
     VALUE key;
     VALUE value;
-    int lev;
 {
-    gc_mark(key, lev);
-    gc_mark(value, lev);
+    gc_mark(key);
+    gc_mark(value);
     return ST_CONTINUE;
 }
 
-static void
-mark_hash(tbl, lev)
-    st_table *tbl;
-    int lev;
-{
-    if (!tbl) return;
-    st_foreach(tbl, mark_keyvalue, lev);
-}
-
 void
 rb_mark_hash(tbl)
     st_table *tbl;
 {
-    mark_hash(tbl, 0);
+    if (!tbl) return;
+    st_foreach(tbl, mark_keyvalue, 0);
 }
+#define mark_hash(tbl)  rb_mark_hash(tbl)
 
 void
 rb_gc_mark_maybe(obj)
     VALUE obj;
 {
     if (is_pointer_to_heap((void *)obj)) {
-	gc_mark(obj, 0);
+	gc_mark(obj);
     }
 }
 
-#define GC_LEVEL_MAX 250
-
-static void
-gc_mark(ptr, lev)
+void
+rb_gc_mark(ptr)
     VALUE ptr;
-    int lev;
 {
-    register RVALUE *obj;
-
-    obj = RANY(ptr);
+    RVALUE *obj = RANY(ptr);
+    SET_STACK_END;
+    
     if (rb_special_const_p(ptr)) return; /* special const not marked */
     if (obj->as.basic.flags == 0) return;       /* free cell */
-    if (obj->as.basic.flags & FL_MARK) return;  /* already marked */
-    obj->as.basic.flags |= FL_MARK;
+    if (rb_mark_table_contains(obj)) return;  /* already marked */
+    rb_mark_table_add(obj);
 
-    if (lev > GC_LEVEL_MAX || (lev == 0 && ruby_stack_check())) {
-	if (!mark_stack_overflow) {
-	    if (mark_stack_ptr - mark_stack < MARK_STACK_MAX) {
-		*mark_stack_ptr = ptr;
-		mark_stack_ptr++;
-	    }
-	    else {
-		mark_stack_overflow = 1;
-	    }
-	}
-	return;
+    if (__stack_past(gc_stack_limit, STACK_END))
+      push_mark_stack(ptr);
+    else{
+      gc_mark_children(ptr);
     }
-    gc_mark_children(ptr, lev+1);
-}
-
-void
-rb_gc_mark(ptr)
-    VALUE ptr;
-{
-    gc_mark(ptr, 0);
 }
 
 static void
-gc_mark_children(ptr, lev)
+gc_mark_children(ptr)
     VALUE ptr;
-    int lev;
 {
-    register RVALUE *obj = RANY(ptr);
+    RVALUE *obj = RANY(ptr);
 
     goto marking;		/* skip */
 
@@ -834,8 +1376,8 @@
     obj = RANY(ptr);
     if (rb_special_const_p(ptr)) return; /* special const not marked */
     if (obj->as.basic.flags == 0) return;       /* free cell */
-    if (obj->as.basic.flags & FL_MARK) return;  /* already marked */
-    obj->as.basic.flags |= FL_MARK;
+    if (rb_mark_table_contains(obj)) return;  /* already marked */
+    rb_mark_table_add(obj);
 
   marking:
     if (FL_TEST(obj, FL_EXIVAR)) {
@@ -860,7 +1402,7 @@
 	  case NODE_RESCUE:
 	  case NODE_RESBODY:
 	  case NODE_CLASS:
-	    gc_mark((VALUE)obj->as.node.u2.node, lev);
+	    gc_mark((VALUE)obj->as.node.u2.node);
 	    /* fall through */
 	  case NODE_BLOCK:	/* 1,3 */
 	  case NODE_ARRAY:
@@ -873,7 +1415,7 @@
 	  case NODE_CALL:
 	  case NODE_DEFS:
 	  case NODE_OP_ASGN1:
-	    gc_mark((VALUE)obj->as.node.u1.node, lev);
+	    gc_mark((VALUE)obj->as.node.u1.node);
 	    /* fall through */
 	  case NODE_SUPER:	/* 3 */
 	  case NODE_FCALL:
@@ -900,7 +1442,7 @@
 	  case NODE_ALIAS:
 	  case NODE_VALIAS:
 	  case NODE_ARGS:
-	    gc_mark((VALUE)obj->as.node.u1.node, lev);
+	    gc_mark((VALUE)obj->as.node.u1.node);
 	    /* fall through */
 	  case NODE_METHOD:	/* 2 */
 	  case NODE_NOT:
@@ -938,7 +1480,7 @@
 	  case NODE_SCOPE:	/* 2,3 */
 	  case NODE_BLOCK_PASS:
 	  case NODE_CDECL:
-	    gc_mark((VALUE)obj->as.node.u3.node, lev);
+	    gc_mark((VALUE)obj->as.node.u3.node);
 	    ptr = (VALUE)obj->as.node.u2.node;
 	    goto again;
 
@@ -971,25 +1513,26 @@
 
 	  default:		/* unlisted NODE */
 	    if (is_pointer_to_heap(obj->as.node.u1.node)) {
-		gc_mark((VALUE)obj->as.node.u1.node, lev);
+		gc_mark((VALUE)obj->as.node.u1.node);
 	    }
 	    if (is_pointer_to_heap(obj->as.node.u2.node)) {
-		gc_mark((VALUE)obj->as.node.u2.node, lev);
+		gc_mark((VALUE)obj->as.node.u2.node);
 	    }
 	    if (is_pointer_to_heap(obj->as.node.u3.node)) {
-		gc_mark((VALUE)obj->as.node.u3.node, lev);
+                ptr = (VALUE)obj->as.node.u3.node;
+                goto again;
 	    }
 	}
-	return;			/* no need to mark class. */
+        return;	/* no need to mark class. */
     }
 
-    gc_mark(obj->as.basic.klass, lev);
+    gc_mark(obj->as.basic.klass);
     switch (obj->as.basic.flags & T_MASK) {
       case T_ICLASS:
       case T_CLASS:
       case T_MODULE:
-	mark_tbl(obj->as.klass.m_tbl, lev);
-	mark_tbl(obj->as.klass.iv_tbl, lev);
+	mark_tbl(obj->as.klass.m_tbl);
+	mark_tbl(obj->as.klass.iv_tbl);
 	ptr = obj->as.klass.super;
 	goto again;
 
@@ -999,17 +1542,16 @@
 	    goto again;
 	}
 	else {
-	    long i, len = obj->as.array.len;
 	    VALUE *ptr = obj->as.array.ptr;
-
-	    for (i=0; i < len; i++) {
-		gc_mark(*ptr++, lev);
+            VALUE *pend = ptr + obj->as.array.len;
+	    while (ptr < pend) {
+		gc_mark(*ptr++);
 	    }
 	}
 	break;
 
       case T_HASH:
-	mark_hash(obj->as.hash.tbl, lev);
+	mark_hash(obj->as.hash.tbl);
 	ptr = obj->as.hash.ifnone;
 	goto again;
 
@@ -1026,7 +1568,7 @@
 	break;
 
       case T_OBJECT:
-	mark_tbl(obj->as.object.iv_tbl, lev);
+	mark_tbl(obj->as.object.iv_tbl);
 	break;
 
       case T_FILE:
@@ -1044,7 +1586,7 @@
 	break;
 
       case T_VARMAP:
-	gc_mark(obj->as.varmap.val, lev);
+	gc_mark(obj->as.varmap.val);
 	ptr = (VALUE)obj->as.varmap.next;
 	goto again;
 
@@ -1054,19 +1596,17 @@
 	    VALUE *vars = &obj->as.scope.local_vars[-1];
 
 	    while (n--) {
-		gc_mark(*vars++, lev);
+		gc_mark(*vars++);
 	    }
 	}
 	break;
 
       case T_STRUCT:
 	{
-	    long len = obj->as.rstruct.len;
 	    VALUE *ptr = obj->as.rstruct.ptr;
-
-	    while (len--) {
-		gc_mark(*ptr++, lev);
-	    }
+            VALUE *pend = ptr + obj->as.rstruct.len;
+            while (ptr < pend)
+	       gc_mark(*ptr++);
 	}
 	break;
 
@@ -1083,8 +1623,13 @@
 add_freelist(p)
     RVALUE *p;
 {
-    p->as.free.flags = 0;
-    p->as.free.next = freelist;
+    /* Do not touch the fields if they don't have to be modified.
+     * This is in order to preserve copy-on-write semantics.
+     */
+    if (p->as.free.flags != 0)
+	p->as.free.flags = 0;
+    if (p->as.free.next != freelist)
+	p->as.free.next = freelist;
     freelist = p;
 }
 
@@ -1095,13 +1640,51 @@
     while (p) {
 	RVALUE *tmp = p->as.free.next;
 	run_final((VALUE)p);
-	if (!FL_TEST(p, FL_SINGLETON)) { /* not freeing page */
+	/* Don't free objects that are singletons, or objects that are already freed.
+	 * The latter is to prevent the unnecessary marking of memory pages as dirty,
+	 * which can destroy copy-on-write semantics.
+	 */
+	if (!FL_TEST(p, FL_SINGLETON)) {
+	    rb_mark_table_remove(p);
 	    add_freelist(p);
 	}
 	p = tmp;
     }
 }
 
+static char* obj_type(int tp)
+{
+    switch (tp) {
+	case T_NIL    : return "NIL";   
+	case T_OBJECT : return "OBJECT";
+	case T_CLASS  : return "CLASS";
+	case T_ICLASS : return "ICLASS";
+	case T_MODULE : return "MODULE";
+	case T_FLOAT  : return "FLOAT";
+	case T_STRING : return "STRING";
+	case T_REGEXP : return "REGEXP";
+	case T_ARRAY  : return "ARRAY";
+	case T_FIXNUM : return "FIXNUM";
+	case T_HASH   : return "HASH";
+	case T_STRUCT : return "STRUCT";
+	case T_BIGNUM : return "BIGNUM";
+	case T_FILE   : return "FILE";
+	    
+	case T_TRUE   : return "TRUE";
+	case T_FALSE  : return "FALSE";
+	case T_DATA   : return "DATA";
+	case T_MATCH  : return "MATCH";
+	case T_SYMBOL : return "SYMBOL";
+	    
+	case T_BLKTAG : return "BLKTAG";
+	case T_UNDEF  : return "UNDEF";
+	case T_VARMAP : return "VARMAP";
+	case T_SCOPE  : return "SCOPE";
+	case T_NODE   : return "NODE";
+	default: return "____";
+    }
+}
+
 static void
 free_unused_heaps()
 {
@@ -1109,7 +1692,8 @@
 
     for (i = j = 1; j < heaps_used; i++) {
 	if (heaps[i].limit == 0) {
-	    free(heaps[i].membase);
+	    free_ruby_heap(heaps[i].membase);
+	    free(heaps[i].marks);
 	    heaps_used--;
 	}
 	else {
@@ -1121,8 +1705,6 @@
     }
 }
 
-#define T_DEFERRED 0x3a
-
 void rb_gc_abort_threads(void);
 
 static void
@@ -1131,24 +1713,38 @@
     RVALUE *p, *pend, *final_list;
     int freed = 0;
     int i;
-    unsigned long live = 0;
     unsigned long free_min = 0;
+    struct heaps_slot *heap;
+
+    unsigned long really_freed = 0;
+    int free_counts[256];
+    int live_counts[256];
+    int do_gc_stats = gc_statistics & verbose_gc_stats;
+
+    live_objects = 0;
 
     for (i = 0; i < heaps_used; i++) {
         free_min += heaps[i].limit;
     }
-    free_min = free_min * 0.2;
-    if (free_min < FREE_MIN)
-        free_min = FREE_MIN;
+    free_min /= 5;
+    if (free_min < heap_free_min)
+        free_min = heap_free_min;
+
+    if (do_gc_stats) {
+	for (i = 0 ; i< 256; i++) {
+	    free_counts[i] = live_counts[i] = 0;
+	}
+    }
 
     if (ruby_in_compile && ruby_parser_stack_on_heap()) {
 	/* should not reclaim nodes during compilation
            if yacc's semantic stack is not allocated on machine stack */
 	for (i = 0; i < heaps_used; i++) {
-	    p = heaps[i].slot; pend = p + heaps[i].limit;
+	    heap = &heaps[i];
+	    p = heap->slot; pend = p + heap->limit;
 	    while (p < pend) {
-		if (!(p->as.basic.flags&FL_MARK) && BUILTIN_TYPE(p) == T_NODE)
-		    gc_mark((VALUE)p, 0);
+		if (!rb_mark_table_heap_contains(heap, p) && BUILTIN_TYPE(p) == T_NODE)
+		    gc_mark((VALUE)p);
 		p++;
 	    }
 	}
@@ -1168,21 +1764,42 @@
 	RVALUE *final = final_list;
 	int deferred;
 
-	p = heaps[i].slot; pend = p + heaps[i].limit;
+	heap = &heaps[i];
+	p = heap->slot; pend = p + heap->limit;
 	while (p < pend) {
-	    if (!(p->as.basic.flags & FL_MARK)) {
-		if (p->as.basic.flags &&
-		    ((deferred = obj_free((VALUE)p)) ||
-		     ((FL_TEST(p, FL_FINALIZE)) && need_call_final))) {
-		    if (!deferred) {
-			p->as.free.flags = T_DEFERRED;
-			RDATA(p)->dfree = 0;
+	    if (!rb_mark_table_heap_contains(heap, p)) {
+		if (p->as.basic.flags) {
+		    if (do_gc_stats) {
+			really_freed++;
+		    }
+		    if ((deferred = obj_free((VALUE)p)) ||
+		        ((FL_TEST(p, FL_FINALIZE)) && need_call_final)) {
+			/* This object has a finalizer, so don't free it right now, but do it later. */
+			if (!deferred) {
+			    p->as.free.flags = T_DEFERRED;
+			    RDATA(p)->dfree = 0;
+			}
+			rb_mark_table_heap_add(heap, p); /* remain marked */
+			p->as.free.next = final_list;
+			final_list = p;
+		    }
+		    else {
+			if (do_gc_stats) {
+			    int builtin_type = BUILTIN_TYPE(p);
+			    if (builtin_type) {
+				free_counts[builtin_type]++;
+			    }
+			}
+			add_freelist(p);
 		    }
-		    p->as.free.flags |= FL_MARK;
-		    p->as.free.next = final_list;
-		    final_list = p;
 		}
 		else {
+		    if (do_gc_stats) {
+			int builtin_type = BUILTIN_TYPE(p);
+			if (builtin_type) {
+			    free_counts[builtin_type]++;
+			}
+		    }
 		    add_freelist(p);
 		}
 		n++;
@@ -1192,8 +1809,11 @@
 		/* do nothing remain marked */
 	    }
 	    else {
-		RBASIC(p)->flags &= ~FL_MARK;
-		live++;
+		rb_mark_table_heap_remove(heap, p);
+		live_objects++;
+		if (do_gc_stats) {
+		    live_counts[BUILTIN_TYPE(p)]++;
+		}
 	    }
 	    p++;
 	}
@@ -1201,6 +1821,7 @@
 	    RVALUE *pp;
 
 	    heaps[i].limit = 0;
+	    heaps[i].slotlimit = heaps[i].slot;
 	    for (pp = final_list; pp != final; pp = pp->as.free.next) {
 		pp->as.free.flags |= FL_SINGLETON; /* freeing page mark */
 	    }
@@ -1210,15 +1831,26 @@
 	    freed += n;
 	}
     }
-    if (malloc_increase > malloc_limit) {
-	malloc_limit += (malloc_increase - malloc_limit) * (double)live / (live + freed);
-	if (malloc_limit < GC_MALLOC_LIMIT) malloc_limit = GC_MALLOC_LIMIT;
-    }
     malloc_increase = 0;
     if (freed < free_min) {
 	add_heap();
     }
     during_gc = 0;
+    
+    if (do_gc_stats) {
+	fprintf(gc_data_file, "objects processed: %.7d\n", live_objects+freed);
+	fprintf(gc_data_file, "live objects	: %.7d\n", live_objects);
+	fprintf(gc_data_file, "freelist objects : %.7d\n", freed - really_freed);
+	fprintf(gc_data_file, "freed objects	: %.7d\n", really_freed);
+	for(i = 0; i < 256; i++) {
+	    if (free_counts[i] > 0) {
+		fprintf(gc_data_file,
+			"kept %.7d / freed %.7d objects of type %s\n",
+			live_counts[i], free_counts[i], obj_type(i));
+	    }
+	}
+    }
+
 
     /* clear finalization list */
     if (final_list) {
@@ -1241,6 +1873,7 @@
 rb_gc_force_recycle(p)
     VALUE p;
 {
+    rb_mark_table_remove((RVALUE *) p);
     add_freelist(RANY(p));
 }
 
@@ -1387,7 +2020,7 @@
 rb_gc_mark_frame(frame)
     struct FRAME *frame;
 {
-    gc_mark((VALUE)frame->node, 0);
+    gc_mark((VALUE)frame->node);
 }
 
 #ifdef __GNUC__
@@ -1425,12 +2058,14 @@
 #endif /* __human68k__ or DJGPP */
 #endif /* __GNUC__ */
 
+
+
 static void
-garbage_collect()
+garbage_collect_0(VALUE *top_frame)
 {
     struct gc_list *list;
-    struct FRAME * volatile frame; /* gcc 2.7.2.3 -O2 bug??  */
-    jmp_buf save_regs_gc_mark;
+    struct FRAME * frame;
+    struct timeval gctv1, gctv2;
     SET_STACK_END;
 
 #ifdef HAVE_NATIVETHREAD
@@ -1447,9 +2082,19 @@
     if (during_gc) return;
     during_gc++;
 
+    if (gc_statistics) {
+	gc_collections++;
+	gettimeofday(&gctv1, NULL);
+	if (verbose_gc_stats) {
+	    fprintf(gc_data_file, "Garbage collection started\n");
+	}
+    }
+
+    gc_stack_limit = __stack_grow(STACK_END, GC_LEVEL_MAX);
+    rb_mark_table_prepare();
     init_mark_stack();
 
-    gc_mark((VALUE)ruby_current_node, 0);
+    gc_mark((VALUE)ruby_current_node);
 
     /* mark frame stack */
     for (frame = ruby_frame; frame; frame = frame->prev) {
@@ -1462,25 +2107,21 @@
 	    }
 	}
     }
-    gc_mark((VALUE)ruby_scope, 0);
-    gc_mark((VALUE)ruby_dyna_vars, 0);
+    gc_mark((VALUE)ruby_scope);
+    gc_mark((VALUE)ruby_dyna_vars);
     if (finalizer_table) {
-	mark_tbl(finalizer_table, 0);
+	mark_tbl(finalizer_table);
     }
 
-    FLUSH_REGISTER_WINDOWS;
-    /* This assumes that all registers are saved into the jmp_buf (and stack) */
-    rb_setjmp(save_regs_gc_mark);
-    mark_locations_array((VALUE*)save_regs_gc_mark, sizeof(save_regs_gc_mark) / sizeof(VALUE *));
 #if STACK_GROW_DIRECTION < 0
-    rb_gc_mark_locations((VALUE*)STACK_END, rb_gc_stack_start);
+    rb_gc_mark_locations(top_frame, rb_curr_thread->stk_start);
 #elif STACK_GROW_DIRECTION > 0
-    rb_gc_mark_locations(rb_gc_stack_start, (VALUE*)STACK_END + 1);
+    rb_gc_mark_locations(rb_curr_thread->stk_start, top_frame + 1);
 #else
-    if ((VALUE*)STACK_END < rb_gc_stack_start)
-	rb_gc_mark_locations((VALUE*)STACK_END, rb_gc_stack_start);
+    if (rb_gc_stack_grow_direction < 0)
+	rb_gc_mark_locations(top_frame, rb_curr_thread->stk_start);
     else
-	rb_gc_mark_locations(rb_gc_stack_start, (VALUE*)STACK_END + 1);
+	rb_gc_mark_locations(rb_curr_thread->stk_start, top_frame + 1);
 #endif
 #ifdef __ia64
     /* mark backing store (flushed register window on the stack) */
@@ -1489,7 +2130,7 @@
 #endif
 #if defined(__human68k__) || defined(__mc68000__)
     rb_gc_mark_locations((VALUE*)((char*)STACK_END + 2),
-			 (VALUE*)((char*)rb_gc_stack_start + 2));
+			 (VALUE*)((char*)rb_curr_thread->stk_start + 2));
 #endif
     rb_gc_mark_threads();
 
@@ -1520,8 +2161,51 @@
 	}
 	rb_gc_abort_threads();
     } while (!MARK_STACK_EMPTY);
-
     gc_sweep();
+    rb_mark_table_finalize();
+    gc_cycles++;
+
+    if (gc_statistics) {
+	GC_TIME_TYPE musecs_used;
+	gettimeofday(&gctv2, NULL);
+	musecs_used = ((GC_TIME_TYPE)(gctv2.tv_sec - gctv1.tv_sec) * 1000000) + (gctv2.tv_usec - gctv1.tv_usec);
+	gc_time += musecs_used;
+
+	if (verbose_gc_stats) {
+	    fprintf(gc_data_file, "GC time: %d msec\n", musecs_used / 1000);
+	}
+    }
+}
+
+static void
+garbage_collect()
+{
+  jmp_buf save_regs_gc_mark;
+  VALUE *top = __sp();
+  FLUSH_REGISTER_WINDOWS;
+  /* This assumes that all registers are saved into the jmp_buf (and stack) */
+  rb_setjmp(save_regs_gc_mark);
+
+#if STACK_WIPE_SITES & 0x400
+# ifdef nativeAllocA
+  if (__stack_past (top, stack_limit)) {
+  /* allocate a large frame to ensure app stack cannot grow into GC stack */
+    (void)(volatile void*) 
+    nativeAllocA(__stack_depth((void*)stack_limit,(void*)top));
+  }  
+  garbage_collect_0(top);
+# else /* no native alloca() available */
+  garbage_collect_0(top);
+  {
+    VALUE *paddedLimit = __stack_grow(gc_stack_limit, GC_STACK_PAD);
+    if (__stack_past(rb_gc_stack_end, paddedLimit))
+      rb_gc_stack_end = paddedLimit;
+  }
+  rb_gc_wipe_stack();  /* wipe the whole stack area reserved for this gc */  
+# endif
+#else
+  garbage_collect_0(top);
+#endif
 }
 
 void
@@ -1548,6 +2232,18 @@
     return Qnil;
 }
 
+
+int
+rb_gc_is_thread_marked(the_thread)
+    VALUE the_thread;
+{
+    if (FL_ABLE(the_thread)) {
+	return rb_mark_table_contains((RVALUE *) the_thread);
+    } else {
+	return 0;
+    }
+}
+
 void
 ruby_set_stack_size(size)
     size_t size;
@@ -1555,6 +2251,29 @@
 #ifndef STACK_LEVEL_MAX
     STACK_LEVEL_MAX = size / sizeof(VALUE);
 #endif
+    stack_limit = __stack_grow(rb_gc_stack_start, STACK_LEVEL_MAX-GC_STACK_MAX);
+}
+
+static void
+set_stack_size(void)
+{
+#ifdef HAVE_GETRLIMIT
+  struct rlimit rlim;
+  if (getrlimit(RLIMIT_STACK, &rlim) == 0) {
+    if (rlim.rlim_cur > 0 && rlim.rlim_cur != RLIM_INFINITY) {
+      size_t maxStackBytes = rlim.rlim_cur;
+      if (rlim.rlim_cur != maxStackBytes)
+        maxStackBytes = -1;
+      {
+        size_t space = maxStackBytes/5;
+        if (space > 1024*1024) space = 1024*1024;
+        ruby_set_stack_size(maxStackBytes - space);
+        return;
+      }
+    }
+  }
+#endif
+  ruby_set_stack_size(STACK_LEVEL_MAX*sizeof(VALUE));
 }
 
 void
@@ -1588,7 +2307,7 @@
     memset(&m, 0, sizeof(m));
     VirtualQuery(&m, &m, sizeof(m));
     rb_gc_stack_start =
-	STACK_UPPER((VALUE *)&m, (VALUE *)m.BaseAddress,
+	STACK_UPPER((VALUE *)m.BaseAddress,
 		    (VALUE *)((char *)m.BaseAddress + m.RegionSize) - 1);
 #elif defined(STACK_END_ADDRESS)
     {
@@ -1597,28 +2316,16 @@
     }
 #else
     if (!addr) addr = (void *)&addr;
-    STACK_UPPER(&addr, addr, ++addr);
+    STACK_UPPER(addr, ++addr);
     if (rb_gc_stack_start) {
-	if (STACK_UPPER(&addr,
-			rb_gc_stack_start > addr,
+	if (STACK_UPPER(rb_gc_stack_start > addr,
 			rb_gc_stack_start < addr))
 	    rb_gc_stack_start = addr;
 	return;
     }
     rb_gc_stack_start = addr;
 #endif
-#ifdef HAVE_GETRLIMIT
-    {
-	struct rlimit rlim;
-
-	if (getrlimit(RLIMIT_STACK, &rlim) == 0) {
-	    unsigned int space = rlim.rlim_cur/5;
-
-	    if (space > 1024*1024) space = 1024*1024;
-	    STACK_LEVEL_MAX = (rlim.rlim_cur - space) / sizeof(VALUE);
-	}
-    }
-#endif
+    set_stack_size();
 }
 
 void ruby_init_stack(VALUE *addr
@@ -1628,8 +2335,7 @@
     )
 {
     if (!rb_gc_stack_start ||
-        STACK_UPPER(&addr,
-                    rb_gc_stack_start > addr,
+        STACK_UPPER(rb_gc_stack_start > addr,
                     rb_gc_stack_start < addr)) {
         rb_gc_stack_start = addr;
     }
@@ -1640,16 +2346,7 @@
     }
 #endif
 #ifdef HAVE_GETRLIMIT
-    {
-        struct rlimit rlim;
-
-        if (getrlimit(RLIMIT_STACK, &rlim) == 0) {
-            unsigned int space = rlim.rlim_cur/5;
-
-            if (space > 1024*1024) space = 1024*1024;
-            STACK_LEVEL_MAX = (rlim.rlim_cur - space) / sizeof(VALUE);
-        }
-    }
+    set_stack_size();
 #elif defined _WIN32
     {
 	MEMORY_BASIC_INFORMATION mi;
@@ -1660,7 +2357,7 @@
 	    size = (char *)mi.BaseAddress - (char *)mi.AllocationBase;
 	    space = size / 5;
 	    if (space > 1024*1024) space = 1024*1024;
-	    STACK_LEVEL_MAX = (size - space) / sizeof(VALUE);
+	    ruby_set_stack_size(size - space);
 	}
     }
 #endif
@@ -1700,9 +2397,13 @@
 void
 Init_heap()
 {
+    rb_gc_init_debugging((VALUE) NULL);
+    rb_use_fast_mark_table();
+    rb_mark_table_init();
     if (!rb_gc_stack_start) {
 	Init_stack(0);
     }
+    set_gc_parameters();
     add_heap();
 }
 
@@ -1989,6 +2690,7 @@
 rb_gc_call_finalizer_at_exit()
 {
     RVALUE *p, *pend;
+    struct heaps_slot *heap;
     int i;
 
     /* run finalizers */
@@ -2013,12 +2715,14 @@
     }
     /* run data object's finalizers */
     for (i = 0; i < heaps_used; i++) {
-	p = heaps[i].slot; pend = p + heaps[i].limit;
+	heap = &heaps[i];
+	p = heap->slot; pend = p + heap->limit;
 	while (p < pend) {
 	    if (BUILTIN_TYPE(p) == T_DATA &&
 		DATA_PTR(p) && RANY(p)->as.data.dfree &&
 		RANY(p)->as.basic.klass != rb_cThread) {
 		p->as.free.flags = 0;
+		rb_mark_table_heap_remove(heap, p);
 		if ((long)RANY(p)->as.data.dfree == -1) {
 		    RUBY_CRITICAL(free(DATA_PTR(p)));
 		}
@@ -2028,6 +2732,7 @@
 	    }
 	    else if (BUILTIN_TYPE(p) == T_FILE) {
 		p->as.free.flags = 0;
+		rb_mark_table_heap_remove(heap, p);
 		rb_io_fptr_finalize(RANY(p)->as.file.fptr);
 	    }
 	    p++;
@@ -2147,6 +2852,218 @@
     return (VALUE)((long)obj|FIXNUM_FLAG);
 }
 
+static VALUE
+os_statistics()
+{
+    int i;
+    int n = 0;
+    unsigned int objects = 0;
+    unsigned int total_objects_size = 0;
+    unsigned int total_heap_size = 0;
+    unsigned int total_heap_slots = 0;
+    unsigned int ast_nodes = 0;
+    char message[1024];
+    unsigned int total_leading_free_slots = 0;
+    unsigned int total_trailing_free_slots = 0;
+    const unsigned int group_size = 16;
+    unsigned int contiguous_free_groups = 0;
+    unsigned int terminal_objects = 0; /* Number of objects that cannot possibly refer to other objects. */
+
+    for (i = 0; i < heaps_used; i++) {
+	RVALUE *p, *pend;
+	unsigned int leading_free_slots = 0;
+	unsigned int trailing_free_slots = 0;
+	unsigned int slot_index = 0;
+	unsigned int free_slots_in_current_group = 0;
+	enum { BEGIN, MIDDLE, END } mode = BEGIN;
+
+	p = heaps[i].slot;
+	pend = p + heaps[i].limit;
+	for (;p < pend; p++, slot_index++) {
+	    switch (mode) {
+	    case BEGIN:
+		if (p->as.basic.flags) {
+		    mode = MIDDLE;
+		} else {
+		    leading_free_slots++;
+		}
+		break;
+	    case MIDDLE:
+		if (p->as.basic.flags == 0) {
+		    mode = END;
+		    trailing_free_slots++;
+		}
+		break;
+	    case END:
+		if (p->as.basic.flags == 0) {
+		    trailing_free_slots++;
+		} else {
+		    trailing_free_slots = 0;
+		    mode = MIDDLE;
+		}
+		break;
+	    };
+	    
+	    if (slot_index % group_size == 0) {
+		if (free_slots_in_current_group == group_size) {
+		    contiguous_free_groups++;
+		}
+		free_slots_in_current_group = 0;
+	    }
+	    if (p->as.basic.flags == 0) {
+		free_slots_in_current_group++;
+	    }
+	    
+	    if (p->as.basic.flags) {
+		int isAST = 0;
+		switch (TYPE(p)) {
+		  case T_ICLASS:
+		  case T_VARMAP:
+		  case T_SCOPE:
+		  case T_NODE:
+		    isAST = 1;
+		    break;
+		  case T_CLASS:
+		    if (FL_TEST(p, FL_SINGLETON)) {
+		        isAST = 1;
+		        break;
+		    }
+		  case T_FILE:
+		  case T_REGEXP:
+		  case T_FLOAT:
+		  case T_BIGNUM:
+		  case T_BLKTAG:
+		    terminal_objects++;
+		    break;
+		  default:
+		    break;
+		}
+		objects++;
+		if (isAST) {
+		   ast_nodes++;
+		}
+	    }
+	}
+	total_heap_size += (void *) pend - heaps[i].membase;
+	total_leading_free_slots += leading_free_slots;
+	total_trailing_free_slots += trailing_free_slots;
+    }
+
+    total_objects_size = objects * sizeof(RVALUE);
+    total_heap_slots = total_heap_size / sizeof(RVALUE);
+    snprintf(message, sizeof(message),
+        "Number of objects    : %d (%d AST nodes, %.2f%%)\n"
+        "Heap slot size       : %d\n"
+        "GC cycles so far     : %d\n"
+        "Number of heaps      : %d\n"
+        "Total size of objects: %.2f KB\n"
+        "Total size of heaps  : %.2f KB (%.2f KB = %.2f%% unused)\n"
+        "Leading free slots   : %d (%.2f KB = %.2f%%)\n"
+        "Trailing free slots  : %d (%.2f KB = %.2f%%)\n"
+        "Number of contiguous groups of %d slots: %d (%.2f%%)\n"
+        "Number of terminal objects: %d (%.2f%%)\n",
+        objects, ast_nodes, ast_nodes * 100 / (double) objects,
+        sizeof(RVALUE),
+        gc_cycles,
+        heaps_used,
+        total_objects_size / 1024.0,
+        total_heap_size / 1024.0,
+        (total_heap_size - total_objects_size) / 1024.0,
+        (total_heap_size - total_objects_size) * 100.0 / total_heap_size,
+        total_leading_free_slots,
+        total_leading_free_slots * sizeof(RVALUE) / 1024.0,
+        total_leading_free_slots * 100.0 / total_heap_slots,
+        total_trailing_free_slots,
+        total_trailing_free_slots * sizeof(RVALUE) / 1024.0,
+        total_trailing_free_slots * 100.0 / total_heap_slots,
+        group_size,
+        contiguous_free_groups,
+        (contiguous_free_groups * group_size * 100.0) / total_heap_slots,
+        terminal_objects,
+        terminal_objects * 100.0 / total_heap_slots
+    );
+    return rb_str_new2(message);
+}
+
+/*
+ *  call-seq:
+ *     GC.copy_on_write_friendly?     => true or false
+ *
+ *  Returns whether the garbage collector is copy-on-write friendly.
+ *
+ *  This method only has meaning on platforms that support the _fork_ system call.
+ *  Please consult the documentation for GC.copy_on_write_friendly= for additional
+ *  notes.
+ */
+static VALUE
+rb_gc_copy_on_write_friendly()
+{
+    if (rb_mark_table_init == rb_fast_mark_table_init) {
+	return Qfalse;
+    } else {
+	return Qtrue;
+    }
+}
+
+/*
+ *  call-seq:
+ *     GC.copy_on_write_friendly = _boolean_
+ *
+ *  Tell the garbage collector whether to be copy-on-write friendly.
+ *
+ *  Note that this is an implementation detail of the garbage collector. On some Ruby
+ *  implementations, the garbage collector may always be copy-on-write friendly. In that
+ *  case, this method will do nothing. Furthermore, copy-on-write friendliness has no
+ *  meaning on some platforms (such as Microsoft Windows), so setting this flag on those
+ *  platform is futile.
+ *
+ *  Please keep in mind that this flag is only advisory. Do not rely on it for anything
+ *  truly important.
+ *
+ *  In the mainline Ruby implementation, the copy-on-write friendly garbage collector is
+ *  slightly slower the non-copy-on-write friendly version.
+ */
+static VALUE
+rb_gc_set_copy_on_write_friendly(VALUE self, VALUE val)
+{
+    if (RTEST(val)) {
+	rb_use_bf_mark_table();
+    } else {
+	rb_use_fast_mark_table();
+    }
+    rb_mark_table_init();
+    return Qnil;
+}
+
+/* call-seq:
+ *  ObjectSpace.live_objects => number
+ *
+ * Returns the count of objects currently allocated in the system. This goes
+ * down after the garbage collector runs.
+ */
+static
+VALUE os_live_objects(VALUE self)
+{ return ULONG2NUM(live_objects); }
+
+/* call-seq:
+ *  ObjectSpace.allocated_objects => number
+ *
+ * Returns the count of objects allocated since the Ruby interpreter has
+ * started.  This number can only increase. To know how many objects are
+ * currently allocated, use ObjectSpace::live_objects
+ */
+static
+VALUE os_allocated_objects(VALUE self)
+{
+#if defined(HAVE_LONG_LONG)
+    return ULL2NUM(allocated_objects);
+#else
+    return ULONG2NUM(allocated_objects);
+#endif
+}
+
+
+
 /*
  *  The <code>GC</code> module provides an interface to Ruby's mark and
  *  sweep garbage collection mechanism. Some of the underlying methods
@@ -2158,13 +3075,35 @@
 {
     VALUE rb_mObSpace;
 
+#if !STACK_GROW_DIRECTION
+    rb_gc_stack_end = stack_grow_direction(&rb_mObSpace);
+#endif
     rb_mGC = rb_define_module("GC");
     rb_define_singleton_method(rb_mGC, "start", rb_gc_start, 0);
     rb_define_singleton_method(rb_mGC, "enable", rb_gc_enable, 0);
     rb_define_singleton_method(rb_mGC, "disable", rb_gc_disable, 0);
+#ifdef MBARI_API
+    rb_define_singleton_method(rb_mGC, "limit", gc_getlimit, 0);
+    rb_define_singleton_method(rb_mGC, "limit=", gc_setlimit, 1);
+    rb_define_singleton_method(rb_mGC, "growth", gc_growth, 0);
+    rb_define_singleton_method(rb_mGC, "exorcise", gc_exorcise, 0);
+#endif
     rb_define_singleton_method(rb_mGC, "stress", gc_stress_get, 0);
     rb_define_singleton_method(rb_mGC, "stress=", gc_stress_set, 1);
     rb_define_method(rb_mGC, "garbage_collect", rb_gc_start, 0);
+    rb_define_singleton_method(rb_mGC, "initialize_debugging", rb_gc_init_debugging, 0);
+    rb_define_singleton_method(rb_mGC, "copy_on_write_friendly?", rb_gc_copy_on_write_friendly, 0);
+    rb_define_singleton_method(rb_mGC, "copy_on_write_friendly=", rb_gc_set_copy_on_write_friendly, 1);
+    
+    rb_define_singleton_method(rb_mGC, "enable_stats", rb_gc_enable_stats, 0);
+    rb_define_singleton_method(rb_mGC, "disable_stats", rb_gc_disable_stats, 0);
+    rb_define_singleton_method(rb_mGC, "clear_stats", rb_gc_clear_stats, 0);
+    rb_define_singleton_method(rb_mGC, "allocated_size", rb_gc_allocated_size, 0);
+    rb_define_singleton_method(rb_mGC, "num_allocations", rb_gc_num_allocations, 0);
+    rb_define_singleton_method(rb_mGC, "collections", rb_gc_collections, 0);
+    rb_define_singleton_method(rb_mGC, "time", rb_gc_time, 0);
+    rb_define_singleton_method(rb_mGC, "dump", rb_gc_dump, 0);
+    rb_define_singleton_method(rb_mGC, "log", rb_gc_log, 1);
 
     rb_mObSpace = rb_define_module("ObjectSpace");
     rb_define_module_function(rb_mObSpace, "each_object", os_each_obj, -1);
@@ -2173,12 +3112,16 @@
     rb_define_module_function(rb_mObSpace, "remove_finalizer", rm_final, 1);
     rb_define_module_function(rb_mObSpace, "finalizers", finals, 0);
     rb_define_module_function(rb_mObSpace, "call_finalizer", call_final, 1);
+    rb_define_module_function(rb_mObSpace, "live_objects", os_live_objects, 0);
+    rb_define_module_function(rb_mObSpace, "allocated_objects", os_allocated_objects, 0);
 
     rb_define_module_function(rb_mObSpace, "define_finalizer", define_final, -1);
     rb_define_module_function(rb_mObSpace, "undefine_finalizer", undefine_final, 1);
 
     rb_define_module_function(rb_mObSpace, "_id2ref", id2ref, 1);
 
+    rb_define_module_function(rb_mObSpace, "statistics", os_statistics, 0);
+
     rb_gc_register_address(&rb_mObSpace);
     rb_global_variable(&finalizers);
     rb_gc_unregister_address(&rb_mObSpace);
--- a/intern.h
+++ b/intern.h
@@ -253,7 +253,7 @@
 /* gc.c */
 NORETURN(void rb_memerror __((void)));
 int ruby_stack_check _((void));
-size_t ruby_stack_length _((VALUE**));
+size_t ruby_stack_length _((VALUE *,VALUE**));
 int rb_during_gc _((void));
 char *rb_source_filename _((const char*));
 void rb_gc_mark_locations _((VALUE*, VALUE*));
@@ -270,6 +270,16 @@
 VALUE rb_gc_enable _((void));
 VALUE rb_gc_disable _((void));
 VALUE rb_gc_start _((void));
+void rb_gc_unstress _((void));
+VALUE rb_gc_enable_stats _((void));
+VALUE rb_gc_disable_stats _((void));
+VALUE rb_gc_allocated_size _((void));
+unsigned long rb_os_live_objects _((void));
+#ifdef HAVE_LONG_LONG
+unsigned long long rb_os_allocated_objects _((void));
+#else
+unsigned long rb_os_allocated_objects _((void));
+#endif
 /* hash.c */
 void st_foreach_safe _((struct st_table *, int (*)(ANYARGS), unsigned long));
 void rb_hash_foreach _((VALUE, int (*)(ANYARGS), VALUE));
--- a/lib/mkmf.rb
+++ b/lib/mkmf.rb
@@ -1314,7 +1314,7 @@
 
 RUBY_EXTCONF_H = #{$extconf_h}
 CFLAGS   = #{$static ? '' : CONFIG['CCDLFLAGS']} #$CFLAGS #$ARCH_FLAG
-INCFLAGS = -I. #$INCFLAGS
+INCFLAGS = $(PREINCFLAGS) -I. #$INCFLAGS
 DEFS     = #{CONFIG['DEFS']}
 CPPFLAGS = #{extconf_h}#{$CPPFLAGS}
 CXXFLAGS = $(CFLAGS) #{CONFIG['CXXFLAGS']}
@@ -1702,11 +1702,11 @@
   $ARCH_FLAG = with_config("arch_flag", arg_config("ARCH_FLAG", config["ARCH_FLAG"])).dup
   $CPPFLAGS = with_config("cppflags", arg_config("CPPFLAGS", config["CPPFLAGS"])).dup
   $LDFLAGS = with_config("ldflags", arg_config("LDFLAGS", config["LDFLAGS"])).dup
-  $INCFLAGS = "-I$(topdir) -I$(hdrdir) -I$(srcdir)"
+  $INCFLAGS = "-I/opt/local/include -I$(topdir) -I$(hdrdir) -I$(srcdir)"
   $DLDFLAGS = with_config("dldflags", arg_config("DLDFLAGS", config["DLDFLAGS"])).dup
   $LIBEXT = config['LIBEXT'].dup
   $OBJEXT = config["OBJEXT"].dup
-  $LIBS = "#{config['LIBS']} #{config['DLDLIBS']}"
+  $LIBS = "-L/opt/local/lib #{config['LIBS']} #{config['DLDLIBS']}"
   $LIBRUBYARG = ""
   $LIBRUBYARG_STATIC = config['LIBRUBYARG_STATIC']
   $LIBRUBYARG_SHARED = config['LIBRUBYARG_SHARED']
--- a/lib/rational.rb
+++ /dev/null
@@ -1,564 +0,0 @@
-#
-#   rational.rb -
-#       $Release Version: 0.5 $
-#       $Revision: 1.7 $
-#       $Date: 1999/08/24 12:49:28 $
-#       by Keiju ISHITSUKA(SHL Japan Inc.)
-#
-# Documentation by Kevin Jackson and Gavin Sinclair.
-# 
-# When you <tt>require 'rational'</tt>, all interactions between numbers
-# potentially return a rational result.  For example:
-#
-#   1.quo(2)              # -> 0.5
-#   require 'rational'
-#   1.quo(2)              # -> Rational(1,2)
-# 
-# See Rational for full documentation.
-#
-
-
-#
-# Creates a Rational number (i.e. a fraction).  +a+ and +b+ should be Integers:
-# 
-#   Rational(1,3)           # -> 1/3
-#
-# Note: trying to construct a Rational with floating point or real values
-# produces errors:
-#
-#   Rational(1.1, 2.3)      # -> NoMethodError
-#
-def Rational(a, b = 1)
-  if a.kind_of?(Rational) && b == 1
-    a
-  else
-    Rational.reduce(a, b)
-  end
-end
-
-#
-# Rational implements a rational class for numbers.
-#
-# <em>A rational number is a number that can be expressed as a fraction p/q
-# where p and q are integers and q != 0.  A rational number p/q is said to have
-# numerator p and denominator q.  Numbers that are not rational are called
-# irrational numbers.</em> (http://mathworld.wolfram.com/RationalNumber.html)
-#
-# To create a Rational Number:
-#   Rational(a,b)             # -> a/b
-#   Rational.new!(a,b)        # -> a/b
-#
-# Examples:
-#   Rational(5,6)             # -> 5/6
-#   Rational(5)               # -> 5/1
-# 
-# Rational numbers are reduced to their lowest terms:
-#   Rational(6,10)            # -> 3/5
-#
-# But not if you use the unusual method "new!":
-#   Rational.new!(6,10)       # -> 6/10
-#
-# Division by zero is obviously not allowed:
-#   Rational(3,0)             # -> ZeroDivisionError
-#
-class Rational < Numeric
-  @RCS_ID='-$Id: rational.rb,v 1.7 1999/08/24 12:49:28 keiju Exp keiju $-'
-
-  #
-  # Reduces the given numerator and denominator to their lowest terms.  Use
-  # Rational() instead.
-  #
-  def Rational.reduce(num, den = 1)
-    raise ZeroDivisionError, "denominator is zero" if den == 0
-
-    if den < 0
-      num = -num
-      den = -den
-    end
-    gcd = num.gcd(den)
-    num = num.div(gcd)
-    den = den.div(gcd)
-    if den == 1 && defined?(Unify)
-      num
-    else
-      new!(num, den)
-    end
-  end
-
-  #
-  # Implements the constructor.  This method does not reduce to lowest terms or
-  # check for division by zero.  Therefore #Rational() should be preferred in
-  # normal use.
-  #
-  def Rational.new!(num, den = 1)
-    new(num, den)
-  end
-
-  private_class_method :new
-
-  #
-  # This method is actually private.
-  #
-  def initialize(num, den)
-    if den < 0
-      num = -num
-      den = -den
-    end
-    if num.kind_of?(Integer) and den.kind_of?(Integer)
-      @numerator = num
-      @denominator = den
-    else
-      @numerator = num.to_i
-      @denominator = den.to_i
-    end
-  end
-
-  #
-  # Returns the addition of this value and +a+.
-  #
-  # Examples:
-  #   r = Rational(3,4)      # -> Rational(3,4)
-  #   r + 1                  # -> Rational(7,4)
-  #   r + 0.5                # -> 1.25
-  #
-  def + (a)
-    if a.kind_of?(Rational)
-      num = @numerator * a.denominator
-      num_a = a.numerator * @denominator
-      Rational(num + num_a, @denominator * a.denominator)
-    elsif a.kind_of?(Integer)
-      self + Rational.new!(a, 1)
-    elsif a.kind_of?(Float)
-      Float(self) + a
-    else
-      x, y = a.coerce(self)
-      x + y
-    end
-  end
-
-  #
-  # Returns the difference of this value and +a+.
-  # subtracted.
-  #
-  # Examples:
-  #   r = Rational(3,4)    # -> Rational(3,4)
-  #   r - 1                # -> Rational(-1,4)
-  #   r - 0.5              # -> 0.25
-  #
-  def - (a)
-    if a.kind_of?(Rational)
-      num = @numerator * a.denominator
-      num_a = a.numerator * @denominator
-      Rational(num - num_a, @denominator*a.denominator)
-    elsif a.kind_of?(Integer)
-      self - Rational.new!(a, 1)
-    elsif a.kind_of?(Float)
-      Float(self) - a
-    else
-      x, y = a.coerce(self)
-      x - y
-    end
-  end
-
-  #
-  # Returns the product of this value and +a+.
-  #
-  # Examples:
-  #   r = Rational(3,4)    # -> Rational(3,4)
-  #   r * 2                # -> Rational(3,2)
-  #   r * 4                # -> Rational(3,1)
-  #   r * 0.5              # -> 0.375
-  #   r * Rational(1,2)    # -> Rational(3,8)
-  #
-  def * (a)
-    if a.kind_of?(Rational)
-      num = @numerator * a.numerator
-      den = @denominator * a.denominator
-      Rational(num, den)
-    elsif a.kind_of?(Integer)
-      self * Rational.new!(a, 1)
-    elsif a.kind_of?(Float)
-      Float(self) * a
-    else
-      x, y = a.coerce(self)
-      x * y
-    end
-  end
-
-  #
-  # Returns the quotient of this value and +a+.
-  #   r = Rational(3,4)    # -> Rational(3,4)
-  #   r / 2                # -> Rational(3,8)
-  #   r / 2.0              # -> 0.375
-  #   r / Rational(1,2)    # -> Rational(3,2)
-  #
-  def / (a)
-    if a.kind_of?(Rational)
-      num = @numerator * a.denominator
-      den = @denominator * a.numerator
-      Rational(num, den)
-    elsif a.kind_of?(Integer)
-      raise ZeroDivisionError, "division by zero" if a == 0
-      self / Rational.new!(a, 1)
-    elsif a.kind_of?(Float)
-      Float(self) / a
-    else
-      x, y = a.coerce(self)
-      x / y
-    end
-  end
-
-  #
-  # Returns this value raised to the given power.
-  #
-  # Examples:
-  #   r = Rational(3,4)    # -> Rational(3,4)
-  #   r ** 2               # -> Rational(9,16)
-  #   r ** 2.0             # -> 0.5625
-  #   r ** Rational(1,2)   # -> 0.866025403784439
-  #
-  def ** (other)
-    if other.kind_of?(Rational)
-      Float(self) ** other
-    elsif other.kind_of?(Integer)
-      if other > 0
-	num = @numerator ** other
-	den = @denominator ** other
-      elsif other < 0
-	num = @denominator ** -other
-	den = @numerator ** -other
-      elsif other == 0
-	num = 1
-	den = 1
-      end
-      Rational.new!(num, den)
-    elsif other.kind_of?(Float)
-      Float(self) ** other
-    else
-      x, y = other.coerce(self)
-      x ** y
-    end
-  end
-
-  def div(other)
-    (self / other).floor
-  end
-
-  #
-  # Returns the remainder when this value is divided by +other+.
-  #
-  # Examples:
-  #   r = Rational(7,4)    # -> Rational(7,4)
-  #   r % Rational(1,2)    # -> Rational(1,4)
-  #   r % 1                # -> Rational(3,4)
-  #   r % Rational(1,7)    # -> Rational(1,28)
-  #   r % 0.26             # -> 0.19
-  #
-  def % (other)
-    value = (self / other).floor
-    return self - other * value
-  end
-
-  #
-  # Returns the quotient _and_ remainder.
-  #
-  # Examples:
-  #   r = Rational(7,4)        # -> Rational(7,4)
-  #   r.divmod Rational(1,2)   # -> [3, Rational(1,4)]
-  #
-  def divmod(other)
-    value = (self / other).floor
-    return value, self - other * value
-  end
-
-  #
-  # Returns the absolute value.
-  #
-  def abs
-    if @numerator > 0
-      self
-    else
-      Rational.new!(-@numerator, @denominator)
-    end
-  end
-
-  #
-  # Returns +true+ iff this value is numerically equal to +other+.
-  #
-  # But beware:
-  #   Rational(1,2) == Rational(4,8)          # -> true
-  #   Rational(1,2) == Rational.new!(4,8)     # -> false
-  #
-  # Don't use Rational.new!
-  #
-  def == (other)
-    if other.kind_of?(Rational)
-      @numerator == other.numerator and @denominator == other.denominator
-    elsif other.kind_of?(Integer)
-      self == Rational.new!(other, 1)
-    elsif other.kind_of?(Float)
-      Float(self) == other
-    else
-      other == self
-    end
-  end
-
-  #
-  # Standard comparison operator.
-  #
-  def <=> (other)
-    if other.kind_of?(Rational)
-      num = @numerator * other.denominator
-      num_a = other.numerator * @denominator
-      v = num - num_a
-      if v > 0
-	return 1
-      elsif v < 0
-	return  -1
-      else
-	return 0
-      end
-    elsif other.kind_of?(Integer)
-      return self <=> Rational.new!(other, 1)
-    elsif other.kind_of?(Float)
-      return Float(self) <=> other
-    elsif defined? other.coerce
-      x, y = other.coerce(self)
-      return x <=> y
-    else
-      return nil
-    end
-  end
-
-  def coerce(other)
-    if other.kind_of?(Float)
-      return other, self.to_f
-    elsif other.kind_of?(Integer)
-      return Rational.new!(other, 1), self
-    else
-      super
-    end
-  end
-
-  #
-  # Converts the rational to an Integer.  Not the _nearest_ integer, the
-  # truncated integer.  Study the following example carefully:
-  #   Rational(+7,4).to_i             # -> 1
-  #   Rational(-7,4).to_i             # -> -1
-  #   (-1.75).to_i                    # -> -1
-  #
-  # In other words:
-  #   Rational(-7,4) == -1.75                 # -> true
-  #   Rational(-7,4).to_i == (-1.75).to_i     # -> true
-  #
-
-
-  def floor()
-    @numerator.div(@denominator)
-  end
-
-  def ceil()
-    -((-@numerator).div(@denominator))
-  end
-
-  def truncate()
-    if @numerator < 0
-      return -((-@numerator).div(@denominator))
-    end
-    @numerator.div(@denominator)
-  end
-
-  alias_method :to_i, :truncate
-
-  def round()
-    if @numerator < 0
-      num = -@numerator
-      num = num * 2 + @denominator
-      den = @denominator * 2
-      -(num.div(den))
-    else
-      num = @numerator * 2 + @denominator
-      den = @denominator * 2
-      num.div(den)
-    end
-  end
-
-  #
-  # Converts the rational to a Float.
-  #
-  def to_f
-    @numerator.fdiv(@denominator)
-  end
-
-  #
-  # Returns a string representation of the rational number.
-  #
-  # Example:
-  #   Rational(3,4).to_s          #  "3/4"
-  #   Rational(8).to_s            #  "8"
-  #
-  def to_s
-    if @denominator == 1
-      @numerator.to_s
-    else
-      @numerator.to_s+"/"+@denominator.to_s
-    end
-  end
-
-  #
-  # Returns +self+.
-  #
-  def to_r
-    self
-  end
-
-  #
-  # Returns a reconstructable string representation:
-  #
-  #   Rational(5,8).inspect     # -> "Rational(5, 8)"
-  #
-  def inspect
-    sprintf("Rational(%s, %s)", @numerator.inspect, @denominator.inspect)
-  end
-
-  #
-  # Returns a hash code for the object.
-  #
-  def hash
-    @numerator.hash ^ @denominator.hash
-  end
-
-  attr :numerator
-  attr :denominator
-
-  private :initialize
-end
-
-class Integer
-  #
-  # In an integer, the value _is_ the numerator of its rational equivalent.
-  # Therefore, this method returns +self+.
-  #
-  def numerator
-    self
-  end
-
-  #
-  # In an integer, the denominator is 1.  Therefore, this method returns 1.
-  #
-  def denominator
-    1
-  end
-
-  #
-  # Returns a Rational representation of this integer.
-  #
-  def to_r
-    Rational(self, 1)
-  end
-
-  #
-  # Returns the <em>greatest common denominator</em> of the two numbers (+self+
-  # and +n+).
-  #
-  # Examples:
-  #   72.gcd 168           # -> 24
-  #   19.gcd 36            # -> 1
-  #
-  # The result is positive, no matter the sign of the arguments.
-  #
-  def gcd(other)
-    min = self.abs
-    max = other.abs
-    while min > 0
-      tmp = min
-      min = max % min
-      max = tmp
-    end
-    max
-  end
-
-  #
-  # Returns the <em>lowest common multiple</em> (LCM) of the two arguments
-  # (+self+ and +other+).
-  #
-  # Examples:
-  #   6.lcm 7        # -> 42
-  #   6.lcm 9        # -> 18
-  #
-  def lcm(other)
-    if self.zero? or other.zero?
-      0
-    else
-      (self.div(self.gcd(other)) * other).abs
-    end
-  end
-
-  #
-  # Returns the GCD _and_ the LCM (see #gcd and #lcm) of the two arguments
-  # (+self+ and +other+).  This is more efficient than calculating them
-  # separately.
-  #
-  # Example:
-  #   6.gcdlcm 9     # -> [3, 18]
-  #
-  def gcdlcm(other)
-    gcd = self.gcd(other)
-    if self.zero? or other.zero?
-      [gcd, 0]
-    else
-      [gcd, (self.div(gcd) * other).abs]
-    end
-  end
-end
-
-class Fixnum
-  remove_method :quo
-
-  # If Rational is defined, returns a Rational number instead of a Float.
-  def quo(other)
-    Rational.new!(self, 1) / other
-  end
-  alias rdiv quo
-
-  # Returns a Rational number if the result is in fact rational (i.e. +other+ < 0).
-  def rpower (other)
-    if other >= 0
-      self.power!(other)
-    else
-      Rational.new!(self, 1)**other
-    end
-  end
-
-end
-
-class Bignum
-  remove_method :quo
-
-  # If Rational is defined, returns a Rational number instead of a Float.
-  def quo(other)
-    Rational.new!(self, 1) / other
-  end
-  alias rdiv quo
-
-  # Returns a Rational number if the result is in fact rational (i.e. +other+ < 0).
-  def rpower (other)
-    if other >= 0
-      self.power!(other)
-    else
-      Rational.new!(self, 1)**other
-    end
-  end
-
-end
-
-unless defined? 1.power!
-  class Fixnum
-    alias power! **
-    alias ** rpower
-  end
-  class Bignum
-    alias power! **
-    alias ** rpower
-  end
-end
--- /dev/null
+++ b/marktable.c
@@ -0,0 +1,205 @@
+/**
+ * A mark table, used during a mark-and-sweep garbage collection cycle.
+ *
+ * This implementation is somewhat slower than fastmarktable.c, but is
+ * copy-on-write friendly. It stores mark information for objects in a bit
+ * field located at the beginning of the heap. Mark information for filenames
+ * are stored in a pointer set.
+ */
+#ifndef _MARK_TABLE_C_
+#define _MARK_TABLE_C_
+
+#include "pointerset.h"
+
+/* A mark table for filenames and objects that are not on the heap. */
+static PointerSet *mark_table = NULL;
+static struct heaps_slot *last_heap = NULL;
+
+
+static inline struct heaps_slot *
+find_heap_slot_for_object(RVALUE *object)
+{
+	register int i;
+
+	/* Look in the cache first. */
+	if (last_heap != NULL && object >= last_heap->slot
+	 && object < last_heap->slotlimit) {
+		return last_heap;
+	}
+	for (i = 0; i < heaps_used; i++) {
+		struct heaps_slot *heap = &heaps[i];
+		if (object >= heap->slot
+		 && object < heap->slotlimit) {
+			/* Cache this result. According to empirical evidence, the chance is
+			 * high that the next lookup will be for the same heap slot.
+			 */
+			last_heap = heap;
+			return heap;
+		}
+	}
+	return NULL;
+}
+
+static inline void
+find_position_in_bitfield(struct heaps_slot *hs, RVALUE *object,
+                          unsigned int *bitfield_index, unsigned int *bitfield_offset)
+{
+	unsigned int index;
+	index = object - hs->slot;
+	
+	/*
+	 * We use bit operators to calculate the position in the bit field, whenever possible.
+	 * This only works if sizeof(int) is a multiple of 2, but I don't know of any platform
+	 * on which that is not true.
+	 */
+	if (sizeof(int) == 4 || sizeof(int) == 8 || sizeof(int) == 16) {
+		int int_bits_log; /* Must be equal to the base 2 logarithm of sizeof(int) * 8 */
+		
+		switch (sizeof(int)) {
+		case 4:
+			int_bits_log = 5;
+			break;
+		case 8:
+			int_bits_log = 6;
+			break;
+		case 16:
+			int_bits_log = 7;
+			break;
+		default:
+			int_bits_log = 0; /* Shut up compiler warning. */
+			abort();
+		}
+		*bitfield_index = index >> int_bits_log;
+		*bitfield_offset = index & ((sizeof(int) * 8) - 1);
+	} else {
+		*bitfield_index = index / (sizeof(int) * 8);
+		*bitfield_offset = index % (sizeof(int) * 8);
+	}
+}
+
+
+static void
+rb_bf_mark_table_init()
+{
+	if (mark_table == NULL) {
+		mark_table = pointer_set_new();
+	}
+}
+
+static void
+rb_bf_mark_table_prepare()
+{
+	last_heap = NULL;
+}
+
+static void
+rb_bf_mark_table_finalize()
+{
+	/* Do nothing. */
+}
+
+static inline void
+rb_bf_mark_table_add(RVALUE *object)
+{
+	struct heaps_slot *hs;
+	unsigned int bitfield_index, bitfield_offset;
+
+	hs = find_heap_slot_for_object(object);
+	if (hs != NULL) {
+		find_position_in_bitfield(hs, object, &bitfield_index, &bitfield_offset);
+		hs->marks[bitfield_index] |= (1 << bitfield_offset);
+	} else {
+		pointer_set_insert(mark_table, (void *) object);
+	}
+}
+
+static inline void
+rb_bf_mark_table_heap_add(struct heaps_slot *hs, RVALUE *object)
+{
+	unsigned int bitfield_index, bitfield_offset;
+	find_position_in_bitfield(hs, object, &bitfield_index, &bitfield_offset);
+	hs->marks[bitfield_index] |= (1 << bitfield_offset);
+}
+
+static inline int
+rb_bf_mark_table_contains(RVALUE *object)
+{
+	struct heaps_slot *hs;
+	unsigned int bitfield_index, bitfield_offset;
+
+	hs = find_heap_slot_for_object(object);
+	if (hs != NULL) {
+		find_position_in_bitfield(hs, object, &bitfield_index, &bitfield_offset);
+		return hs->marks[bitfield_index] & (1 << bitfield_offset);
+	} else {
+		return pointer_set_contains(mark_table, (void *) object);
+	}
+}
+
+static inline int
+rb_bf_mark_table_heap_contains(struct heaps_slot *hs, RVALUE *object)
+{
+	unsigned int bitfield_index, bitfield_offset;
+	find_position_in_bitfield(hs, object, &bitfield_index, &bitfield_offset);
+	last_heap = hs;
+	return hs->marks[bitfield_index] & (1 << bitfield_offset);
+}
+
+static inline void
+rb_bf_mark_table_remove(RVALUE *object)
+{
+	struct heaps_slot *hs;
+	unsigned int bitfield_index, bitfield_offset;
+
+	hs = find_heap_slot_for_object(object);
+	if (hs != NULL) {
+		find_position_in_bitfield(hs, object, &bitfield_index, &bitfield_offset);
+		hs->marks[bitfield_index] &= ~(1 << bitfield_offset);
+	} else {
+		pointer_set_delete(mark_table, (void *) object);
+	}
+}
+
+static inline void
+rb_bf_mark_table_heap_remove(struct heaps_slot *hs, RVALUE *object)
+{
+	unsigned int bitfield_index, bitfield_offset;
+	find_position_in_bitfield(hs, object, &bitfield_index, &bitfield_offset);
+	hs->marks[bitfield_index] &= ~(1 << bitfield_offset);
+}
+
+static inline void
+rb_bf_mark_table_add_filename(char *filename)
+{
+	pointer_set_insert(mark_table, (void *) filename);
+}
+
+static inline int
+rb_bf_mark_table_contains_filename(const char *filename)
+{
+	return pointer_set_contains(mark_table, (void *) filename);
+}
+
+static inline void
+rb_bf_mark_table_remove_filename(char *filename)
+{
+	pointer_set_delete(mark_table, (void *) filename);
+}
+
+static void
+rb_use_bf_mark_table() {
+	rb_mark_table_init          = rb_bf_mark_table_init;
+	rb_mark_table_prepare       = rb_bf_mark_table_prepare;
+	rb_mark_table_finalize      = rb_bf_mark_table_finalize;
+	rb_mark_table_add           = rb_bf_mark_table_add;
+	rb_mark_table_heap_add      = rb_bf_mark_table_heap_add;
+	rb_mark_table_contains      = rb_bf_mark_table_contains;
+	rb_mark_table_heap_contains = rb_bf_mark_table_heap_contains;
+	rb_mark_table_remove        = rb_bf_mark_table_remove;
+	rb_mark_table_heap_remove   = rb_bf_mark_table_heap_remove;
+	rb_mark_table_add_filename  = rb_bf_mark_table_add_filename;
+	rb_mark_table_contains_filename = rb_bf_mark_table_contains_filename;
+	rb_mark_table_remove_filename   = rb_bf_mark_table_remove_filename;
+}
+
+#endif /* _MARK_TABLE_C_ */
--- /dev/null
+++ b/marktable.h
@@ -0,0 +1,17 @@
+#ifndef _MARK_TABLE_H_
+#define _MARK_TABLE_H_
+
+static void (*rb_mark_table_init)();
+static void (*rb_mark_table_prepare)();
+static void (*rb_mark_table_finalize)();
+static void (*rb_mark_table_add)(RVALUE *object);
+static void (*rb_mark_table_heap_add)(struct heaps_slot *hs, RVALUE *object);
+static int  (*rb_mark_table_contains)(RVALUE *object);
+static int  (*rb_mark_table_heap_contains)(struct heaps_slot *hs, RVALUE *object);
+static void (*rb_mark_table_remove)(RVALUE *object);
+static void (*rb_mark_table_heap_remove)(struct heaps_slot *hs, RVALUE *object);
+static void (*rb_mark_table_add_filename)(char *filename);
+static int  (*rb_mark_table_contains_filename)(const char *filename);
+static void (*rb_mark_table_remove_filename)(char *filename);
+
+#endif /* _MARK_TABLE_H_ */
--- a/missing/alloca.c
+++ b/missing/alloca.c
@@ -29,6 +29,7 @@
 static char	SCCSid[] = "@(#)alloca.c	1.1";	/* for the "what" utility */
 #endif
 
+#include <sys/types.h>
 #include "config.h"
 #ifdef emacs
 #ifdef static
@@ -44,11 +45,7 @@
 #endif /* static */
 #endif /* emacs */
 
-#ifdef X3J11
 typedef void	*pointer;		/* generic pointer type */
-#else
-typedef char	*pointer;		/* generic pointer type */
-#endif /* X3J11 */
 
 #define	NULL	0			/* null pointer constant */
 
@@ -140,8 +137,7 @@
 static header *last_alloca_header = NULL; /* -> last alloca header */
 
 pointer
-alloca (size)			/* returns pointer to storage */
-     unsigned	size;		/* # bytes to allocate */
+alloca (size_t size)		/* returns pointer to storage */
 {
   auto char	probe;		/* probes stack depth: */
   register char	*depth = &probe;
--- a/node.h
+++ b/node.h
@@ -409,15 +409,11 @@
 
     VALUE result;
 
-    size_t stk_len;
-    size_t stk_max;
-    VALUE *stk_ptr;
-    VALUE *stk_pos;
+    size_t stk_len, stk_max;
+    VALUE *stk_ptr, *stk_pos, *stk_start;
 #ifdef __ia64
-    size_t bstr_len;
-    size_t bstr_max;
-    VALUE *bstr_ptr;
-    VALUE *bstr_pos;
+    size_t   bstr_len, bstr_max;
+    VALUE *bstr_ptr, *bstr_pos;
 #endif
 
     struct FRAME *frame;
--- /dev/null
+++ b/pointerset.c
@@ -0,0 +1,247 @@
+#include "config.h"
+#include "defines.h"
+#ifdef HAVE_STDLIB_H
+	#include <stdlib.h>
+#endif
+#include <string.h>
+#include "pointerset.h"
+
+
+typedef struct _PointerSetEntry PointerSetEntry;
+
+struct _PointerSet {
+	unsigned int num_bins;
+	unsigned int num_entries;
+	PointerSetEntry **bins;
+};
+
+struct _PointerSetEntry {
+	PointerSetElement element;
+	PointerSetEntry *next;
+};
+
+/* Table of prime numbers 2^n+a, 2<=n<=30. */
+static const long primes[] = {
+	8 + 3,
+	16 + 3,
+	32 + 5,
+	64 + 3,
+	128 + 3,
+	256 + 27,
+	512 + 9,
+	1024 + 9,
+	2048 + 5,
+	4096 + 3,
+	8192 + 27,
+	16384 + 43,
+	32768 + 3,
+	65536 + 45,
+	131072 + 29,
+	262144 + 3,
+	524288 + 21,
+	1048576 + 7,
+	2097152 + 17,
+	4194304 + 15,
+	8388608 + 9,
+	16777216 + 43,
+	33554432 + 35,
+	67108864 + 15,
+	134217728 + 29,
+	268435456 + 3,
+	536870912 + 11,
+	1073741824 + 85,
+	0
+};
+
+
+/* The percentage of nonempty buckets, before increasing the number of bins. 1.0 == 100%
+ * A value larger than 1.0 means that it's very likely that some buckets contain more than
+ * 1 entry.
+ */
+#define MAX_LOAD_FACTOR 2.0
+/* The default for the number of bins allocated initially. Must be a prime number. */
+#define DEFAULT_TABLE_SIZE 11
+/* MINSIZE is the minimum size of a dictionary. */
+#define MINSIZE 8
+
+#if SIZEOF_LONG == SIZEOF_VOIDP
+	typedef unsigned long PointerInt;
+#elif SIZEOF_LONG_LONG == SIZEOF_VOIDP
+	typedef unsigned LONG_LONG PointerInt;
+#else
+	#error ---->> pointerset.c requires sizeof(void*) == sizeof(long) to be compiled. <<---
+	-
+#endif
+
+#define alloc(type) (type*)malloc((unsigned)sizeof(type))
+#define Calloc(n,s) (char*)calloc((n),(s))
+
+#define HASH(element, num_bins) ((PointerInt) element) % num_bins
+#define FIND_ENTRY(set, entry, element) \
+	do { \
+		unsigned int bin_pos = HASH(element, set->num_bins); \
+		entry = (set)->bins[bin_pos]; \
+		while (entry != NULL && entry->element != element) { \
+			entry = entry->next; \
+		} \
+	} while (0)
+
+
+static int
+new_size(int size)
+{
+	int i;
+	int newsize;
+
+	for (i = 0, newsize = MINSIZE;
+	     i < sizeof(primes)/sizeof(primes[0]);
+	     i++, newsize <<= 1)
+	{
+		if (newsize > size)
+			return primes[i];
+	}
+	/* Ran out of polynomials */
+	return -1;	/* should raise exception */
+}
+
+PointerSet *
+pointer_set_new()
+{
+	PointerSet *set;
+
+	set = alloc(PointerSet);
+	if (set != NULL) {
+		set->num_entries = 0;
+		set->num_bins = DEFAULT_TABLE_SIZE;
+		set->bins = (PointerSetEntry **) Calloc(DEFAULT_TABLE_SIZE, sizeof(PointerSetEntry *));
+	}
+	return set;
+}
+
+static void
+free_bin_contents(PointerSet *set)
+{
+	PointerSetEntry *entry, *next;
+	int i;
+
+	for(i = 0; i < set->num_bins; i++) {
+		entry = set->bins[i];
+		while (entry != NULL) {
+			next = entry->next;
+			free(entry);
+			entry = next;
+		}
+		set->bins[i] = NULL;
+	}
+	set->num_entries = 0;
+}
+
+void
+pointer_set_free(PointerSet *set)
+{
+	free_bin_contents(set);
+	free(set->bins);
+	free(set);
+}
+
+int
+pointer_set_contains(PointerSet *set, PointerSetElement element)
+{
+	PointerSetEntry *entry;
+	FIND_ENTRY(set, entry, element);
+	return entry != NULL;
+}
+
+static void
+rehash(PointerSet *set, int new_num_bins)
+{
+	PointerSetEntry *entry, **new_bins;
+	int i;
+
+	new_bins = (PointerSetEntry **) Calloc(new_num_bins, sizeof(PointerSetEntry *));
+	for (i = 0; i < set->num_bins; i++) {
+		entry = set->bins[i];
+		while (entry != NULL) {
+			unsigned int new_bin_pos;
+			PointerSetEntry *next;
+
+			new_bin_pos = HASH(entry->element, new_num_bins);
+			next = entry->next;
+			entry->next = new_bins[new_bin_pos];
+			new_bins[new_bin_pos] = entry;
+			entry = next;
+		}
+	}
+	free(set->bins);
+	set->num_bins = new_num_bins;
+	set->bins = new_bins;
+}
+
+void
+pointer_set_insert(PointerSet *set, PointerSetElement element)
+{
+	PointerSetEntry *entry;
+
+	FIND_ENTRY(set, entry, element);
+	if (entry == NULL) {
+		unsigned int bin_pos;
+
+		if (set->num_entries / (double) set->num_bins > MAX_LOAD_FACTOR) {
+			/* Increase number of bins to the next prime number. */
+			rehash(set, new_size(set->num_bins + 1));
+		}
+
+		bin_pos = HASH(element, set->num_bins);
+		entry = malloc(sizeof(PointerSetEntry));
+		entry->element = element;
+		entry->next = set->bins[bin_pos];
+		set->bins[bin_pos] = entry;
+		set->num_entries++;
+	}
+}
+
+void
+pointer_set_delete(PointerSet *set, PointerSetElement element)
+{
+	unsigned int bin_pos;
+	PointerSetEntry *entry, *prev;
+
+	bin_pos = HASH(element, set->num_bins);
+	entry = set->bins[bin_pos];
+	prev = NULL;
+	while (entry != NULL && entry->element != element) {
+		prev = entry;
+		entry = entry->next;
+	}
+	if (entry != NULL) {
+		if (prev != NULL) {
+			prev->next = entry->next;
+		} else {
+			set->bins[bin_pos] = entry->next;
+		}
+		free(entry);
+		set->num_entries--;
+		/* TODO: is it a good idea to reduce the number of bins? */
+	}
+}
+
+void
+pointer_set_reset(PointerSet *set)
+{
+	free_bin_contents(set);
+	set->bins = realloc(set->bins, sizeof(PointerSetEntry *) * DEFAULT_TABLE_SIZE);
+	set->num_bins = DEFAULT_TABLE_SIZE;
+	memset(set->bins, 0, sizeof(PointerSetEntry *) * DEFAULT_TABLE_SIZE);
+}
+
+unsigned int
+pointer_set_get_size(PointerSet *set)
+{
+	return set->num_entries;
+}
+
+unsigned int
+pointer_set_get_capacity(PointerSet *set)
+{
+	return set->num_bins;
+}
--- /dev/null
+++ b/pointerset.h
@@ -0,0 +1,56 @@
+/**
+ * A specialized set data structure, designed to only contain pointers.
+ * It will grow and shrink dynamically.
+ */
+#ifndef _POINTER_SET_H_
+#define _POINTER_SET_H_
+
+typedef void * PointerSetElement;
+typedef struct _PointerSet PointerSet;
+
+/**
+ * Create a new, empty pointer set.
+ */
+PointerSet   *pointer_set_new();
+
+/**
+ * Free the given pointer set.
+ */
+void         pointer_set_free(PointerSet *set);
+
+/**
+ * Insert the given pointer into the pointer set. The data that the
+ * pointer pointers to is not touched, so <tt>element</tt> may even be
+ * an invalid pointer.
+ */
+void         pointer_set_insert(PointerSet *set, PointerSetElement element);
+
+/**
+ * Remove the given pointer from the pointer set. Nothing will happen
+ * if the pointer isn't already in the set.
+ */
+void         pointer_set_delete(PointerSet *set, PointerSetElement element);
+
+/**
+ * Check whether the given pointer is in the pointer set.
+ */
+int          pointer_set_contains(PointerSet *set, PointerSetElement element);
+
+/**
+ * Clear the pointer set.
+ */
+void         pointer_set_reset(PointerSet *set);
+
+/**
+ * Return the number of pointers in the pointer set.
+ */
+unsigned int pointer_set_get_size(PointerSet *set);
+
+/**
+ * Return the amount of space that is used to store the pointers in the set.
+ *
+ * @invariant pointer_set_get_capacity(set) >= pointer_set_get_size(set)
+ */
+unsigned int pointer_set_get_capacity(PointerSet *set);
+
+#endif /* _POINTER_SET_H_ */
--- a/re.c
+++ b/re.c
@@ -1496,19 +1496,17 @@
 rb_reg_regcomp(str)
     VALUE str;
 {
-    volatile VALUE save_str = str;
-    if (reg_cache && RREGEXP(reg_cache)->len == RSTRING(str)->len
-	&& case_cache == ruby_ignorecase
-	&& kcode_cache == reg_kcode
-	&& memcmp(RREGEXP(reg_cache)->str, RSTRING(str)->ptr, RSTRING(str)->len) == 0)
-	return reg_cache;
-
+  if (!reg_cache || RREGEXP(reg_cache)->len != RSTRING(str)->len
+     || case_cache != ruby_ignorecase
+     || kcode_cache != reg_kcode
+     || memcmp(RREGEXP(reg_cache)->str, RSTRING(str)->ptr, RSTRING(str)->len)) {
     case_cache = ruby_ignorecase;
     kcode_cache = reg_kcode;
-    reg_cache = rb_reg_new(RSTRING(str)->ptr, RSTRING(str)->len, ruby_ignorecase);
+    reg_cache = rb_reg_new(RSTRING(str)->ptr,RSTRING(str)->len,ruby_ignorecase);
     OBJ_INFECT(reg_cache, str);
-    RB_GC_GUARD(save_str);
-    return reg_cache;
+    RB_GC_GUARD(str);
+  }
+  return reg_cache;
 }
 
 static int
--- a/ruby.h
+++ b/ruby.h
@@ -480,7 +480,7 @@
 #define FL_EXIVAR    (1<<9)
 #define FL_FREEZE    (1<<10)
 
-#define FL_USHIFT    11
+#define FL_USHIFT    12
 
 #define FL_USER0     (1<<(FL_USHIFT+0))
 #define FL_USER1     (1<<(FL_USHIFT+1))
@@ -557,6 +557,8 @@
 void rb_gc_register_address _((VALUE*));
 void rb_gc_unregister_address _((VALUE*));
 
+int rb_gc_is_thread_marked _((VALUE));
+
 ID rb_intern _((const char*));
 const char *rb_id2name _((ID));
 ID rb_to_id _((VALUE));
--- a/rubysig.h
+++ b/rubysig.h
@@ -12,8 +12,80 @@
 
 #ifndef SIG_H
 #define SIG_H
+
 #include <errno.h>
 
+#if defined __ppc__ || defined __powerpc__ || \
+    defined __ppc64__ || defined __powerpc64__
+#define __anyPowerPC__ 1  /* for compatibility with older gcc versions */
+#endif
+
+/* STACK_WIPE_SITES determines where attempts are made to exorcise
+   "ghost object refereces" from the stack and how the stack is cleared:
+   
+   0x*001 -->  wipe stack just after every thread_switch
+   0x*002 -->  wipe stack just after every EXEC_TAG()
+   0x*004 -->  wipe stack in CHECK_INTS
+   0x*010 -->  wipe stack in while & until loops
+   0x*020 -->  wipe stack before yield() in iterators and outside eval.c
+   0x*040 -->  wipe stack on catch and thread save context
+   0x*100 -->  update stack extent on each object allocation
+   0x*200 -->  update stack extent on each object reallocation
+   0x*400 -->  update stack extent during GC marking passes
+   0x*800 -->  update stack extent on each throw (use with 0x040)
+   0x1000 -->  use inline assembly code for x86, PowerPC, or ARM CPUs
+
+   0x0*** -->  do not even call rb_wipe_stack()
+   0x2*** -->  call dummy rb_wipe_stack() (for debugging and profiling)
+   0x4*** -->  safe, portable stack clearing in memory allocated with alloca
+   0x6*** -->  use faster, but less safe stack clearing in unallocated stack
+   0x8*** -->  use faster, but less safe stack clearing (with inline code)
+   
+   for most effective gc use 0x*707
+   for fastest micro-benchmarking use 0x0000
+   0x*770 prevents almost all memory leaks caused by ghost references
+   without adding much overhead for stack clearing.
+   Other good trade offs are 0x*270, 0x*703, 0x*303 or even 0x*03
+   
+   In general, you may lessen the default -mpreferred-stack-boundary
+   only if using less safe stack clearing (0x6***).  Lessening the
+   stack alignment with portable stack clearing (0x4***) may fail to clear 
+   all ghost references off the stack.
+   
+   When using 0x6*** or 0x8***, the compiler could insert 
+   stack push(s) between reading the stack pointer and clearing 
+   the ghost references.  The register(s) pushed will be
+   cleared by the rb_gc_stack_wipe(), typically resulting in a segfault
+   or an interpreter hang.
+   
+   STACK_WIPE_SITES of 0x8770 works well compiled with gcc on most machines
+   using the recommended CFLAGS="-O2 -fno-stack-protector".  However...
+   If it hangs or crashes for you, try changing STACK_WIPE_SITES to 0x4770
+   and please report your details.  i.e. CFLAGS, compiler, version, CPU
+   
+   Note that it is redundant to wipe_stack in looping constructs if 
+   also doing so in CHECK_INTS.  It is also redundant to wipe_stack on
+   each thread_switch if wiping after every thread save context.
+*/
+#ifndef STACK_WIPE_SITES
+# ifdef __x86_64__     /* deal with "red zone" by not inlining stack clearing */
+#  define STACK_WIPE_SITES  0x6770
+# elif defined __anyPowerPC__   /* On any PowerPC, deal with... */
+#  define STACK_WIPE_SITES  0x7764   /* red zone & alloc(0) doesn't return sp */
+# else
+#  define STACK_WIPE_SITES  0x8770 /*normal case, use 0x4770 if problems arise*/
+# endif
+#endif
+
+#if (STACK_WIPE_SITES & 0x14) == 0x14
+#warning  wiping stack in CHECK_INTS makes wiping in loops redundant
+#endif
+#if (STACK_WIPE_SITES & 0x41) == 0x41
+#warning  wiping stack after thread save makes wiping on thread_switch redundant
+#endif
+
+#define STACK_WIPE_METHOD (STACK_WIPE_SITES>>13)
+
 #ifdef _WIN32
 typedef LONG rb_atomic_t;
 
@@ -78,12 +150,163 @@
 void rb_trap_restore_mask _((void));
 
 RUBY_EXTERN int rb_thread_critical;
-RUBY_EXTERN int rb_thread_pending;
 void rb_thread_schedule _((void));
+
+RUBY_EXTERN VALUE *rb_gc_stack_end;
+RUBY_EXTERN int rb_gc_stack_grow_direction;  /* -1 for down or 1 for up */
+
+#if STACK_GROW_DIRECTION > 0
+
+/* clear stack space between end and sp (not including *sp) */
+#define __stack_zero(end,sp)  __stack_zero_up(end,sp)
+
+/* true if top has grown past limit, i.e. top deeper than limit */
+#define __stack_past(limit,top)  __stack_past_up(limit,top)
+
+/* depth of mid below stack top */
+#define __stack_depth(top,mid)   __stack_depth_up(top,mid)
+
+/* stack pointer top adjusted to include depth more items */
+#define __stack_grow(top,depth)  __stack_grow_up(top,depth)
+
+
+#elif STACK_GROW_DIRECTION < 0
+#define __stack_zero(end,sp)  __stack_zero_down(end,sp)
+#define __stack_past(limit,top)  __stack_past_down(limit,top)
+#define __stack_depth(top,mid)   __stack_depth_down(top,mid)
+#define __stack_grow(top,depth)  __stack_grow_down(top,depth)
+
+#else  /* limp along if stack direction can't be determined at compile time */
+#define __stack_zero(end,sp) if (rb_gc_stack_grow_direction<0) \
+        __stack_zero_down(end,sp); else __stack_zero_up(end,sp);
+#define __stack_past(limit,top)  (rb_gc_stack_grow_direction<0 ? \
+                      __stack_past_down(limit,top) : __stack_past_up(limit,top))
+#define __stack_depth(top,mid) (rb_gc_stack_grow_direction<0 ? \
+                       __stack_depth_down(top,mid) : __stack_depth_up(top,mid))
+#define __stack_grow(top,depth) (rb_gc_stack_grow_direction<0 ? \
+                      __stack_grow_down(top,depth) : __stack_grow_up(top,depth))
+#endif
+ 
+#define __stack_zero_up(end,sp)  while (end >= ++sp) *sp=0
+#define __stack_past_up(limit,top)  ((limit) < (top))
+#define __stack_depth_up(top,mid) ((top) - (mid))
+#define __stack_grow_up(top,depth) ((top)+(depth))
+
+#define __stack_zero_down(end,sp)  while (end <= --sp) *sp=0
+#define __stack_past_down(limit,top)  ((limit) > (top))
+#define __stack_depth_down(top,mid) ((mid) - (top))
+#define __stack_grow_down(top,depth) ((top)-(depth))
+
+/* Make alloca work the best possible way.  */
+#ifdef __GNUC__
+# ifndef atarist
+#  ifndef alloca
+#   define alloca __builtin_alloca
+#  endif
+# endif /* atarist */
+
+# define nativeAllocA __builtin_alloca
+
+/* use assembly to get stack pointer quickly */
+# if STACK_WIPE_SITES & 0x1000
+#  define __defspfn(asmb)  \
+static inline VALUE *__sp(void) __attribute__((always_inline)); \
+static inline VALUE *__sp(void) \
+{ \
+  VALUE *sp; asm(asmb); \
+  return sp; \
+}
+#  ifdef __anyPowerPC__
+#   ifdef __APPLE__
+__defspfn("addi %0, r1, 0": "=r"(sp))
+#   else
+__defspfn("addi %0, 1, 0": "=r"(sp))
+#   endif
+#  elif defined  __i386__
+__defspfn("movl %%esp, %0": "=r"(sp))
+#  elif defined __x86_64__
+#warn ===> x86_64 inline assembler is known to crash -- change STACK_WIPE_SITES
+__defspfn("movq %%rsp, %0": "=r"(sp))
+#  elif __arm__
+__defspfn("mov %0, sp": "=r"(sp))
+#  else
+#   define __sp()  ((VALUE *)__builtin_alloca(0))
+#   warning No assembly version of __sp() defined for this CPU.
+#  endif
+# else
+#  if ALLOCA_0_RETURNS_STACK_POINTER
+#    define __sp()  ((VALUE *)__builtin_alloca(0))
+#  else
+#    define __sp()  ((VALUE *)__builtin_alloca(sizeof(void *)))
+#  endif /* ALLOCA_0_RETURNS_STACK_POINTER */
+# endif
+
+#else  // not GNUC
+
+# ifdef HAVE_ALLOCA_H
+#  include <alloca.h>
+# else
+#  ifndef _AIX
+#   ifndef alloca /* predefined by HP cc +Olibcalls */
+void *alloca ();
+#   endif
+#  endif /* AIX */
+# endif /* HAVE_ALLOCA_H */
+
+# if STACK_WIPE_SITES & 0x1000
+#  warning No assembly versions of __sp() defined for this compiler.
+# endif
+# if HAVE_ALLOCA
+#  define __sp()  ((VALUE *)alloca(0))
+#  define nativeAllocA alloca
+# else
+RUBY_EXTERN VALUE *__sp(void);
+#  if STACK_WIPE_SITES
+#   define STACK_WIPE_SITES 0
+#   warning Disabled Stack Wiping because there is no native alloca()
+#  endif
+# endif
+#endif /* __GNUC__ */
+
+
+/*
+  Zero memory that was (recently) part of the stack, but is no longer.
+  Invoke when stack is deep to mark its extent and when it's shallow to wipe it.
+*/
+#if STACK_WIPE_METHOD == 0
+#define rb_gc_wipe_stack() ((void)0)
+#elif STACK_WIPE_METHOD == 4
+#define rb_gc_wipe_stack() {     \
+  VALUE *end = rb_gc_stack_end;  \
+  VALUE *sp = __sp();            \
+  rb_gc_stack_end = sp;          \
+  __stack_zero(end, sp);   \
+}
+#else
+RUBY_EXTERN void rb_gc_wipe_stack(void);
+#endif
+
+/*
+  Update our record of maximum stack extent without zeroing unused stack
+*/
+#define rb_gc_update_stack_extent() do { \
+    VALUE *sp = __sp(); \
+    if __stack_past(rb_gc_stack_end, sp) rb_gc_stack_end = sp; \
+} while(0)
+
+
+#if STACK_WIPE_SITES & 4
+# define CHECK_INTS_wipe_stack()  rb_gc_wipe_stack()
+#else
+# define CHECK_INTS_wipe_stack()  (void)0
+#endif
+
 #if defined(HAVE_SETITIMER) || defined(_THREAD_SAFE)
+RUBY_EXTERN int rb_thread_pending;
 # define CHECK_INTS do {\
+    CHECK_INTS_wipe_stack(); \
     if (!(rb_prohibit_interrupt || rb_thread_critical)) {\
-	if (rb_thread_pending) rb_thread_schedule();\
+        if (rb_thread_pending) rb_thread_schedule();\
 	if (rb_trap_pending) rb_trap_exec();\
     }\
 } while (0)
@@ -92,13 +315,14 @@
 RUBY_EXTERN int rb_thread_tick;
 #define THREAD_TICK 500
 #define CHECK_INTS do {\
+    CHECK_INTS_wipe_stack(); \
     if (!(rb_prohibit_interrupt || rb_thread_critical)) {\
-	if (rb_thread_pending || rb_thread_tick-- <= 0) {\
+	if (rb_thread_tick-- <= 0) {\
 	    rb_thread_tick = THREAD_TICK;\
-	    rb_thread_schedule();\
+            rb_thread_schedule();\
 	}\
+        if (rb_trap_pending) rb_trap_exec();\
     }\
-    if (rb_trap_pending) rb_trap_exec();\
 } while (0)
 #endif
 
--- a/signal.c
+++ b/signal.c
@@ -629,8 +629,6 @@
     }
 #endif
 
-    extern int ruby_gc_stress;
-    ruby_gc_stress = 0;
     rb_bug("Segmentation fault");
 }
 #endif
--- /dev/null
+++ b/system_allocator.c
@@ -0,0 +1,50 @@
+/*
+ * The problem
+ * -----------
+ * On platforms that use a two-level symbol namespace for dynamic libraries
+ * (most notably MacOS X), integrating tcmalloc requires special modifications.
+ *
+ * Most Unix platforms use a flat namespace for symbol lookup, which is why
+ * linking to tcmalloc causes it override malloc() and free() for the entire
+ * process. This is not the case on OS X: if Ruby calls a function from library
+ * that's not compiled with -flat_namespace, then that library will use the
+ * system's memory allocator instead of tcmalloc.
+ *
+ * The Ruby readline extension is a good example of how things can go wrong.
+ * The readline extension calls the readline() function in the readline library.
+ * This library is not compiled with -flat_namespace; readline() returns a string
+ * that's allocated by the system memory allocator. The Ruby readline extension
+ * then frees this string by passing it to tcmalloc's free() function. This
+ * results in a crash.
+ * Note that setting DYLD_FORCE_FLAT_NAMESPACE on OS X does not work: the
+ * resulting Ruby interpreter will crash immediately.
+ *
+ *
+ * The solution
+ * ------------
+ * This can be fixed by making it possible for Ruby extensions to call the
+ * system's memory allocator functions, instead of tcmalloc's, if it knows
+ * that a piece of memory is allocated by the system's memory allocator.
+ *
+ * This library, libsystem_allocator provides wrapper functions for the system
+ * memory allocator. libsystem_allocator will be compiled without -flat_namespace
+ * on OS X, and so it will always use the system's memory allocator instead of
+ * tcmalloc.
+ *
+ * libsystem_allocator will not be compiled on systems that only support flat
+ * namespaces (e.g. Linux). On those platforms, system_malloc() and
+ * system_free() have no special effect.
+ */
+#include <stdlib.h>
+
+void *
+system_malloc(long size)
+{
+    return malloc(size);
+}
+
+void
+system_free(void *ptr)
+{
+    free(ptr);
+}
--- /dev/null
+++ b/test/callerforallthreads/test_caller_for_each_thread.rb
@@ -0,0 +1,95 @@
+# -*- ruby-indent-level: 4 -*-
+require 'thread'
+require 'test/unit'
+
+class AClassWithNestedmethods
+  
+  def an_ultra_nested_method(skip)
+    caller_for_all_threads skip
+  end
+
+  def a_nested_method(skip)
+    an_ultra_nested_method skip
+  end
+
+  def a_method(skip=0)
+    a_nested_method skip
+  end
+  
+end
+
+class CallerForEachThreadTest < Test::Unit::TestCase
+  
+  def testCollectMeaningfulBacktraceForASingleThread
+    backtraces = AClassWithNestedmethods.new.a_method
+    backtrace = backtraces[Thread.current]
+    assert_not_nil backtrace
+    assert_equal __FILE__ + ":8:in `an_ultra_nested_method'", backtrace[0]
+    assert_equal __FILE__ + ":12:in `a_nested_method'", backtrace[1]
+    assert_equal __FILE__ + ":16:in `a_method'", backtrace[2]
+    assert_equal __FILE__ + ":24:in `testCollectMeaningfulBacktraceForASingleThread'", 
+                 backtrace[3]
+  end
+
+  def testCanSkipFirstStackEntries
+    backtraces = AClassWithNestedmethods.new.a_method 2
+    backtrace = backtraces[Thread.current]
+    assert_not_nil backtrace
+    assert_equal __FILE__ + ":16:in `a_method'", backtrace[0]
+    assert_equal __FILE__ + ":35:in `testCanSkipFirstStackEntries'", 
+                 backtrace[1]
+  end
+
+  def testCollectMeaningfulBacktraceForMultipleThreads
+    first_thread = Thread.new do
+      loop do
+        Thread.pass
+        sleep 1
+      end
+    end
+
+    second_thread = Thread.new do
+      loop do
+        Thread.pass
+        sleep 1
+      end
+    end
+
+    backtraces = AClassWithNestedmethods.new.a_method
+    
+    backtrace = backtraces[Thread.current]
+    assert_not_nil backtrace
+    assert_match __FILE__ + ":8:in `an_ultra_nested_method'", backtrace[0]
+    assert_match __FILE__ + ":12:in `a_nested_method'", backtrace[1]
+    assert_equal __FILE__ + ":16:in `a_method'", backtrace[2]
+    assert_equal __FILE__ + ":58:in `testCollectMeaningfulBacktraceForMultipleThreads'", 
+                 backtrace[3]
+                 
+    backtrace = backtraces[first_thread]
+    assert_not_nil backtrace
+    assert_equal __FILE__ + ":47:in `testCollectMeaningfulBacktraceForMultipleThreads'", 
+                 backtrace[0]
+    assert_equal __FILE__ + ":45:in `loop'", 
+                 backtrace[1]
+    assert_equal __FILE__ + ":45:in `testCollectMeaningfulBacktraceForMultipleThreads'",
+                 backtrace[2]
+    assert_equal __FILE__ + ":44:in `initialize'",backtrace[3]
+    assert_equal __FILE__ + ":44:in `new'", backtrace[4]
+    assert_equal __FILE__ + ":44:in `testCollectMeaningfulBacktraceForMultipleThreads'",
+                 backtrace[5]
+
+    backtrace = backtraces[second_thread]
+    assert_not_nil backtrace
+    assert_equal __FILE__ + ":53:in `testCollectMeaningfulBacktraceForMultipleThreads'", 
+                 backtrace[0]
+    assert_equal __FILE__ + ":52:in `loop'", backtrace[1]
+    assert_equal __FILE__ + ":52:in `testCollectMeaningfulBacktraceForMultipleThreads'",
+                 backtrace[2]
+    assert_equal __FILE__ + ":51:in `initialize'",backtrace[3]
+    assert_equal __FILE__ + ":51:in `new'", backtrace[4]
+    assert_equal __FILE__ + ":51:in `testCollectMeaningfulBacktraceForMultipleThreads'",
+                 backtrace[5]
+  end
+  
+end
+
--- /dev/null
+++ b/test/rational/test_fixnum_gcd.rb
@@ -0,0 +1,811 @@
+require 'rational'
+require 'pp'
+
+require 'test/unit'
+require 'rbconfig'
+
+class GcdTest < Test::Unit::TestCase
+
+  @@biggest_positive_fixnum = 1
+  until (x = ((@@biggest_positive_fixnum << 1) + 1)).class == Bignum
+    @@biggest_positive_fixnum = x
+  end
+  @@biggest_positive_fixnum = (@@biggest_positive_fixnum - 10)
+  until (x = (@@biggest_positive_fixnum + 1)).class == Bignum
+    @@biggest_positive_fixnum = x
+  end
+  @@smallest_positive_bignum = x
+  
+  @@biggest_negative_fixnum = -1
+  until (x = (@@biggest_negative_fixnum << 1)).class == Bignum
+    @@biggest_negative_fixnum = x
+  end
+  until (x = (@@biggest_negative_fixnum - 1)).class == Bignum
+    @@biggest_negative_fixnum = x
+  end
+  @@smallest_negative_bignum = x
+  
+  def xc x
+    [ x.class, x ].inspect
+  end
+
+case RbConfig::CONFIG['build_cpu']
+when 'amd64', 'x86_64'
+  # values generated by ruby 1.8.7 (2009-06-12 patchlevel 174) [x86_64-linux]
+@@expected = 
+[["[Fixnum, 1] gcd [Fixnum, 1] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 1] gcd [Fixnum, 2] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 1] gcd [Fixnum, 4] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 1] gcd [Fixnum, 5] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 1] gcd [Fixnum, 25] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 1] gcd [Fixnum, -1] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 1] gcd [Fixnum, -2] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 1] gcd [Fixnum, -4] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 1] gcd [Fixnum, -5] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 1] gcd [Fixnum, -25] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 1] gcd [Fixnum, 4611686018427387903] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 1] gcd [Fixnum, -4611686018427387903] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 1] gcd [Fixnum, -4611686018427387904] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 1] gcd [Bignum, 4611686018427387904] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 1] gcd [Bignum, 4611686018427387904] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 1] gcd [Fixnum, -4611686018427387904] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 1] gcd [Bignum, -4611686018427387905] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 1] gcd [Bignum, 4611686018427387905] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 2] gcd [Fixnum, 1] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 2] gcd [Fixnum, 2] => ", "[Fixnum, 2]"],
+ ["[Fixnum, 2] gcd [Fixnum, 4] => ", "[Fixnum, 2]"],
+ ["[Fixnum, 2] gcd [Fixnum, 5] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 2] gcd [Fixnum, 25] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 2] gcd [Fixnum, -1] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 2] gcd [Fixnum, -2] => ", "[Fixnum, 2]"],
+ ["[Fixnum, 2] gcd [Fixnum, -4] => ", "[Fixnum, 2]"],
+ ["[Fixnum, 2] gcd [Fixnum, -5] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 2] gcd [Fixnum, -25] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 2] gcd [Fixnum, 4611686018427387903] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 2] gcd [Fixnum, -4611686018427387903] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 2] gcd [Fixnum, -4611686018427387904] => ", "[Fixnum, 2]"],
+ ["[Fixnum, 2] gcd [Bignum, 4611686018427387904] => ", "[Fixnum, 2]"],
+ ["[Fixnum, 2] gcd [Bignum, 4611686018427387904] => ", "[Fixnum, 2]"],
+ ["[Fixnum, 2] gcd [Fixnum, -4611686018427387904] => ", "[Fixnum, 2]"],
+ ["[Fixnum, 2] gcd [Bignum, -4611686018427387905] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 2] gcd [Bignum, 4611686018427387905] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 4] gcd [Fixnum, 1] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 4] gcd [Fixnum, 2] => ", "[Fixnum, 2]"],
+ ["[Fixnum, 4] gcd [Fixnum, 4] => ", "[Fixnum, 4]"],
+ ["[Fixnum, 4] gcd [Fixnum, 5] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 4] gcd [Fixnum, 25] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 4] gcd [Fixnum, -1] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 4] gcd [Fixnum, -2] => ", "[Fixnum, 2]"],
+ ["[Fixnum, 4] gcd [Fixnum, -4] => ", "[Fixnum, 4]"],
+ ["[Fixnum, 4] gcd [Fixnum, -5] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 4] gcd [Fixnum, -25] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 4] gcd [Fixnum, 4611686018427387903] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 4] gcd [Fixnum, -4611686018427387903] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 4] gcd [Fixnum, -4611686018427387904] => ", "[Fixnum, 4]"],
+ ["[Fixnum, 4] gcd [Bignum, 4611686018427387904] => ", "[Fixnum, 4]"],
+ ["[Fixnum, 4] gcd [Bignum, 4611686018427387904] => ", "[Fixnum, 4]"],
+ ["[Fixnum, 4] gcd [Fixnum, -4611686018427387904] => ", "[Fixnum, 4]"],
+ ["[Fixnum, 4] gcd [Bignum, -4611686018427387905] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 4] gcd [Bignum, 4611686018427387905] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 5] gcd [Fixnum, 1] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 5] gcd [Fixnum, 2] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 5] gcd [Fixnum, 4] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 5] gcd [Fixnum, 5] => ", "[Fixnum, 5]"],
+ ["[Fixnum, 5] gcd [Fixnum, 25] => ", "[Fixnum, 5]"],
+ ["[Fixnum, 5] gcd [Fixnum, -1] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 5] gcd [Fixnum, -2] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 5] gcd [Fixnum, -4] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 5] gcd [Fixnum, -5] => ", "[Fixnum, 5]"],
+ ["[Fixnum, 5] gcd [Fixnum, -25] => ", "[Fixnum, 5]"],
+ ["[Fixnum, 5] gcd [Fixnum, 4611686018427387903] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 5] gcd [Fixnum, -4611686018427387903] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 5] gcd [Fixnum, -4611686018427387904] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 5] gcd [Bignum, 4611686018427387904] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 5] gcd [Bignum, 4611686018427387904] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 5] gcd [Fixnum, -4611686018427387904] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 5] gcd [Bignum, -4611686018427387905] => ", "[Fixnum, 5]"],
+ ["[Fixnum, 5] gcd [Bignum, 4611686018427387905] => ", "[Fixnum, 5]"],
+ ["[Fixnum, 25] gcd [Fixnum, 1] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 25] gcd [Fixnum, 2] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 25] gcd [Fixnum, 4] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 25] gcd [Fixnum, 5] => ", "[Fixnum, 5]"],
+ ["[Fixnum, 25] gcd [Fixnum, 25] => ", "[Fixnum, 25]"],
+ ["[Fixnum, 25] gcd [Fixnum, -1] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 25] gcd [Fixnum, -2] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 25] gcd [Fixnum, -4] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 25] gcd [Fixnum, -5] => ", "[Fixnum, 5]"],
+ ["[Fixnum, 25] gcd [Fixnum, -25] => ", "[Fixnum, 25]"],
+ ["[Fixnum, 25] gcd [Fixnum, 4611686018427387903] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 25] gcd [Fixnum, -4611686018427387903] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 25] gcd [Fixnum, -4611686018427387904] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 25] gcd [Bignum, 4611686018427387904] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 25] gcd [Bignum, 4611686018427387904] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 25] gcd [Fixnum, -4611686018427387904] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 25] gcd [Bignum, -4611686018427387905] => ", "[Fixnum, 5]"],
+ ["[Fixnum, 25] gcd [Bignum, 4611686018427387905] => ", "[Fixnum, 5]"],
+ ["[Fixnum, -1] gcd [Fixnum, 1] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1] gcd [Fixnum, 2] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1] gcd [Fixnum, 4] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1] gcd [Fixnum, 5] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1] gcd [Fixnum, 25] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1] gcd [Fixnum, -1] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1] gcd [Fixnum, -2] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1] gcd [Fixnum, -4] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1] gcd [Fixnum, -5] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1] gcd [Fixnum, -25] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1] gcd [Fixnum, 4611686018427387903] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1] gcd [Fixnum, -4611686018427387903] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1] gcd [Fixnum, -4611686018427387904] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1] gcd [Bignum, 4611686018427387904] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1] gcd [Bignum, 4611686018427387904] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1] gcd [Fixnum, -4611686018427387904] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1] gcd [Bignum, -4611686018427387905] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1] gcd [Bignum, 4611686018427387905] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -2] gcd [Fixnum, 1] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -2] gcd [Fixnum, 2] => ", "[Fixnum, 2]"],
+ ["[Fixnum, -2] gcd [Fixnum, 4] => ", "[Fixnum, 2]"],
+ ["[Fixnum, -2] gcd [Fixnum, 5] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -2] gcd [Fixnum, 25] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -2] gcd [Fixnum, -1] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -2] gcd [Fixnum, -2] => ", "[Fixnum, 2]"],
+ ["[Fixnum, -2] gcd [Fixnum, -4] => ", "[Fixnum, 2]"],
+ ["[Fixnum, -2] gcd [Fixnum, -5] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -2] gcd [Fixnum, -25] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -2] gcd [Fixnum, 4611686018427387903] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -2] gcd [Fixnum, -4611686018427387903] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -2] gcd [Fixnum, -4611686018427387904] => ", "[Fixnum, 2]"],
+ ["[Fixnum, -2] gcd [Bignum, 4611686018427387904] => ", "[Fixnum, 2]"],
+ ["[Fixnum, -2] gcd [Bignum, 4611686018427387904] => ", "[Fixnum, 2]"],
+ ["[Fixnum, -2] gcd [Fixnum, -4611686018427387904] => ", "[Fixnum, 2]"],
+ ["[Fixnum, -2] gcd [Bignum, -4611686018427387905] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -2] gcd [Bignum, 4611686018427387905] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -4] gcd [Fixnum, 1] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -4] gcd [Fixnum, 2] => ", "[Fixnum, 2]"],
+ ["[Fixnum, -4] gcd [Fixnum, 4] => ", "[Fixnum, 4]"],
+ ["[Fixnum, -4] gcd [Fixnum, 5] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -4] gcd [Fixnum, 25] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -4] gcd [Fixnum, -1] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -4] gcd [Fixnum, -2] => ", "[Fixnum, 2]"],
+ ["[Fixnum, -4] gcd [Fixnum, -4] => ", "[Fixnum, 4]"],
+ ["[Fixnum, -4] gcd [Fixnum, -5] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -4] gcd [Fixnum, -25] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -4] gcd [Fixnum, 4611686018427387903] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -4] gcd [Fixnum, -4611686018427387903] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -4] gcd [Fixnum, -4611686018427387904] => ", "[Fixnum, 4]"],
+ ["[Fixnum, -4] gcd [Bignum, 4611686018427387904] => ", "[Fixnum, 4]"],
+ ["[Fixnum, -4] gcd [Bignum, 4611686018427387904] => ", "[Fixnum, 4]"],
+ ["[Fixnum, -4] gcd [Fixnum, -4611686018427387904] => ", "[Fixnum, 4]"],
+ ["[Fixnum, -4] gcd [Bignum, -4611686018427387905] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -4] gcd [Bignum, 4611686018427387905] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -5] gcd [Fixnum, 1] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -5] gcd [Fixnum, 2] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -5] gcd [Fixnum, 4] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -5] gcd [Fixnum, 5] => ", "[Fixnum, 5]"],
+ ["[Fixnum, -5] gcd [Fixnum, 25] => ", "[Fixnum, 5]"],
+ ["[Fixnum, -5] gcd [Fixnum, -1] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -5] gcd [Fixnum, -2] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -5] gcd [Fixnum, -4] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -5] gcd [Fixnum, -5] => ", "[Fixnum, 5]"],
+ ["[Fixnum, -5] gcd [Fixnum, -25] => ", "[Fixnum, 5]"],
+ ["[Fixnum, -5] gcd [Fixnum, 4611686018427387903] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -5] gcd [Fixnum, -4611686018427387903] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -5] gcd [Fixnum, -4611686018427387904] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -5] gcd [Bignum, 4611686018427387904] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -5] gcd [Bignum, 4611686018427387904] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -5] gcd [Fixnum, -4611686018427387904] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -5] gcd [Bignum, -4611686018427387905] => ", "[Fixnum, 5]"],
+ ["[Fixnum, -5] gcd [Bignum, 4611686018427387905] => ", "[Fixnum, 5]"],
+ ["[Fixnum, -25] gcd [Fixnum, 1] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -25] gcd [Fixnum, 2] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -25] gcd [Fixnum, 4] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -25] gcd [Fixnum, 5] => ", "[Fixnum, 5]"],
+ ["[Fixnum, -25] gcd [Fixnum, 25] => ", "[Fixnum, 25]"],
+ ["[Fixnum, -25] gcd [Fixnum, -1] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -25] gcd [Fixnum, -2] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -25] gcd [Fixnum, -4] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -25] gcd [Fixnum, -5] => ", "[Fixnum, 5]"],
+ ["[Fixnum, -25] gcd [Fixnum, -25] => ", "[Fixnum, 25]"],
+ ["[Fixnum, -25] gcd [Fixnum, 4611686018427387903] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -25] gcd [Fixnum, -4611686018427387903] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -25] gcd [Fixnum, -4611686018427387904] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -25] gcd [Bignum, 4611686018427387904] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -25] gcd [Bignum, 4611686018427387904] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -25] gcd [Fixnum, -4611686018427387904] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -25] gcd [Bignum, -4611686018427387905] => ", "[Fixnum, 5]"],
+ ["[Fixnum, -25] gcd [Bignum, 4611686018427387905] => ", "[Fixnum, 5]"],
+ ["[Fixnum, 4611686018427387903] gcd [Fixnum, 1] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 4611686018427387903] gcd [Fixnum, 2] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 4611686018427387903] gcd [Fixnum, 4] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 4611686018427387903] gcd [Fixnum, 5] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 4611686018427387903] gcd [Fixnum, 25] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 4611686018427387903] gcd [Fixnum, -1] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 4611686018427387903] gcd [Fixnum, -2] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 4611686018427387903] gcd [Fixnum, -4] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 4611686018427387903] gcd [Fixnum, -5] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 4611686018427387903] gcd [Fixnum, -25] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 4611686018427387903] gcd [Fixnum, 4611686018427387903] => ",
+  "[Fixnum, 4611686018427387903]"],
+ ["[Fixnum, 4611686018427387903] gcd [Fixnum, -4611686018427387903] => ",
+  "[Fixnum, 4611686018427387903]"],
+ ["[Fixnum, 4611686018427387903] gcd [Fixnum, -4611686018427387904] => ",
+  "[Fixnum, 1]"],
+ ["[Fixnum, 4611686018427387903] gcd [Bignum, 4611686018427387904] => ",
+  "[Fixnum, 1]"],
+ ["[Fixnum, 4611686018427387903] gcd [Bignum, 4611686018427387904] => ",
+  "[Fixnum, 1]"],
+ ["[Fixnum, 4611686018427387903] gcd [Fixnum, -4611686018427387904] => ",
+  "[Fixnum, 1]"],
+ ["[Fixnum, 4611686018427387903] gcd [Bignum, -4611686018427387905] => ",
+  "[Fixnum, 1]"],
+ ["[Fixnum, 4611686018427387903] gcd [Bignum, 4611686018427387905] => ",
+  "[Fixnum, 1]"],
+ ["[Fixnum, -4611686018427387903] gcd [Fixnum, 1] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -4611686018427387903] gcd [Fixnum, 2] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -4611686018427387903] gcd [Fixnum, 4] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -4611686018427387903] gcd [Fixnum, 5] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -4611686018427387903] gcd [Fixnum, 25] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -4611686018427387903] gcd [Fixnum, -1] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -4611686018427387903] gcd [Fixnum, -2] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -4611686018427387903] gcd [Fixnum, -4] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -4611686018427387903] gcd [Fixnum, -5] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -4611686018427387903] gcd [Fixnum, -25] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -4611686018427387903] gcd [Fixnum, 4611686018427387903] => ",
+  "[Fixnum, 4611686018427387903]"],
+ ["[Fixnum, -4611686018427387903] gcd [Fixnum, -4611686018427387903] => ",
+  "[Fixnum, 4611686018427387903]"],
+ ["[Fixnum, -4611686018427387903] gcd [Fixnum, -4611686018427387904] => ",
+  "[Fixnum, 1]"],
+ ["[Fixnum, -4611686018427387903] gcd [Bignum, 4611686018427387904] => ",
+  "[Fixnum, 1]"],
+ ["[Fixnum, -4611686018427387903] gcd [Bignum, 4611686018427387904] => ",
+  "[Fixnum, 1]"],
+ ["[Fixnum, -4611686018427387903] gcd [Fixnum, -4611686018427387904] => ",
+  "[Fixnum, 1]"],
+ ["[Fixnum, -4611686018427387903] gcd [Bignum, -4611686018427387905] => ",
+  "[Fixnum, 1]"],
+ ["[Fixnum, -4611686018427387903] gcd [Bignum, 4611686018427387905] => ",
+  "[Fixnum, 1]"],
+ ["[Fixnum, -4611686018427387904] gcd [Fixnum, 1] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -4611686018427387904] gcd [Fixnum, 2] => ", "[Fixnum, 2]"],
+ ["[Fixnum, -4611686018427387904] gcd [Fixnum, 4] => ", "[Fixnum, 4]"],
+ ["[Fixnum, -4611686018427387904] gcd [Fixnum, 5] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -4611686018427387904] gcd [Fixnum, 25] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -4611686018427387904] gcd [Fixnum, -1] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -4611686018427387904] gcd [Fixnum, -2] => ", "[Fixnum, 2]"],
+ ["[Fixnum, -4611686018427387904] gcd [Fixnum, -4] => ", "[Fixnum, 4]"],
+ ["[Fixnum, -4611686018427387904] gcd [Fixnum, -5] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -4611686018427387904] gcd [Fixnum, -25] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -4611686018427387904] gcd [Fixnum, 4611686018427387903] => ",
+  "[Fixnum, 1]"],
+ ["[Fixnum, -4611686018427387904] gcd [Fixnum, -4611686018427387903] => ",
+  "[Fixnum, 1]"],
+ ["[Fixnum, -4611686018427387904] gcd [Fixnum, -4611686018427387904] => ",
+  "[Bignum, 4611686018427387904]"],
+ ["[Fixnum, -4611686018427387904] gcd [Bignum, 4611686018427387904] => ",
+  "[Bignum, 4611686018427387904]"],
+ ["[Fixnum, -4611686018427387904] gcd [Bignum, 4611686018427387904] => ",
+  "[Bignum, 4611686018427387904]"],
+ ["[Fixnum, -4611686018427387904] gcd [Fixnum, -4611686018427387904] => ",
+  "[Bignum, 4611686018427387904]"],
+ ["[Fixnum, -4611686018427387904] gcd [Bignum, -4611686018427387905] => ",
+  "[Fixnum, 1]"],
+ ["[Fixnum, -4611686018427387904] gcd [Bignum, 4611686018427387905] => ",
+  "[Fixnum, 1]"],
+ ["[Bignum, 4611686018427387904] gcd [Fixnum, 1] => ", "[Fixnum, 1]"],
+ ["[Bignum, 4611686018427387904] gcd [Fixnum, 2] => ", "[Fixnum, 2]"],
+ ["[Bignum, 4611686018427387904] gcd [Fixnum, 4] => ", "[Fixnum, 4]"],
+ ["[Bignum, 4611686018427387904] gcd [Fixnum, 5] => ", "[Fixnum, 1]"],
+ ["[Bignum, 4611686018427387904] gcd [Fixnum, 25] => ", "[Fixnum, 1]"],
+ ["[Bignum, 4611686018427387904] gcd [Fixnum, -1] => ", "[Fixnum, 1]"],
+ ["[Bignum, 4611686018427387904] gcd [Fixnum, -2] => ", "[Fixnum, 2]"],
+ ["[Bignum, 4611686018427387904] gcd [Fixnum, -4] => ", "[Fixnum, 4]"],
+ ["[Bignum, 4611686018427387904] gcd [Fixnum, -5] => ", "[Fixnum, 1]"],
+ ["[Bignum, 4611686018427387904] gcd [Fixnum, -25] => ", "[Fixnum, 1]"],
+ ["[Bignum, 4611686018427387904] gcd [Fixnum, 4611686018427387903] => ",
+  "[Fixnum, 1]"],
+ ["[Bignum, 4611686018427387904] gcd [Fixnum, -4611686018427387903] => ",
+  "[Fixnum, 1]"],
+ ["[Bignum, 4611686018427387904] gcd [Fixnum, -4611686018427387904] => ",
+  "[Bignum, 4611686018427387904]"],
+ ["[Bignum, 4611686018427387904] gcd [Bignum, 4611686018427387904] => ",
+  "[Bignum, 4611686018427387904]"],
+ ["[Bignum, 4611686018427387904] gcd [Bignum, 4611686018427387904] => ",
+  "[Bignum, 4611686018427387904]"],
+ ["[Bignum, 4611686018427387904] gcd [Fixnum, -4611686018427387904] => ",
+  "[Bignum, 4611686018427387904]"],
+ ["[Bignum, 4611686018427387904] gcd [Bignum, -4611686018427387905] => ",
+  "[Fixnum, 1]"],
+ ["[Bignum, 4611686018427387904] gcd [Bignum, 4611686018427387905] => ",
+  "[Fixnum, 1]"],
+ ["[Bignum, 4611686018427387904] gcd [Fixnum, 1] => ", "[Fixnum, 1]"],
+ ["[Bignum, 4611686018427387904] gcd [Fixnum, 2] => ", "[Fixnum, 2]"],
+ ["[Bignum, 4611686018427387904] gcd [Fixnum, 4] => ", "[Fixnum, 4]"],
+ ["[Bignum, 4611686018427387904] gcd [Fixnum, 5] => ", "[Fixnum, 1]"],
+ ["[Bignum, 4611686018427387904] gcd [Fixnum, 25] => ", "[Fixnum, 1]"],
+ ["[Bignum, 4611686018427387904] gcd [Fixnum, -1] => ", "[Fixnum, 1]"],
+ ["[Bignum, 4611686018427387904] gcd [Fixnum, -2] => ", "[Fixnum, 2]"],
+ ["[Bignum, 4611686018427387904] gcd [Fixnum, -4] => ", "[Fixnum, 4]"],
+ ["[Bignum, 4611686018427387904] gcd [Fixnum, -5] => ", "[Fixnum, 1]"],
+ ["[Bignum, 4611686018427387904] gcd [Fixnum, -25] => ", "[Fixnum, 1]"],
+ ["[Bignum, 4611686018427387904] gcd [Fixnum, 4611686018427387903] => ",
+  "[Fixnum, 1]"],
+ ["[Bignum, 4611686018427387904] gcd [Fixnum, -4611686018427387903] => ",
+  "[Fixnum, 1]"],
+ ["[Bignum, 4611686018427387904] gcd [Fixnum, -4611686018427387904] => ",
+  "[Bignum, 4611686018427387904]"],
+ ["[Bignum, 4611686018427387904] gcd [Bignum, 4611686018427387904] => ",
+  "[Bignum, 4611686018427387904]"],
+ ["[Bignum, 4611686018427387904] gcd [Bignum, 4611686018427387904] => ",
+  "[Bignum, 4611686018427387904]"],
+ ["[Bignum, 4611686018427387904] gcd [Fixnum, -4611686018427387904] => ",
+  "[Bignum, 4611686018427387904]"],
+ ["[Bignum, 4611686018427387904] gcd [Bignum, -4611686018427387905] => ",
+  "[Fixnum, 1]"],
+ ["[Bignum, 4611686018427387904] gcd [Bignum, 4611686018427387905] => ",
+  "[Fixnum, 1]"],
+ ["[Fixnum, -4611686018427387904] gcd [Fixnum, 1] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -4611686018427387904] gcd [Fixnum, 2] => ", "[Fixnum, 2]"],
+ ["[Fixnum, -4611686018427387904] gcd [Fixnum, 4] => ", "[Fixnum, 4]"],
+ ["[Fixnum, -4611686018427387904] gcd [Fixnum, 5] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -4611686018427387904] gcd [Fixnum, 25] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -4611686018427387904] gcd [Fixnum, -1] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -4611686018427387904] gcd [Fixnum, -2] => ", "[Fixnum, 2]"],
+ ["[Fixnum, -4611686018427387904] gcd [Fixnum, -4] => ", "[Fixnum, 4]"],
+ ["[Fixnum, -4611686018427387904] gcd [Fixnum, -5] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -4611686018427387904] gcd [Fixnum, -25] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -4611686018427387904] gcd [Fixnum, 4611686018427387903] => ",
+  "[Fixnum, 1]"],
+ ["[Fixnum, -4611686018427387904] gcd [Fixnum, -4611686018427387903] => ",
+  "[Fixnum, 1]"],
+ ["[Fixnum, -4611686018427387904] gcd [Fixnum, -4611686018427387904] => ",
+  "[Bignum, 4611686018427387904]"],
+ ["[Fixnum, -4611686018427387904] gcd [Bignum, 4611686018427387904] => ",
+  "[Bignum, 4611686018427387904]"],
+ ["[Fixnum, -4611686018427387904] gcd [Bignum, 4611686018427387904] => ",
+  "[Bignum, 4611686018427387904]"],
+ ["[Fixnum, -4611686018427387904] gcd [Fixnum, -4611686018427387904] => ",
+  "[Bignum, 4611686018427387904]"],
+ ["[Fixnum, -4611686018427387904] gcd [Bignum, -4611686018427387905] => ",
+  "[Fixnum, 1]"],
+ ["[Fixnum, -4611686018427387904] gcd [Bignum, 4611686018427387905] => ",
+  "[Fixnum, 1]"],
+ ["[Bignum, -4611686018427387905] gcd [Fixnum, 1] => ", "[Fixnum, 1]"],
+ ["[Bignum, -4611686018427387905] gcd [Fixnum, 2] => ", "[Fixnum, 1]"],
+ ["[Bignum, -4611686018427387905] gcd [Fixnum, 4] => ", "[Fixnum, 1]"],
+ ["[Bignum, -4611686018427387905] gcd [Fixnum, 5] => ", "[Fixnum, 5]"],
+ ["[Bignum, -4611686018427387905] gcd [Fixnum, 25] => ", "[Fixnum, 5]"],
+ ["[Bignum, -4611686018427387905] gcd [Fixnum, -1] => ", "[Fixnum, 1]"],
+ ["[Bignum, -4611686018427387905] gcd [Fixnum, -2] => ", "[Fixnum, 1]"],
+ ["[Bignum, -4611686018427387905] gcd [Fixnum, -4] => ", "[Fixnum, 1]"],
+ ["[Bignum, -4611686018427387905] gcd [Fixnum, -5] => ", "[Fixnum, 5]"],
+ ["[Bignum, -4611686018427387905] gcd [Fixnum, -25] => ", "[Fixnum, 5]"],
+ ["[Bignum, -4611686018427387905] gcd [Fixnum, 4611686018427387903] => ",
+  "[Fixnum, 1]"],
+ ["[Bignum, -4611686018427387905] gcd [Fixnum, -4611686018427387903] => ",
+  "[Fixnum, 1]"],
+ ["[Bignum, -4611686018427387905] gcd [Fixnum, -4611686018427387904] => ",
+  "[Fixnum, 1]"],
+ ["[Bignum, -4611686018427387905] gcd [Bignum, 4611686018427387904] => ",
+  "[Fixnum, 1]"],
+ ["[Bignum, -4611686018427387905] gcd [Bignum, 4611686018427387904] => ",
+  "[Fixnum, 1]"],
+ ["[Bignum, -4611686018427387905] gcd [Fixnum, -4611686018427387904] => ",
+  "[Fixnum, 1]"],
+ ["[Bignum, -4611686018427387905] gcd [Bignum, -4611686018427387905] => ",
+  "[Bignum, 4611686018427387905]"],
+ ["[Bignum, -4611686018427387905] gcd [Bignum, 4611686018427387905] => ",
+  "[Bignum, 4611686018427387905]"],
+ ["[Bignum, 4611686018427387905] gcd [Fixnum, 1] => ", "[Fixnum, 1]"],
+ ["[Bignum, 4611686018427387905] gcd [Fixnum, 2] => ", "[Fixnum, 1]"],
+ ["[Bignum, 4611686018427387905] gcd [Fixnum, 4] => ", "[Fixnum, 1]"],
+ ["[Bignum, 4611686018427387905] gcd [Fixnum, 5] => ", "[Fixnum, 5]"],
+ ["[Bignum, 4611686018427387905] gcd [Fixnum, 25] => ", "[Fixnum, 5]"],
+ ["[Bignum, 4611686018427387905] gcd [Fixnum, -1] => ", "[Fixnum, 1]"],
+ ["[Bignum, 4611686018427387905] gcd [Fixnum, -2] => ", "[Fixnum, 1]"],
+ ["[Bignum, 4611686018427387905] gcd [Fixnum, -4] => ", "[Fixnum, 1]"],
+ ["[Bignum, 4611686018427387905] gcd [Fixnum, -5] => ", "[Fixnum, 5]"],
+ ["[Bignum, 4611686018427387905] gcd [Fixnum, -25] => ", "[Fixnum, 5]"],
+ ["[Bignum, 4611686018427387905] gcd [Fixnum, 4611686018427387903] => ",
+  "[Fixnum, 1]"],
+ ["[Bignum, 4611686018427387905] gcd [Fixnum, -4611686018427387903] => ",
+  "[Fixnum, 1]"],
+ ["[Bignum, 4611686018427387905] gcd [Fixnum, -4611686018427387904] => ",
+  "[Fixnum, 1]"],
+ ["[Bignum, 4611686018427387905] gcd [Bignum, 4611686018427387904] => ",
+  "[Fixnum, 1]"],
+ ["[Bignum, 4611686018427387905] gcd [Bignum, 4611686018427387904] => ",
+  "[Fixnum, 1]"],
+ ["[Bignum, 4611686018427387905] gcd [Fixnum, -4611686018427387904] => ",
+  "[Fixnum, 1]"],
+ ["[Bignum, 4611686018427387905] gcd [Bignum, -4611686018427387905] => ",
+  "[Bignum, 4611686018427387905]"],
+ ["[Bignum, 4611686018427387905] gcd [Bignum, 4611686018427387905] => ",
+  "[Bignum, 4611686018427387905]"]]
+when 'i686', 'i386'
+  # values generated by ruby 1.8.7 (2009-06-12 patchlevel 174) [i486-linux]
+@@expected = 
+[["[Fixnum, 1] gcd [Fixnum, 1] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 1] gcd [Fixnum, 2] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 1] gcd [Fixnum, 4] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 1] gcd [Fixnum, 5] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 1] gcd [Fixnum, 25] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 1] gcd [Fixnum, -1] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 1] gcd [Fixnum, -2] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 1] gcd [Fixnum, -4] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 1] gcd [Fixnum, -5] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 1] gcd [Fixnum, -25] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 1] gcd [Fixnum, 1073741823] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 1] gcd [Fixnum, -1073741823] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 1] gcd [Fixnum, -1073741824] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 1] gcd [Bignum, 1073741824] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 1] gcd [Bignum, 1073741824] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 1] gcd [Fixnum, -1073741824] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 1] gcd [Bignum, -1073741825] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 1] gcd [Bignum, 1073741825] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 2] gcd [Fixnum, 1] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 2] gcd [Fixnum, 2] => ", "[Fixnum, 2]"],
+ ["[Fixnum, 2] gcd [Fixnum, 4] => ", "[Fixnum, 2]"],
+ ["[Fixnum, 2] gcd [Fixnum, 5] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 2] gcd [Fixnum, 25] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 2] gcd [Fixnum, -1] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 2] gcd [Fixnum, -2] => ", "[Fixnum, 2]"],
+ ["[Fixnum, 2] gcd [Fixnum, -4] => ", "[Fixnum, 2]"],
+ ["[Fixnum, 2] gcd [Fixnum, -5] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 2] gcd [Fixnum, -25] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 2] gcd [Fixnum, 1073741823] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 2] gcd [Fixnum, -1073741823] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 2] gcd [Fixnum, -1073741824] => ", "[Fixnum, 2]"],
+ ["[Fixnum, 2] gcd [Bignum, 1073741824] => ", "[Fixnum, 2]"],
+ ["[Fixnum, 2] gcd [Bignum, 1073741824] => ", "[Fixnum, 2]"],
+ ["[Fixnum, 2] gcd [Fixnum, -1073741824] => ", "[Fixnum, 2]"],
+ ["[Fixnum, 2] gcd [Bignum, -1073741825] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 2] gcd [Bignum, 1073741825] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 4] gcd [Fixnum, 1] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 4] gcd [Fixnum, 2] => ", "[Fixnum, 2]"],
+ ["[Fixnum, 4] gcd [Fixnum, 4] => ", "[Fixnum, 4]"],
+ ["[Fixnum, 4] gcd [Fixnum, 5] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 4] gcd [Fixnum, 25] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 4] gcd [Fixnum, -1] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 4] gcd [Fixnum, -2] => ", "[Fixnum, 2]"],
+ ["[Fixnum, 4] gcd [Fixnum, -4] => ", "[Fixnum, 4]"],
+ ["[Fixnum, 4] gcd [Fixnum, -5] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 4] gcd [Fixnum, -25] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 4] gcd [Fixnum, 1073741823] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 4] gcd [Fixnum, -1073741823] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 4] gcd [Fixnum, -1073741824] => ", "[Fixnum, 4]"],
+ ["[Fixnum, 4] gcd [Bignum, 1073741824] => ", "[Fixnum, 4]"],
+ ["[Fixnum, 4] gcd [Bignum, 1073741824] => ", "[Fixnum, 4]"],
+ ["[Fixnum, 4] gcd [Fixnum, -1073741824] => ", "[Fixnum, 4]"],
+ ["[Fixnum, 4] gcd [Bignum, -1073741825] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 4] gcd [Bignum, 1073741825] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 5] gcd [Fixnum, 1] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 5] gcd [Fixnum, 2] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 5] gcd [Fixnum, 4] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 5] gcd [Fixnum, 5] => ", "[Fixnum, 5]"],
+ ["[Fixnum, 5] gcd [Fixnum, 25] => ", "[Fixnum, 5]"],
+ ["[Fixnum, 5] gcd [Fixnum, -1] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 5] gcd [Fixnum, -2] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 5] gcd [Fixnum, -4] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 5] gcd [Fixnum, -5] => ", "[Fixnum, 5]"],
+ ["[Fixnum, 5] gcd [Fixnum, -25] => ", "[Fixnum, 5]"],
+ ["[Fixnum, 5] gcd [Fixnum, 1073741823] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 5] gcd [Fixnum, -1073741823] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 5] gcd [Fixnum, -1073741824] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 5] gcd [Bignum, 1073741824] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 5] gcd [Bignum, 1073741824] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 5] gcd [Fixnum, -1073741824] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 5] gcd [Bignum, -1073741825] => ", "[Fixnum, 5]"],
+ ["[Fixnum, 5] gcd [Bignum, 1073741825] => ", "[Fixnum, 5]"],
+ ["[Fixnum, 25] gcd [Fixnum, 1] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 25] gcd [Fixnum, 2] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 25] gcd [Fixnum, 4] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 25] gcd [Fixnum, 5] => ", "[Fixnum, 5]"],
+ ["[Fixnum, 25] gcd [Fixnum, 25] => ", "[Fixnum, 25]"],
+ ["[Fixnum, 25] gcd [Fixnum, -1] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 25] gcd [Fixnum, -2] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 25] gcd [Fixnum, -4] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 25] gcd [Fixnum, -5] => ", "[Fixnum, 5]"],
+ ["[Fixnum, 25] gcd [Fixnum, -25] => ", "[Fixnum, 25]"],
+ ["[Fixnum, 25] gcd [Fixnum, 1073741823] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 25] gcd [Fixnum, -1073741823] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 25] gcd [Fixnum, -1073741824] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 25] gcd [Bignum, 1073741824] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 25] gcd [Bignum, 1073741824] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 25] gcd [Fixnum, -1073741824] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 25] gcd [Bignum, -1073741825] => ", "[Fixnum, 25]"],
+ ["[Fixnum, 25] gcd [Bignum, 1073741825] => ", "[Fixnum, 25]"],
+ ["[Fixnum, -1] gcd [Fixnum, 1] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1] gcd [Fixnum, 2] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1] gcd [Fixnum, 4] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1] gcd [Fixnum, 5] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1] gcd [Fixnum, 25] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1] gcd [Fixnum, -1] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1] gcd [Fixnum, -2] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1] gcd [Fixnum, -4] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1] gcd [Fixnum, -5] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1] gcd [Fixnum, -25] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1] gcd [Fixnum, 1073741823] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1] gcd [Fixnum, -1073741823] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1] gcd [Fixnum, -1073741824] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1] gcd [Bignum, 1073741824] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1] gcd [Bignum, 1073741824] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1] gcd [Fixnum, -1073741824] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1] gcd [Bignum, -1073741825] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1] gcd [Bignum, 1073741825] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -2] gcd [Fixnum, 1] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -2] gcd [Fixnum, 2] => ", "[Fixnum, 2]"],
+ ["[Fixnum, -2] gcd [Fixnum, 4] => ", "[Fixnum, 2]"],
+ ["[Fixnum, -2] gcd [Fixnum, 5] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -2] gcd [Fixnum, 25] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -2] gcd [Fixnum, -1] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -2] gcd [Fixnum, -2] => ", "[Fixnum, 2]"],
+ ["[Fixnum, -2] gcd [Fixnum, -4] => ", "[Fixnum, 2]"],
+ ["[Fixnum, -2] gcd [Fixnum, -5] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -2] gcd [Fixnum, -25] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -2] gcd [Fixnum, 1073741823] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -2] gcd [Fixnum, -1073741823] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -2] gcd [Fixnum, -1073741824] => ", "[Fixnum, 2]"],
+ ["[Fixnum, -2] gcd [Bignum, 1073741824] => ", "[Fixnum, 2]"],
+ ["[Fixnum, -2] gcd [Bignum, 1073741824] => ", "[Fixnum, 2]"],
+ ["[Fixnum, -2] gcd [Fixnum, -1073741824] => ", "[Fixnum, 2]"],
+ ["[Fixnum, -2] gcd [Bignum, -1073741825] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -2] gcd [Bignum, 1073741825] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -4] gcd [Fixnum, 1] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -4] gcd [Fixnum, 2] => ", "[Fixnum, 2]"],
+ ["[Fixnum, -4] gcd [Fixnum, 4] => ", "[Fixnum, 4]"],
+ ["[Fixnum, -4] gcd [Fixnum, 5] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -4] gcd [Fixnum, 25] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -4] gcd [Fixnum, -1] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -4] gcd [Fixnum, -2] => ", "[Fixnum, 2]"],
+ ["[Fixnum, -4] gcd [Fixnum, -4] => ", "[Fixnum, 4]"],
+ ["[Fixnum, -4] gcd [Fixnum, -5] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -4] gcd [Fixnum, -25] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -4] gcd [Fixnum, 1073741823] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -4] gcd [Fixnum, -1073741823] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -4] gcd [Fixnum, -1073741824] => ", "[Fixnum, 4]"],
+ ["[Fixnum, -4] gcd [Bignum, 1073741824] => ", "[Fixnum, 4]"],
+ ["[Fixnum, -4] gcd [Bignum, 1073741824] => ", "[Fixnum, 4]"],
+ ["[Fixnum, -4] gcd [Fixnum, -1073741824] => ", "[Fixnum, 4]"],
+ ["[Fixnum, -4] gcd [Bignum, -1073741825] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -4] gcd [Bignum, 1073741825] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -5] gcd [Fixnum, 1] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -5] gcd [Fixnum, 2] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -5] gcd [Fixnum, 4] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -5] gcd [Fixnum, 5] => ", "[Fixnum, 5]"],
+ ["[Fixnum, -5] gcd [Fixnum, 25] => ", "[Fixnum, 5]"],
+ ["[Fixnum, -5] gcd [Fixnum, -1] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -5] gcd [Fixnum, -2] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -5] gcd [Fixnum, -4] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -5] gcd [Fixnum, -5] => ", "[Fixnum, 5]"],
+ ["[Fixnum, -5] gcd [Fixnum, -25] => ", "[Fixnum, 5]"],
+ ["[Fixnum, -5] gcd [Fixnum, 1073741823] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -5] gcd [Fixnum, -1073741823] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -5] gcd [Fixnum, -1073741824] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -5] gcd [Bignum, 1073741824] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -5] gcd [Bignum, 1073741824] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -5] gcd [Fixnum, -1073741824] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -5] gcd [Bignum, -1073741825] => ", "[Fixnum, 5]"],
+ ["[Fixnum, -5] gcd [Bignum, 1073741825] => ", "[Fixnum, 5]"],
+ ["[Fixnum, -25] gcd [Fixnum, 1] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -25] gcd [Fixnum, 2] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -25] gcd [Fixnum, 4] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -25] gcd [Fixnum, 5] => ", "[Fixnum, 5]"],
+ ["[Fixnum, -25] gcd [Fixnum, 25] => ", "[Fixnum, 25]"],
+ ["[Fixnum, -25] gcd [Fixnum, -1] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -25] gcd [Fixnum, -2] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -25] gcd [Fixnum, -4] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -25] gcd [Fixnum, -5] => ", "[Fixnum, 5]"],
+ ["[Fixnum, -25] gcd [Fixnum, -25] => ", "[Fixnum, 25]"],
+ ["[Fixnum, -25] gcd [Fixnum, 1073741823] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -25] gcd [Fixnum, -1073741823] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -25] gcd [Fixnum, -1073741824] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -25] gcd [Bignum, 1073741824] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -25] gcd [Bignum, 1073741824] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -25] gcd [Fixnum, -1073741824] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -25] gcd [Bignum, -1073741825] => ", "[Fixnum, 25]"],
+ ["[Fixnum, -25] gcd [Bignum, 1073741825] => ", "[Fixnum, 25]"],
+ ["[Fixnum, 1073741823] gcd [Fixnum, 1] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 1073741823] gcd [Fixnum, 2] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 1073741823] gcd [Fixnum, 4] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 1073741823] gcd [Fixnum, 5] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 1073741823] gcd [Fixnum, 25] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 1073741823] gcd [Fixnum, -1] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 1073741823] gcd [Fixnum, -2] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 1073741823] gcd [Fixnum, -4] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 1073741823] gcd [Fixnum, -5] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 1073741823] gcd [Fixnum, -25] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 1073741823] gcd [Fixnum, 1073741823] => ", "[Fixnum, 1073741823]"],
+ ["[Fixnum, 1073741823] gcd [Fixnum, -1073741823] => ",
+  "[Fixnum, 1073741823]"],
+ ["[Fixnum, 1073741823] gcd [Fixnum, -1073741824] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 1073741823] gcd [Bignum, 1073741824] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 1073741823] gcd [Bignum, 1073741824] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 1073741823] gcd [Fixnum, -1073741824] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 1073741823] gcd [Bignum, -1073741825] => ", "[Fixnum, 1]"],
+ ["[Fixnum, 1073741823] gcd [Bignum, 1073741825] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1073741823] gcd [Fixnum, 1] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1073741823] gcd [Fixnum, 2] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1073741823] gcd [Fixnum, 4] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1073741823] gcd [Fixnum, 5] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1073741823] gcd [Fixnum, 25] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1073741823] gcd [Fixnum, -1] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1073741823] gcd [Fixnum, -2] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1073741823] gcd [Fixnum, -4] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1073741823] gcd [Fixnum, -5] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1073741823] gcd [Fixnum, -25] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1073741823] gcd [Fixnum, 1073741823] => ",
+  "[Fixnum, 1073741823]"],
+ ["[Fixnum, -1073741823] gcd [Fixnum, -1073741823] => ",
+  "[Fixnum, 1073741823]"],
+ ["[Fixnum, -1073741823] gcd [Fixnum, -1073741824] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1073741823] gcd [Bignum, 1073741824] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1073741823] gcd [Bignum, 1073741824] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1073741823] gcd [Fixnum, -1073741824] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1073741823] gcd [Bignum, -1073741825] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1073741823] gcd [Bignum, 1073741825] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1073741824] gcd [Fixnum, 1] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1073741824] gcd [Fixnum, 2] => ", "[Fixnum, 2]"],
+ ["[Fixnum, -1073741824] gcd [Fixnum, 4] => ", "[Fixnum, 4]"],
+ ["[Fixnum, -1073741824] gcd [Fixnum, 5] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1073741824] gcd [Fixnum, 25] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1073741824] gcd [Fixnum, -1] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1073741824] gcd [Fixnum, -2] => ", "[Fixnum, 2]"],
+ ["[Fixnum, -1073741824] gcd [Fixnum, -4] => ", "[Fixnum, 4]"],
+ ["[Fixnum, -1073741824] gcd [Fixnum, -5] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1073741824] gcd [Fixnum, -25] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1073741824] gcd [Fixnum, 1073741823] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1073741824] gcd [Fixnum, -1073741823] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1073741824] gcd [Fixnum, -1073741824] => ",
+  "[Bignum, 1073741824]"],
+ ["[Fixnum, -1073741824] gcd [Bignum, 1073741824] => ",
+  "[Bignum, 1073741824]"],
+ ["[Fixnum, -1073741824] gcd [Bignum, 1073741824] => ",
+  "[Bignum, 1073741824]"],
+ ["[Fixnum, -1073741824] gcd [Fixnum, -1073741824] => ",
+  "[Bignum, 1073741824]"],
+ ["[Fixnum, -1073741824] gcd [Bignum, -1073741825] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1073741824] gcd [Bignum, 1073741825] => ", "[Fixnum, 1]"],
+ ["[Bignum, 1073741824] gcd [Fixnum, 1] => ", "[Fixnum, 1]"],
+ ["[Bignum, 1073741824] gcd [Fixnum, 2] => ", "[Fixnum, 2]"],
+ ["[Bignum, 1073741824] gcd [Fixnum, 4] => ", "[Fixnum, 4]"],
+ ["[Bignum, 1073741824] gcd [Fixnum, 5] => ", "[Fixnum, 1]"],
+ ["[Bignum, 1073741824] gcd [Fixnum, 25] => ", "[Fixnum, 1]"],
+ ["[Bignum, 1073741824] gcd [Fixnum, -1] => ", "[Fixnum, 1]"],
+ ["[Bignum, 1073741824] gcd [Fixnum, -2] => ", "[Fixnum, 2]"],
+ ["[Bignum, 1073741824] gcd [Fixnum, -4] => ", "[Fixnum, 4]"],
+ ["[Bignum, 1073741824] gcd [Fixnum, -5] => ", "[Fixnum, 1]"],
+ ["[Bignum, 1073741824] gcd [Fixnum, -25] => ", "[Fixnum, 1]"],
+ ["[Bignum, 1073741824] gcd [Fixnum, 1073741823] => ", "[Fixnum, 1]"],
+ ["[Bignum, 1073741824] gcd [Fixnum, -1073741823] => ", "[Fixnum, 1]"],
+ ["[Bignum, 1073741824] gcd [Fixnum, -1073741824] => ",
+  "[Bignum, 1073741824]"],
+ ["[Bignum, 1073741824] gcd [Bignum, 1073741824] => ", "[Bignum, 1073741824]"],
+ ["[Bignum, 1073741824] gcd [Bignum, 1073741824] => ", "[Bignum, 1073741824]"],
+ ["[Bignum, 1073741824] gcd [Fixnum, -1073741824] => ",
+  "[Bignum, 1073741824]"],
+ ["[Bignum, 1073741824] gcd [Bignum, -1073741825] => ", "[Fixnum, 1]"],
+ ["[Bignum, 1073741824] gcd [Bignum, 1073741825] => ", "[Fixnum, 1]"],
+ ["[Bignum, 1073741824] gcd [Fixnum, 1] => ", "[Fixnum, 1]"],
+ ["[Bignum, 1073741824] gcd [Fixnum, 2] => ", "[Fixnum, 2]"],
+ ["[Bignum, 1073741824] gcd [Fixnum, 4] => ", "[Fixnum, 4]"],
+ ["[Bignum, 1073741824] gcd [Fixnum, 5] => ", "[Fixnum, 1]"],
+ ["[Bignum, 1073741824] gcd [Fixnum, 25] => ", "[Fixnum, 1]"],
+ ["[Bignum, 1073741824] gcd [Fixnum, -1] => ", "[Fixnum, 1]"],
+ ["[Bignum, 1073741824] gcd [Fixnum, -2] => ", "[Fixnum, 2]"],
+ ["[Bignum, 1073741824] gcd [Fixnum, -4] => ", "[Fixnum, 4]"],
+ ["[Bignum, 1073741824] gcd [Fixnum, -5] => ", "[Fixnum, 1]"],
+ ["[Bignum, 1073741824] gcd [Fixnum, -25] => ", "[Fixnum, 1]"],
+ ["[Bignum, 1073741824] gcd [Fixnum, 1073741823] => ", "[Fixnum, 1]"],
+ ["[Bignum, 1073741824] gcd [Fixnum, -1073741823] => ", "[Fixnum, 1]"],
+ ["[Bignum, 1073741824] gcd [Fixnum, -1073741824] => ",
+  "[Bignum, 1073741824]"],
+ ["[Bignum, 1073741824] gcd [Bignum, 1073741824] => ", "[Bignum, 1073741824]"],
+ ["[Bignum, 1073741824] gcd [Bignum, 1073741824] => ", "[Bignum, 1073741824]"],
+ ["[Bignum, 1073741824] gcd [Fixnum, -1073741824] => ",
+  "[Bignum, 1073741824]"],
+ ["[Bignum, 1073741824] gcd [Bignum, -1073741825] => ", "[Fixnum, 1]"],
+ ["[Bignum, 1073741824] gcd [Bignum, 1073741825] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1073741824] gcd [Fixnum, 1] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1073741824] gcd [Fixnum, 2] => ", "[Fixnum, 2]"],
+ ["[Fixnum, -1073741824] gcd [Fixnum, 4] => ", "[Fixnum, 4]"],
+ ["[Fixnum, -1073741824] gcd [Fixnum, 5] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1073741824] gcd [Fixnum, 25] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1073741824] gcd [Fixnum, -1] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1073741824] gcd [Fixnum, -2] => ", "[Fixnum, 2]"],
+ ["[Fixnum, -1073741824] gcd [Fixnum, -4] => ", "[Fixnum, 4]"],
+ ["[Fixnum, -1073741824] gcd [Fixnum, -5] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1073741824] gcd [Fixnum, -25] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1073741824] gcd [Fixnum, 1073741823] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1073741824] gcd [Fixnum, -1073741823] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1073741824] gcd [Fixnum, -1073741824] => ",
+  "[Bignum, 1073741824]"],
+ ["[Fixnum, -1073741824] gcd [Bignum, 1073741824] => ",
+  "[Bignum, 1073741824]"],
+ ["[Fixnum, -1073741824] gcd [Bignum, 1073741824] => ",
+  "[Bignum, 1073741824]"],
+ ["[Fixnum, -1073741824] gcd [Fixnum, -1073741824] => ",
+  "[Bignum, 1073741824]"],
+ ["[Fixnum, -1073741824] gcd [Bignum, -1073741825] => ", "[Fixnum, 1]"],
+ ["[Fixnum, -1073741824] gcd [Bignum, 1073741825] => ", "[Fixnum, 1]"],
+ ["[Bignum, -1073741825] gcd [Fixnum, 1] => ", "[Fixnum, 1]"],
+ ["[Bignum, -1073741825] gcd [Fixnum, 2] => ", "[Fixnum, 1]"],
+ ["[Bignum, -1073741825] gcd [Fixnum, 4] => ", "[Fixnum, 1]"],
+ ["[Bignum, -1073741825] gcd [Fixnum, 5] => ", "[Fixnum, 5]"],
+ ["[Bignum, -1073741825] gcd [Fixnum, 25] => ", "[Fixnum, 25]"],
+ ["[Bignum, -1073741825] gcd [Fixnum, -1] => ", "[Fixnum, 1]"],
+ ["[Bignum, -1073741825] gcd [Fixnum, -2] => ", "[Fixnum, 1]"],
+ ["[Bignum, -1073741825] gcd [Fixnum, -4] => ", "[Fixnum, 1]"],
+ ["[Bignum, -1073741825] gcd [Fixnum, -5] => ", "[Fixnum, 5]"],
+ ["[Bignum, -1073741825] gcd [Fixnum, -25] => ", "[Fixnum, 25]"],
+ ["[Bignum, -1073741825] gcd [Fixnum, 1073741823] => ", "[Fixnum, 1]"],
+ ["[Bignum, -1073741825] gcd [Fixnum, -1073741823] => ", "[Fixnum, 1]"],
+ ["[Bignum, -1073741825] gcd [Fixnum, -1073741824] => ", "[Fixnum, 1]"],
+ ["[Bignum, -1073741825] gcd [Bignum, 1073741824] => ", "[Fixnum, 1]"],
+ ["[Bignum, -1073741825] gcd [Bignum, 1073741824] => ", "[Fixnum, 1]"],
+ ["[Bignum, -1073741825] gcd [Fixnum, -1073741824] => ", "[Fixnum, 1]"],
+ ["[Bignum, -1073741825] gcd [Bignum, -1073741825] => ",
+  "[Bignum, 1073741825]"],
+ ["[Bignum, -1073741825] gcd [Bignum, 1073741825] => ",
+  "[Bignum, 1073741825]"],
+ ["[Bignum, 1073741825] gcd [Fixnum, 1] => ", "[Fixnum, 1]"],
+ ["[Bignum, 1073741825] gcd [Fixnum, 2] => ", "[Fixnum, 1]"],
+ ["[Bignum, 1073741825] gcd [Fixnum, 4] => ", "[Fixnum, 1]"],
+ ["[Bignum, 1073741825] gcd [Fixnum, 5] => ", "[Fixnum, 5]"],
+ ["[Bignum, 1073741825] gcd [Fixnum, 25] => ", "[Fixnum, 25]"],
+ ["[Bignum, 1073741825] gcd [Fixnum, -1] => ", "[Fixnum, 1]"],
+ ["[Bignum, 1073741825] gcd [Fixnum, -2] => ", "[Fixnum, 1]"],
+ ["[Bignum, 1073741825] gcd [Fixnum, -4] => ", "[Fixnum, 1]"],
+ ["[Bignum, 1073741825] gcd [Fixnum, -5] => ", "[Fixnum, 5]"],
+ ["[Bignum, 1073741825] gcd [Fixnum, -25] => ", "[Fixnum, 25]"],
+ ["[Bignum, 1073741825] gcd [Fixnum, 1073741823] => ", "[Fixnum, 1]"],
+ ["[Bignum, 1073741825] gcd [Fixnum, -1073741823] => ", "[Fixnum, 1]"],
+ ["[Bignum, 1073741825] gcd [Fixnum, -1073741824] => ", "[Fixnum, 1]"],
+ ["[Bignum, 1073741825] gcd [Bignum, 1073741824] => ", "[Fixnum, 1]"],
+ ["[Bignum, 1073741825] gcd [Bignum, 1073741824] => ", "[Fixnum, 1]"],
+ ["[Bignum, 1073741825] gcd [Fixnum, -1073741824] => ", "[Fixnum, 1]"],
+ ["[Bignum, 1073741825] gcd [Bignum, -1073741825] => ",
+  "[Bignum, 1073741825]"],
+ ["[Bignum, 1073741825] gcd [Bignum, 1073741825] => ", "[Bignum, 1073741825]"]]
+else
+  pp RbConfig::CONFIG
+  @@expected = nil
+end
+
+  def test_results
+    values = 
+      [
+       1, 2, 4, 5, 25,
+       -1, -2, -4, -5, -25,
+       @@biggest_positive_fixnum, - @@biggest_positive_fixnum,
+       @@biggest_negative_fixnum, - @@biggest_negative_fixnum,
+       @@smallest_positive_bignum, - @@smallest_positive_bignum,
+       @@smallest_negative_bignum, - @@smallest_negative_bignum,
+      ]
+
+    result = [ ]
+    values.each do | x |
+      values.each do | y |
+        result <<
+          [ "#{xc(x)} gcd #{xc(y)} => ", 
+            begin
+              xc(x.gcd(y))
+            rescue => err
+              err
+            end
+          ]
+      end
+    end
+    
+    if @@expected 
+      if result != @@expected
+        @@expected.each_with_index do | x, i |
+          y = result[i]
+          assert_equal x, y
+        end
+      end
+    else
+      puts "@@expected = "
+      pp result
+    end
+  end
+end
--- /dev/null
+++ b/test/rational/test_rational.rb
@@ -0,0 +1,1205 @@
+require 'test/unit'
+require 'rational'
+
+class RationalSub < Rational; end
+
+class Rational_Test < Test::Unit::TestCase
+
+  def setup
+    @complex = defined?(Complex)
+    if @complex
+      @keiju = Complex.instance_variables.include?(:@RCS_ID)
+    end
+    seps = [File::SEPARATOR, File::ALT_SEPARATOR].compact.map{|x| Regexp.escape(x)}.join("|")
+    @unify = $".grep(/(?:^|#{seps})mathn(?:\.(?:rb|so))?/).size != 0
+  end
+
+  ## [1.8] Rational#convert is missing
+=begin
+  def test_ratsub
+    c = RationalSub.__send__(:convert, 1)
+
+    assert_kind_of(Numeric, c)
+
+    if @unify
+      assert_instance_of(Fixnum, c)
+    else
+      assert_instance_of(RationalSub, c)
+
+      c2 = c + 1
+      assert_instance_of(RationalSub, c2)
+      c2 = c - 1
+      assert_instance_of(RationalSub, c2)
+
+      c3 = c - c2
+      assert_instance_of(RationalSub, c3)
+
+      s = Marshal.dump(c)
+      c5 = Marshal.load(s)
+      assert_equal(c, c5)
+      assert_instance_of(RationalSub, c5)
+    end
+
+    c1 = Rational(1)
+    assert_equal(c1.hash, c.hash, '[ruby-dev:38850]')
+    assert_equal([true, true], [c.eql?(c1), c1.eql?(c)])
+  end
+=end
+
+  def test_eql_p
+    c = Rational(0)
+    c2 = Rational(0)
+    c3 = Rational(1)
+
+    assert_equal(true, c.eql?(c2))
+    assert_equal(false, c.eql?(c3))
+
+    if @unify
+      assert_equal(true, c.eql?(0))
+    else
+      assert_equal(false, c.eql?(0))
+    end
+  end
+
+  def test_hash
+    assert_instance_of(Fixnum, Rational(1,2).hash)
+
+    h = {}
+    h[Rational(0)] = 0
+    h[Rational(1,1)] = 1
+    h[Rational(2,1)] = 2
+    h[Rational(3,1)] = 3
+
+    assert_equal(4, h.size)
+    assert_equal(2, h[Rational(2,1)])
+
+    h[Rational(0,1)] = 9
+    assert_equal(4, h.size)
+  end
+
+  def test_freeze
+    c = Rational(1)
+    c.freeze
+    unless @unify
+      assert_equal(true, c.frozen?)
+    end
+    assert_instance_of(String, c.to_s)
+  end
+
+  def test_conv
+    c = Rational(0,1)
+    assert_equal(Rational(0,1), c)
+
+    c = Rational(2**32, 2**32)
+    assert_equal(Rational(2**32,2**32), c)
+    assert_equal([1,1], [c.numerator,c.denominator])
+
+    c = Rational(-2**32, 2**32)
+    assert_equal(Rational(-2**32,2**32), c)
+    assert_equal([-1,1], [c.numerator,c.denominator])
+
+    c = Rational(2**32, -2**32)
+    assert_equal(Rational(2**32,-2**32), c)
+    assert_equal([-1,1], [c.numerator,c.denominator])
+
+    c = Rational(-2**32, -2**32)
+    assert_equal(Rational(-2**32,-2**32), c)
+    assert_equal([1,1], [c.numerator,c.denominator])
+
+    ## [1.8] Rational() blindly expects arguments to be integers
+=begin
+    c = Rational(Rational(1,2),2)
+    assert_equal(Rational(1,4), c)
+
+    c = Rational(2,Rational(1,2))
+    assert_equal(Rational(4), c)
+
+    c = Rational(Rational(1,2),Rational(1,2))
+    assert_equal(Rational(1), c)
+=end
+
+    if @complex && !@keiju
+      c = Rational(Complex(1,2),2)
+      assert_equal(Complex(Rational(1,2),1), c)
+
+      c = Rational(2,Complex(1,2))
+      assert_equal(Complex(Rational(2,5),Rational(-4,5)), c)
+
+      c = Rational(Complex(1,2),Complex(1,2))
+      assert_equal(Rational(1), c)
+    end
+
+    assert_equal(Rational(3),Rational(3))
+    assert_equal(Rational(1),Rational(3,3))
+    ## [1.8] Float#to_r is missing
+=begin
+    assert_equal(3.3.to_r,Rational(3.3))
+=end
+    ## [1.8] Rational() blindly expects arguments to be integers
+=begin
+    assert_equal(1,Rational(3.3,3.3))
+    assert_equal(Rational(3),Rational('3'))
+    assert_equal(Rational(1),Rational('3.0','3.0'))
+    assert_equal(Rational(1),Rational('3/3','3/3'))
+    assert_raise(TypeError){Rational(nil)}
+    assert_raise(ArgumentError){Rational('')}
+    assert_raise(TypeError){Rational(Object.new)}
+=end
+    assert_raise(ArgumentError){Rational()}
+    assert_raise(ArgumentError){Rational(1,2,3)}
+
+    ## [1.8] Rational() blindly expects arguments to be integers
+=begin
+    if (0.0/0).nan?
+      assert_raise(FloatDomainError){Rational(0.0/0)}
+    end
+    if (1.0/0).infinite?
+      assert_raise(FloatDomainError){Rational(1.0/0)}
+    end
+=end
+  end
+
+  def test_attr
+    c = Rational(4)
+
+    assert_equal(4, c.numerator)
+    assert_equal(1, c.denominator)
+
+    c = Rational(4,5)
+
+    assert_equal(4, c.numerator)
+    assert_equal(5, c.denominator)
+
+    c = Rational(4)
+
+    assert_equal(4, c.numerator)
+    assert_equal(1, c.denominator)
+
+    c = Rational(4,5)
+
+    assert_equal(4, c.numerator)
+    assert_equal(5, c.denominator)
+
+    c = Rational(4)
+
+    assert_equal(4, c.numerator)
+    assert_equal(1, c.denominator)
+
+    c = Rational(4,5)
+
+    assert_equal(4, c.numerator)
+    assert_equal(5, c.denominator)
+  end
+
+  def test_attr2
+    c = Rational(1)
+
+    if @unify
+=begin
+      assert_equal(true, c.finite?)
+      assert_equal(false, c.infinite?)
+      assert_equal(false, c.nan?)
+      assert_equal(true, c.integer?)
+      assert_equal(false, c.float?)
+      assert_equal(true, c.rational?)
+=end
+      ## [1.8] Numeric#real? is missing
+=begin
+      assert_equal(true, c.real?)
+=end
+=begin
+      assert_equal(false, c.complex?)
+      assert_equal(true, c.exact?)
+      assert_equal(false, c.inexact?)
+=end
+    else
+=begin
+      assert_equal(true, c.finite?)
+      assert_equal(false, c.infinite?)
+      assert_equal(false, c.nan?)
+      assert_equal(false, c.integer?)
+      assert_equal(false, c.float?)
+      assert_equal(true, c.rational?)
+=end
+      ## [1.8] Numeric#real? is missing
+=begin
+      assert_equal(true, c.real?)
+=end
+=begin
+      assert_equal(false, c.complex?)
+      assert_equal(true, c.exact?)
+      assert_equal(false, c.inexact?)
+=end
+    end
+
+=begin
+    assert_equal(true, Rational(0).positive?)
+    assert_equal(true, Rational(1).positive?)
+    assert_equal(false, Rational(-1).positive?)
+    assert_equal(false, Rational(0).negative?)
+    assert_equal(false, Rational(1).negative?)
+    assert_equal(true, Rational(-1).negative?)
+
+    assert_equal(0, Rational(0).sign)
+    assert_equal(1, Rational(2).sign)
+    assert_equal(-1, Rational(-2).sign)
+=end
+
+    assert_equal(true, Rational(0).zero?)
+    assert_equal(true, Rational(0,1).zero?)
+    assert_equal(false, Rational(1,1).zero?)
+
+    assert_equal(nil, Rational(0).nonzero?)
+    assert_equal(nil, Rational(0,1).nonzero?)
+    assert_equal(Rational(1,1), Rational(1,1).nonzero?)
+  end
+
+  def test_uplus
+    assert_equal(Rational(1), +Rational(1))
+    assert_equal(Rational(-1), +Rational(-1))
+    assert_equal(Rational(1,1), +Rational(1,1))
+    assert_equal(Rational(-1,1), +Rational(-1,1))
+    assert_equal(Rational(-1,1), +Rational(1,-1))
+    assert_equal(Rational(1,1), +Rational(-1,-1))
+  end
+
+  def test_negate
+    assert_equal(Rational(-1), -Rational(1))
+    assert_equal(Rational(1), -Rational(-1))
+    assert_equal(Rational(-1,1), -Rational(1,1))
+    assert_equal(Rational(1,1), -Rational(-1,1))
+    assert_equal(Rational(1,1), -Rational(1,-1))
+    assert_equal(Rational(-1,1), -Rational(-1,-1))
+
+=begin
+    assert_equal(0, Rational(0).negate)
+    assert_equal(-2, Rational(2).negate)
+    assert_equal(2, Rational(-2).negate)
+=end
+  end
+
+  def test_add
+    c = Rational(1,2)
+    c2 = Rational(2,3)
+
+    assert_equal(Rational(7,6), c + c2)
+
+    assert_equal(Rational(5,2), c + 2)
+    assert_equal(2.5, c + 2.0)
+  end
+
+  def test_sub
+    c = Rational(1,2)
+    c2 = Rational(2,3)
+
+    assert_equal(Rational(-1,6), c - c2)
+
+    assert_equal(Rational(-3,2), c - 2)
+    assert_equal(-1.5, c - 2.0)
+  end
+
+  def test_mul
+    c = Rational(1,2)
+    c2 = Rational(2,3)
+
+    assert_equal(Rational(1,3), c * c2)
+
+    assert_equal(Rational(1,1), c * 2)
+    assert_equal(1.0, c * 2.0)
+  end
+
+  def test_div
+    c = Rational(1,2)
+    c2 = Rational(2,3)
+
+    assert_equal(Rational(3,4), c / c2)
+
+    assert_equal(Rational(1,4), c / 2)
+    assert_equal(0.25, c / 2.0)
+
+    assert_raise(ZeroDivisionError){Rational(1, 3) / 0}
+    assert_raise(ZeroDivisionError){Rational(1, 3) / Rational(0)}
+  end
+
+  def assert_eql(exp, act, *args)
+    unless Array === exp
+      exp = [exp]
+    end
+    unless Array === act
+      act = [act]
+    end
+    exp.zip(act).each do |e, a|
+      na = [e, a] + args
+      assert_equal(*na)
+      na = [e.class, a] + args
+      assert_instance_of(*na)
+    end
+  end
+
+  def test_idiv
+    c = Rational(1,2)
+    c2 = Rational(2,3)
+
+    assert_eql(0, c.div(c2))
+    assert_eql(0, c.div(2))
+    assert_eql(0, c.div(2.0))
+
+    c = Rational(301,100)
+    c2 = Rational(7,5)
+
+    assert_equal(2, c.div(c2))
+    assert_equal(-3, c.div(-c2))
+    assert_equal(-3, (-c).div(c2))
+    assert_equal(2, (-c).div(-c2))
+
+    c = Rational(301,100)
+    c2 = Rational(2)
+
+    assert_equal(1, c.div(c2))
+    assert_equal(-2, c.div(-c2))
+    assert_equal(-2, (-c).div(c2))
+    assert_equal(1, (-c).div(-c2))
+
+    unless @unify
+      c = Rational(11)
+      c2 = Rational(3)
+
+      assert_equal(3, c.div(c2))
+      assert_equal(-4, c.div(-c2))
+      assert_equal(-4, (-c).div(c2))
+      assert_equal(3, (-c).div(-c2))
+    end
+  end
+
+  def test_modulo
+    c = Rational(1,2)
+    c2 = Rational(2,3)
+
+    assert_eql(Rational(1,2), c.modulo(c2))
+    assert_eql(Rational(1,2), c.modulo(2))
+    assert_eql(0.5, c.modulo(2.0))
+
+    c = Rational(301,100)
+    c2 = Rational(7,5)
+
+    assert_equal(Rational(21,100), c.modulo(c2))
+    assert_equal(Rational(-119,100), c.modulo(-c2))
+    assert_equal(Rational(119,100), (-c).modulo(c2))
+    assert_equal(Rational(-21,100), (-c).modulo(-c2))
+
+    c = Rational(301,100)
+    c2 = Rational(2)
+
+    assert_equal(Rational(101,100), c.modulo(c2))
+    assert_equal(Rational(-99,100), c.modulo(-c2))
+    assert_equal(Rational(99,100), (-c).modulo(c2))
+    assert_equal(Rational(-101,100), (-c).modulo(-c2))
+
+    unless @unify
+      c = Rational(11)
+      c2 = Rational(3)
+
+      assert_equal(2, c.modulo(c2))
+      assert_equal(-1, c.modulo(-c2))
+      assert_equal(1, (-c).modulo(c2))
+      assert_equal(-2, (-c).modulo(-c2))
+    end
+  end
+
+  def test_divmod
+    c = Rational(1,2)
+    c2 = Rational(2,3)
+
+    assert_eql([0, Rational(1,2)], c.divmod(c2))
+    assert_eql([0, Rational(1,2)], c.divmod(2))
+    assert_eql([0, 0.5], c.divmod(2.0))
+
+    c = Rational(301,100)
+    c2 = Rational(7,5)
+
+    assert_equal([2, Rational(21,100)], c.divmod(c2))
+    assert_equal([-3, Rational(-119,100)], c.divmod(-c2))
+    assert_equal([-3, Rational(119,100)], (-c).divmod(c2))
+    assert_equal([2, Rational(-21,100)], (-c).divmod(-c2))
+
+    c = Rational(301,100)
+    c2 = Rational(2)
+
+    assert_equal([1, Rational(101,100)], c.divmod(c2))
+    assert_equal([-2, Rational(-99,100)], c.divmod(-c2))
+    assert_equal([-2, Rational(99,100)], (-c).divmod(c2))
+    assert_equal([1, Rational(-101,100)], (-c).divmod(-c2))
+
+    unless @unify
+      c = Rational(11)
+      c2 = Rational(3)
+
+      assert_equal([3,2], c.divmod(c2))
+      assert_equal([-4,-1], c.divmod(-c2))
+      assert_equal([-4,1], (-c).divmod(c2))
+      assert_equal([3,-2], (-c).divmod(-c2))
+    end
+  end
+
+=begin
+  def test_quot
+    c = Rational(1,2)
+    c2 = Rational(2,3)
+
+    assert_eql(0, c.quot(c2))
+    assert_eql(0, c.quot(2))
+    assert_eql(0, c.quot(2.0))
+
+    c = Rational(301,100)
+    c2 = Rational(7,5)
+
+    assert_equal(2, c.quot(c2))
+    assert_equal(-2, c.quot(-c2))
+    assert_equal(-2, (-c).quot(c2))
+    assert_equal(2, (-c).quot(-c2))
+
+    c = Rational(301,100)
+    c2 = Rational(2)
+
+    assert_equal(1, c.quot(c2))
+    assert_equal(-1, c.quot(-c2))
+    assert_equal(-1, (-c).quot(c2))
+    assert_equal(1, (-c).quot(-c2))
+
+    unless @unify
+      c = Rational(11)
+      c2 = Rational(3)
+
+      assert_equal(3, c.quot(c2))
+      assert_equal(-3, c.quot(-c2))
+      assert_equal(-3, (-c).quot(c2))
+      assert_equal(3, (-c).quot(-c2))
+    end
+  end
+=end
+
+  def test_remainder
+    c = Rational(1,2)
+    c2 = Rational(2,3)
+
+    assert_eql(Rational(1,2), c.remainder(c2))
+    assert_eql(Rational(1,2), c.remainder(2))
+    assert_eql(0.5, c.remainder(2.0))
+
+    c = Rational(301,100)
+    c2 = Rational(7,5)
+
+    assert_equal(Rational(21,100), c.remainder(c2))
+    assert_equal(Rational(21,100), c.remainder(-c2))
+    assert_equal(Rational(-21,100), (-c).remainder(c2))
+    assert_equal(Rational(-21,100), (-c).remainder(-c2))
+
+    c = Rational(301,100)
+    c2 = Rational(2)
+
+    assert_equal(Rational(101,100), c.remainder(c2))
+    assert_equal(Rational(101,100), c.remainder(-c2))
+    assert_equal(Rational(-101,100), (-c).remainder(c2))
+    assert_equal(Rational(-101,100), (-c).remainder(-c2))
+
+    unless @unify
+      c = Rational(11)
+      c2 = Rational(3)
+
+      assert_equal(2, c.remainder(c2))
+      assert_equal(2, c.remainder(-c2))
+      assert_equal(-2, (-c).remainder(c2))
+      assert_equal(-2, (-c).remainder(-c2))
+    end
+  end
+
+=begin
+  def test_quotrem
+    c = Rational(1,2)
+    c2 = Rational(2,3)
+
+    assert_eql([0, Rational(1,2)], c.quotrem(c2))
+    assert_eql([0, Rational(1,2)], c.quotrem(2))
+    assert_eql([0, 0.5], c.quotrem(2.0))
+
+    c = Rational(301,100)
+    c2 = Rational(7,5)
+
+    assert_equal([2, Rational(21,100)], c.quotrem(c2))
+    assert_equal([-2, Rational(21,100)], c.quotrem(-c2))
+    assert_equal([-2, Rational(-21,100)], (-c).quotrem(c2))
+    assert_equal([2, Rational(-21,100)], (-c).quotrem(-c2))
+
+    c = Rational(301,100)
+    c2 = Rational(2)
+
+    assert_equal([1, Rational(101,100)], c.quotrem(c2))
+    assert_equal([-1, Rational(101,100)], c.quotrem(-c2))
+    assert_equal([-1, Rational(-101,100)], (-c).quotrem(c2))
+    assert_equal([1, Rational(-101,100)], (-c).quotrem(-c2))
+
+    unless @unify
+      c = Rational(11)
+      c2 = Rational(3)
+
+      assert_equal([3,2], c.quotrem(c2))
+      assert_equal([-3,2], c.quotrem(-c2))
+      assert_equal([-3,-2], (-c).quotrem(c2))
+      assert_equal([3,-2], (-c).quotrem(-c2))
+    end
+  end
+=end
+
+  def test_quo
+    c = Rational(1,2)
+    c2 = Rational(2,3)
+
+    assert_equal(Rational(3,4), c.quo(c2))
+
+    assert_equal(Rational(1,4), c.quo(2))
+    assert_equal(0.25, c.quo(2.0))
+  end
+
+  def test_fdiv
+    c = Rational(1,2)
+    c2 = Rational(2,3)
+
+    assert_equal(0.75, c.fdiv(c2))
+
+    assert_equal(0.25, c.fdiv(2))
+    assert_equal(0.25, c.fdiv(2.0))
+  end
+
+  def test_expt
+    c = Rational(1,2)
+    c2 = Rational(2,3)
+
+    r = c ** c2
+    assert_in_delta(0.6299, r, 0.001)
+
+    assert_equal(Rational(1,4), c ** 2)
+    assert_equal(Rational(4), c ** -2)
+    assert_equal(Rational(1,4), (-c) ** 2)
+    assert_equal(Rational(4), (-c) ** -2)
+
+    assert_equal(0.25, c ** 2.0)
+    assert_equal(4.0, c ** -2.0)
+
+    assert_equal(Rational(1,4), c ** Rational(2))
+    assert_equal(Rational(4), c ** Rational(-2))
+
+    assert_equal(Rational(1), 0 ** Rational(0))
+    assert_equal(Rational(1), Rational(0) ** 0)
+    assert_equal(Rational(1), Rational(0) ** Rational(0))
+
+    # p ** p
+    x = 2 ** Rational(2)
+    ## [1.8] Fixnum#coerce tries to convert the other operand to Float.
+=begin
+    assert_equal(Rational(4), x)
+    unless @unify
+      assert_instance_of(Rational, x)
+    end
+    assert_equal(4, x.numerator)
+    assert_equal(1, x.denominator)
+=end
+    assert_equal(4.0, x)
+    unless @unify
+      assert_instance_of(Float, x)
+    end
+
+    x = Rational(2) ** 2
+    assert_equal(Rational(4), x)
+    unless @unify
+      assert_instance_of(Rational, x)
+    end
+    assert_equal(4, x.numerator)
+    assert_equal(1, x.denominator)
+
+    x = Rational(2) ** Rational(2)
+    ## [1.8] Rational#** calculates Rational**Rational in Float.
+=begin
+    assert_equal(Rational(4), x)
+    unless @unify
+      assert_instance_of(Rational, x)
+    end
+    assert_equal(4, x.numerator)
+    assert_equal(1, x.denominator)
+=end
+    assert_equal(4.0, x)
+    unless @unify
+      assert_instance_of(Float, x)
+    end
+
+    # -p ** p
+    x = (-2) ** Rational(2)
+    ## [1.8] Fixnum#coerce tries to convert the other operand to Float.
+=begin
+    assert_equal(Rational(4), x)
+    unless @unify
+      assert_instance_of(Rational, x)
+    end
+    assert_equal(4, x.numerator)
+    assert_equal(1, x.denominator)
+=end
+    assert_equal(4.0, x)
+    unless @unify
+      assert_instance_of(Float, x)
+    end
+
+    x = Rational(-2) ** 2
+    assert_equal(Rational(4), x)
+    unless @unify
+      assert_instance_of(Rational, x)
+    end
+    assert_equal(4, x.numerator)
+    assert_equal(1, x.denominator)
+
+    x = Rational(-2) ** Rational(2)
+    ## [1.8] Rational#** calculates Rational**Rational in Float.
+=begin
+    assert_equal(Rational(4), x)
+    unless @unify
+      assert_instance_of(Rational, x)
+    end
+    assert_equal(4, x.numerator)
+    assert_equal(1, x.denominator)
+=end
+    assert_equal(4.0, x)
+    unless @unify
+      assert_instance_of(Float, x)
+    end
+
+    # p ** -p
+    x = 2 ** Rational(-2)
+    ## [1.8] Fixnum#coerce tries to convert the other operand to Float.
+=begin
+    assert_equal(Rational(1,4), x)
+    assert_instance_of(Rational, x)
+    assert_equal(1, x.numerator)
+    assert_equal(4, x.denominator)
+=end
+    assert_equal(0.25, x)
+    assert_instance_of(Float, x)
+
+    x = Rational(2) ** -2
+    assert_equal(Rational(1,4), x)
+    assert_instance_of(Rational, x)
+    assert_equal(1, x.numerator)
+    assert_equal(4, x.denominator)
+
+    x = Rational(2) ** Rational(-2)
+    ## [1.8] Rational#** calculates Rational**Rational in Float.
+=begin
+    assert_equal(Rational(1,4), x)
+    assert_instance_of(Rational, x)
+    assert_equal(1, x.numerator)
+    assert_equal(4, x.denominator)
+=end
+    assert_equal(0.25, x)
+    assert_instance_of(Float, x)
+
+    # -p ** -p
+    x = (-2) ** Rational(-2)
+    ## [1.8] Fixnum#coerce tries to convert the other operand to Float.
+=begin
+    assert_equal(Rational(1,4), x)
+    assert_instance_of(Rational, x)
+    assert_equal(1, x.numerator)
+    assert_equal(4, x.denominator)
+=end
+    assert_equal(0.25, x)
+    assert_instance_of(Float, x)
+
+    x = Rational(-2) ** -2
+    assert_equal(Rational(1,4), x)
+    assert_instance_of(Rational, x)
+    assert_equal(1, x.numerator)
+    assert_equal(4, x.denominator)
+
+    x = Rational(-2) ** Rational(-2)
+    ## [1.8] Rational#** calculates Rational**Rational in Float.
+=begin
+    assert_equal(Rational(1,4), x)
+    assert_instance_of(Rational, x)
+    assert_equal(1, x.numerator)
+    assert_equal(4, x.denominator)
+=end
+    assert_equal(0.25, x)
+    assert_instance_of(Float, x)
+
+    unless @unify # maybe bug mathn
+      ## [1.8] returns Infinity
+=begin
+      assert_raise(ZeroDivisionError){0 ** -1}
+=end
+    end
+  end
+
+  def test_cmp
+    assert_equal(-1, Rational(-1) <=> Rational(0))
+    assert_equal(0, Rational(0) <=> Rational(0))
+    assert_equal(+1, Rational(+1) <=> Rational(0))
+
+    assert_equal(-1, Rational(-1) <=> 0)
+    assert_equal(0, Rational(0) <=> 0)
+    assert_equal(+1, Rational(+1) <=> 0)
+
+    assert_equal(-1, Rational(-1) <=> 0.0)
+    assert_equal(0, Rational(0) <=> 0.0)
+    assert_equal(+1, Rational(+1) <=> 0.0)
+
+    assert_equal(-1, Rational(1,2) <=> Rational(2,3))
+    assert_equal(0, Rational(2,3) <=> Rational(2,3))
+    assert_equal(+1, Rational(2,3) <=> Rational(1,2))
+
+    f = 2**30-1
+    b = 2**30
+
+    assert_equal(0, Rational(f) <=> Rational(f))
+    assert_equal(-1, Rational(f) <=> Rational(b))
+    assert_equal(+1, Rational(b) <=> Rational(f))
+    assert_equal(0, Rational(b) <=> Rational(b))
+
+    assert_equal(-1, Rational(f-1) <=> Rational(f))
+    assert_equal(+1, Rational(f) <=> Rational(f-1))
+    assert_equal(-1, Rational(b-1) <=> Rational(b))
+    assert_equal(+1, Rational(b) <=> Rational(b-1))
+
+    assert_equal(false, Rational(0) < Rational(0))
+    assert_equal(true, Rational(0) <= Rational(0))
+    assert_equal(true, Rational(0) >= Rational(0))
+    assert_equal(false, Rational(0) > Rational(0))
+
+    assert_equal(nil, Rational(0) <=> nil)
+    assert_equal(nil, Rational(0) <=> 'foo')
+  end
+
+  def test_eqeq
+    assert(Rational(1,1) == Rational(1))
+    assert(Rational(-1,1) == Rational(-1))
+
+    assert_equal(false, Rational(2,1) == Rational(1))
+    assert_equal(true, Rational(2,1) != Rational(1))
+    assert_equal(false, Rational(1) == nil)
+    assert_equal(false, Rational(1) == '')
+  end
+
+  def test_coerce
+    assert_equal([Rational(2),Rational(1)], Rational(1).coerce(2))
+    ## [1.8] Rational coerces itself to Float
+=begin
+    assert_equal([Rational(2.2),Rational(1)], Rational(1).coerce(2.2))
+=end
+    assert_equal([2.2,1.0], Rational(1).coerce(2.2))
+    assert_equal([Rational(2),Rational(1)], Rational(1).coerce(Rational(2)))
+  end
+
+  def test_unify
+    if @unify
+      assert_instance_of(Fixnum, Rational(1,2) + Rational(1,2))
+      assert_instance_of(Fixnum, Rational(1,2) - Rational(1,2))
+      assert_instance_of(Fixnum, Rational(1,2) * 2)
+      assert_instance_of(Fixnum, Rational(1,2) / Rational(1,2))
+      assert_instance_of(Fixnum, Rational(1,2).div(Rational(1,2)))
+      assert_instance_of(Fixnum, Rational(1,2).quo(Rational(1,2)))
+      assert_instance_of(Fixnum, Rational(1,2) ** -2)
+    end
+  end
+
+  def test_math
+    assert_equal(Rational(1,2), Rational(1,2).abs)
+    assert_equal(Rational(1,2), Rational(-1,2).abs)
+    if @complex && !@keiju
+      assert_equal(Rational(1,2), Rational(1,2).magnitude)
+      assert_equal(Rational(1,2), Rational(-1,2).magnitude)
+    end
+
+    assert_equal(1, Rational(1,2).numerator)
+    assert_equal(2, Rational(1,2).denominator)
+  end
+
+  def test_trunc
+    [[Rational(13, 5),  [ 2,  3,  2,  3]], #  2.6
+     [Rational(5, 2),   [ 2,  3,  2,  3]], #  2.5
+     [Rational(12, 5),  [ 2,  3,  2,  2]], #  2.4
+     [Rational(-12,5),  [-3, -2, -2, -2]], # -2.4
+     [Rational(-5, 2),  [-3, -2, -2, -3]], # -2.5
+     [Rational(-13, 5), [-3, -2, -2, -3]], # -2.6
+    ].each do |i, a|
+      assert_equal(a[0], i.floor)
+      assert_equal(a[1], i.ceil)
+      assert_equal(a[2], i.truncate)
+      assert_equal(a[3], i.round)
+    end
+  end
+
+  def test_to_s
+    c = Rational(1,2)
+
+    assert_instance_of(String, c.to_s)
+    assert_equal('1/2', c.to_s)
+
+    if @unify
+      assert_equal('0', Rational(0,2).to_s)
+      assert_equal('0', Rational(0,-2).to_s)
+    else
+      ## [1.8] Float#to_r is missing
+=begin
+      assert_equal('0/1', Rational(0,2).to_s)
+      assert_equal('0/1', Rational(0,-2).to_s)
+=end
+      assert_equal('0', Rational(0,2).to_s)
+      assert_equal('0', Rational(0,-2).to_s)
+    end
+    assert_equal('1/2', Rational(1,2).to_s)
+    assert_equal('-1/2', Rational(-1,2).to_s)
+    assert_equal('1/2', Rational(-1,-2).to_s)
+    assert_equal('-1/2', Rational(1,-2).to_s)
+    assert_equal('1/2', Rational(-1,-2).to_s)
+  end
+
+  def test_inspect
+    c = Rational(1,2)
+
+    assert_instance_of(String, c.inspect)
+    ## [1.8] Format changed in 1.9
+=begin
+    assert_equal('(1/2)', c.inspect)
+=end
+    assert_equal('Rational(1, 2)', c.inspect)
+  end
+
+  def test_marshal
+    c = Rational(1,2)
+    c.instance_eval{@ivar = 9}
+
+    s = Marshal.dump(c)
+    c2 = Marshal.load(s)
+    assert_equal(c, c2)
+    assert_equal(9, c2.instance_variable_get(:@ivar))
+    assert_instance_of(Rational, c2)
+
+    ## [1.8] No support (yet) for the marshal format of Rational in 1.9
+=begin
+    assert_raise(ZeroDivisionError){
+      Marshal.load("\x04\bU:\rRational[\ai\x06i\x05")
+    }
+=end
+  end
+
+  ## [1.8] String#to_r is missing
+=begin
+  def test_parse
+    assert_equal(Rational(5), '5'.to_r)
+    assert_equal(Rational(-5), '-5'.to_r)
+    assert_equal(Rational(5,3), '5/3'.to_r)
+    assert_equal(Rational(-5,3), '-5/3'.to_r)
+#    assert_equal(Rational(5,-3), '5/-3'.to_r)
+#    assert_equal(Rational(-5,-3), '-5/-3'.to_r)
+
+    assert_equal(Rational(5), '5.0'.to_r)
+    assert_equal(Rational(-5), '-5.0'.to_r)
+    assert_equal(Rational(5,3), '5.0/3'.to_r)
+    assert_equal(Rational(-5,3), '-5.0/3'.to_r)
+#    assert_equal(Rational(5,-3), '5.0/-3'.to_r)
+#    assert_equal(Rational(-5,-3), '-5.0/-3'.to_r)
+
+    assert_equal(Rational(5), '5e0'.to_r)
+    assert_equal(Rational(-5), '-5e0'.to_r)
+    assert_equal(Rational(5,3), '5e0/3'.to_r)
+    assert_equal(Rational(-5,3), '-5e0/3'.to_r)
+#    assert_equal(Rational(5,-3), '5e0/-3'.to_r)
+#    assert_equal(Rational(-5,-3), '-5e0/-3'.to_r)
+
+    assert_equal(Rational(33,100), '.33'.to_r)
+    assert_equal(Rational(33,100), '0.33'.to_r)
+    assert_equal(Rational(-33,100), '-.33'.to_r)
+    assert_equal(Rational(-33,100), '-0.33'.to_r)
+    assert_equal(Rational(-33,100), '-0.3_3'.to_r)
+
+    assert_equal(Rational(1,2), '5e-1'.to_r)
+    assert_equal(Rational(50), '5e+1'.to_r)
+    assert_equal(Rational(1,2), '5.0e-1'.to_r)
+    assert_equal(Rational(50), '5.0e+1'.to_r)
+    assert_equal(Rational(50), '5e1'.to_r)
+    assert_equal(Rational(50), '5E1'.to_r)
+    assert_equal(Rational(500), '5e2'.to_r)
+    assert_equal(Rational(5000), '5e3'.to_r)
+    assert_equal(Rational(500000000000), '5e1_1'.to_r)
+
+    assert_equal(Rational(5), Rational('5'))
+    assert_equal(Rational(-5), Rational('-5'))
+    assert_equal(Rational(5,3), Rational('5/3'))
+    assert_equal(Rational(-5,3), Rational('-5/3'))
+#    assert_equal(Rational(5,-3), Rational('5/-3'))
+#    assert_equal(Rational(-5,-3), Rational('-5/-3'))
+
+    assert_equal(Rational(5), Rational('5.0'))
+    assert_equal(Rational(-5), Rational('-5.0'))
+    assert_equal(Rational(5,3), Rational('5.0/3'))
+    assert_equal(Rational(-5,3), Rational('-5.0/3'))
+#    assert_equal(Rational(5,-3), Rational('5.0/-3'))
+#    assert_equal(Rational(-5,-3), Rational('-5.0/-3'))
+
+    assert_equal(Rational(5), Rational('5e0'))
+    assert_equal(Rational(-5), Rational('-5e0'))
+    assert_equal(Rational(5,3), Rational('5e0/3'))
+    assert_equal(Rational(-5,3), Rational('-5e0/3'))
+#    assert_equal(Rational(5,-3), Rational('5e0/-3'))
+#    assert_equal(Rational(-5,-3), Rational('-5e0/-3'))
+
+    assert_equal(Rational(33,100), Rational('.33'))
+    assert_equal(Rational(33,100), Rational('0.33'))
+    assert_equal(Rational(-33,100), Rational('-.33'))
+    assert_equal(Rational(-33,100), Rational('-0.33'))
+    assert_equal(Rational(-33,100), Rational('-0.3_3'))
+
+    assert_equal(Rational(1,2), Rational('5e-1'))
+    assert_equal(Rational(50), Rational('5e+1'))
+    assert_equal(Rational(1,2), Rational('5.0e-1'))
+    assert_equal(Rational(50), Rational('5.0e+1'))
+    assert_equal(Rational(50), Rational('5e1'))
+    assert_equal(Rational(50), Rational('5E1'))
+    assert_equal(Rational(500), Rational('5e2'))
+    assert_equal(Rational(5000), Rational('5e3'))
+    assert_equal(Rational(500000000000), Rational('5e1_1'))
+
+    assert_equal(Rational(0), ''.to_r)
+    assert_equal(Rational(0), ' '.to_r)
+    assert_equal(Rational(5), "\f\n\r\t\v5\0".to_r)
+    assert_equal(Rational(0), '_'.to_r)
+    assert_equal(Rational(0), '_5'.to_r)
+    assert_equal(Rational(5), '5_'.to_r)
+    assert_equal(Rational(5), '5x'.to_r)
+    assert_equal(Rational(5), '5/_3'.to_r)
+    assert_equal(Rational(5,3), '5/3_'.to_r)
+    assert_equal(Rational(5,3), '5/3.3'.to_r)
+    assert_equal(Rational(5,3), '5/3x'.to_r)
+    assert_raise(ArgumentError){ Rational('')}
+    assert_raise(ArgumentError){ Rational('_')}
+    assert_raise(ArgumentError){ Rational("\f\n\r\t\v5\0")}
+    assert_raise(ArgumentError){ Rational('_5')}
+    assert_raise(ArgumentError){ Rational('5_')}
+    assert_raise(ArgumentError){ Rational('5x')}
+    assert_raise(ArgumentError){ Rational('5/_3')}
+    assert_raise(ArgumentError){ Rational('5/3_')}
+    assert_raise(ArgumentError){ Rational('5/3.3')}
+    assert_raise(ArgumentError){ Rational('5/3x')}
+  end
+=end
+
+=begin
+  def test_reciprocal
+    assert_equal(Rational(1,9), Rational(9,1).reciprocal)
+    assert_equal(Rational(9,1), Rational(1,9).reciprocal)
+    assert_equal(Rational(-1,9), Rational(-9,1).reciprocal)
+    assert_equal(Rational(-9,1), Rational(-1,9).reciprocal)
+    assert_equal(Rational(1,9), Rational(9,1).inverse)
+    assert_equal(Rational(9,1), Rational(1,9).inverse)
+    assert_equal(Rational(-1,9), Rational(-9,1).inverse)
+    assert_equal(Rational(-9,1), Rational(-1,9).inverse)
+  end
+=end
+
+  def test_to_i
+    assert_equal(1, Rational(3,2).to_i)
+    assert_equal(1, Integer(Rational(3,2)))
+  end
+
+  def test_to_f
+    assert_equal(1.5, Rational(3,2).to_f)
+    assert_equal(1.5, Float(Rational(3,2)))
+  end
+
+  def test_to_c
+    if @complex && !@keiju
+      if @unify
+	assert_equal(Rational(3,2), Rational(3,2).to_c)
+	assert_equal(Rational(3,2), Complex(Rational(3,2)))
+      else
+	assert_equal(Complex(Rational(3,2)), Rational(3,2).to_c)
+	assert_equal(Complex(Rational(3,2)), Complex(Rational(3,2)))
+      end
+    end
+  end
+
+  def test_to_r
+    ## [1.8] Float#to_r is missing
+=begin
+    c = nil.to_r
+    assert_equal([0,1], [c.numerator, c.denominator])
+=end
+
+    c = 0.to_r
+    assert_equal([0,1], [c.numerator, c.denominator])
+
+    c = 1.to_r
+    assert_equal([1,1], [c.numerator, c.denominator])
+
+    ## [1.8] Float#to_r is missing
+=begin
+    c = 1.1.to_r
+    assert_equal([2476979795053773, 2251799813685248],
+		 [c.numerator, c.denominator])
+=end
+
+    c = Rational(1,2).to_r
+    assert_equal([1,2], [c.numerator, c.denominator])
+
+    if @complex
+      if @keiju
+	assert_raise(NoMethodError){Complex(1,2).to_r}
+      else
+	assert_raise(RangeError){Complex(1,2).to_r}
+      end
+    end
+
+    ## [1.8] Float#to_r is missing
+=begin
+    if (0.0/0).nan?
+      assert_raise(FloatDomainError){(0.0/0).to_r}
+    end
+    if (1.0/0).infinite?
+      assert_raise(FloatDomainError){(1.0/0).to_r}
+    end
+=end
+  end
+
+  ## [1.8] #rationalize is missing
+=begin
+  def test_rationalize
+    c = nil.rationalize
+    assert_equal([0,1], [c.numerator, c.denominator])
+
+    c = 0.rationalize
+    assert_equal([0,1], [c.numerator, c.denominator])
+
+    c = 1.rationalize
+    assert_equal([1,1], [c.numerator, c.denominator])
+
+    c = 1.1.rationalize
+    assert_equal([11, 10], [c.numerator, c.denominator])
+
+    c = Rational(1,2).rationalize
+    assert_equal([1,2], [c.numerator, c.denominator])
+
+    assert_equal(nil.rationalize(Rational(1,10)), Rational(0))
+    assert_equal(0.rationalize(Rational(1,10)), Rational(0))
+    assert_equal(10.rationalize(Rational(1,10)), Rational(10))
+
+    r = 0.3333
+    assert_equal(r.rationalize, Rational(3333, 10000))
+    assert_equal(r.rationalize(Rational(1,10)), Rational(1,3))
+    assert_equal(r.rationalize(Rational(-1,10)), Rational(1,3))
+
+    r = Rational(5404319552844595,18014398509481984)
+    assert_equal(r.rationalize, r)
+    assert_equal(r.rationalize(Rational(1,10)), Rational(1,3))
+    assert_equal(r.rationalize(Rational(-1,10)), Rational(1,3))
+
+    r = -0.3333
+    assert_equal(r.rationalize, Rational(-3333, 10000))
+    assert_equal(r.rationalize(Rational(1,10)), Rational(-1,3))
+    assert_equal(r.rationalize(Rational(-1,10)), Rational(-1,3))
+
+    r = Rational(-5404319552844595,18014398509481984)
+    assert_equal(r.rationalize, r)
+    assert_equal(r.rationalize(Rational(1,10)), Rational(-1,3))
+    assert_equal(r.rationalize(Rational(-1,10)), Rational(-1,3))
+
+    if @complex
+      if @keiju
+      else
+	assert_raise(RangeError){Complex(1,2).rationalize}
+      end
+    end
+
+    if (0.0/0).nan?
+      assert_raise(FloatDomainError){(0.0/0).rationalize}
+    end
+    if (1.0/0).infinite?
+      assert_raise(FloatDomainError){(1.0/0).rationalize}
+    end
+  end
+=end
+
+  def test_gcdlcm
+    assert_equal(7, 91.gcd(-49))
+    assert_equal(5, 5.gcd(0))
+    assert_equal(5, 0.gcd(5))
+    assert_equal(70, 14.lcm(35))
+    assert_equal(0, 5.lcm(0))
+    assert_equal(0, 0.lcm(5))
+    assert_equal([5,0], 0.gcdlcm(5))
+    assert_equal([5,0], 5.gcdlcm(0))
+
+    assert_equal(1, 1073741827.gcd(1073741789))
+    assert_equal(1152921470247108503, 1073741827.lcm(1073741789))
+
+    assert_equal(1, 1073741789.gcd(1073741827))
+    assert_equal(1152921470247108503, 1073741789.lcm(1073741827))
+  end
+
+  def test_supp
+    ## [1.8] Numeric#real? is missing
+=begin
+    assert_equal(true, 1.real?)
+    assert_equal(true, 1.1.real?)
+=end
+
+    assert_equal(1, 1.numerator)
+    assert_equal(9, 9.numerator)
+    assert_equal(1, 1.denominator)
+    assert_equal(1, 9.denominator)
+
+    ## [1.8] Float#to_r is missing
+=begin
+    assert_equal(1.0, 1.0.numerator)
+    assert_equal(9.0, 9.0.numerator)
+    assert_equal(1.0, 1.0.denominator)
+    assert_equal(1.0, 9.0.denominator)
+=end
+
+=begin
+    assert_equal(Rational(1,9), 9.reciprocal)
+    assert_in_delta(0.1111, 9.0.reciprocal, 0.001)
+    assert_equal(Rational(1,9), 9.inverse)
+    assert_in_delta(0.1111, 9.0.inverse, 0.001)
+=end
+
+    assert_equal(Rational(1,2), 1.quo(2))
+    assert_equal(Rational(5000000000), 10000000000.quo(2))
+    assert_equal(0.5, 1.0.quo(2))
+    assert_equal(Rational(1,4), Rational(1,2).quo(2))
+
+    assert_equal(0.5, 1.fdiv(2))
+    assert_equal(5000000000.0, 10000000000.fdiv(2))
+    assert_equal(0.5, 1.0.fdiv(2))
+    assert_equal(0.25, Rational(1,2).fdiv(2))
+  end
+
+  ## [1.8] Not for me
+=begin
+  def test_ruby19
+    assert_raise(NoMethodError){ Rational.new(1) }
+    assert_raise(NoMethodError){ Rational.new!(1) }
+  end
+=end
+
+  def test_fixed_bug
+    if @unify
+      assert_instance_of(Fixnum, Rational(1,2) ** 0) # mathn's bug
+    end
+
+    n = Float::MAX.to_i * 2
+    ## [1.8] Bug still exists (or is left as "a feature")
+=begin
+    assert_equal(1.0, Rational(n + 2, n + 1).to_f, '[ruby-dev:33852]')
+=end
+  end
+
+  def test_known_bug
+  end
+
+end
--- /dev/null
+++ b/test/rational/test_rational2.rb
@@ -0,0 +1,1387 @@
+require 'test/unit'
+require 'rational'
+
+class Rational_Test2 < Test::Unit::TestCase
+
+  def test_kumi
+    assert_equal(Rational(1, 1), +Rational(1, 1))
+    assert_equal(Rational(-1, 1), -Rational(1, 1))
+    assert_equal(Rational(2, 1),
+                 Rational(1, 1) + Rational(1, 1))
+    assert_equal(Rational(0, 1),
+                 Rational(1, 1) - Rational(1, 1))
+    assert_equal(Rational(1, 1),
+                 Rational(1, 1) * Rational(1, 1))
+    assert_equal(Rational(1, 1),
+                 Rational(1, 1) / Rational(1, 1))
+    assert_equal(Rational(3, 1),
+                 Rational(1, 1) + Rational(2, 1))
+    assert_equal(Rational(-1, 1),
+                 Rational(1, 1) - Rational(2, 1))
+    assert_equal(Rational(2, 1),
+                 Rational(1, 1) * Rational(2, 1))
+    assert_equal(Rational(1, 2),
+                 Rational(1, 1) / Rational(2, 1))
+    assert_equal(Rational(4, 1),
+                 Rational(1, 1) + Rational(3, 1))
+    assert_equal(Rational(-2, 1),
+                 Rational(1, 1) - Rational(3, 1))
+    assert_equal(Rational(3, 1),
+                 Rational(1, 1) * Rational(3, 1))
+    assert_equal(Rational(1, 3),
+                 Rational(1, 1) / Rational(3, 1))
+    assert_equal(Rational(1073741790, 1),
+                 Rational(1, 1) + Rational(1073741789, 1))
+    assert_equal(Rational(-1073741788, 1),
+                 Rational(1, 1) - Rational(1073741789, 1))
+    assert_equal(Rational(1073741789, 1),
+                 Rational(1, 1) * Rational(1073741789, 1))
+    assert_equal(Rational(1, 1073741789),
+                 Rational(1, 1) / Rational(1073741789, 1))
+    assert_equal(Rational(1073741828, 1),
+                 Rational(1, 1) + Rational(1073741827, 1))
+    assert_equal(Rational(-1073741826, 1),
+                 Rational(1, 1) - Rational(1073741827, 1))
+    assert_equal(Rational(1073741827, 1),
+                 Rational(1, 1) * Rational(1073741827, 1))
+    assert_equal(Rational(1, 1073741827),
+                 Rational(1, 1) / Rational(1073741827, 1))
+    assert_equal(Rational(5, 3),
+                 Rational(1, 1) + Rational(2, 3))
+    assert_equal(Rational(1, 3),
+                 Rational(1, 1) - Rational(2, 3))
+    assert_equal(Rational(2, 3),
+                 Rational(1, 1) * Rational(2, 3))
+    assert_equal(Rational(3, 2),
+                 Rational(1, 1) / Rational(2, 3))
+    assert_equal(Rational(5, 2),
+                 Rational(1, 1) + Rational(3, 2))
+    assert_equal(Rational(-1, 2),
+                 Rational(1, 1) - Rational(3, 2))
+    assert_equal(Rational(3, 2),
+                 Rational(1, 1) * Rational(3, 2))
+    assert_equal(Rational(2, 3),
+                 Rational(1, 1) / Rational(3, 2))
+    assert_equal(Rational(1073741792, 1073741789),
+                 Rational(1, 1) + Rational(3, 1073741789))
+    assert_equal(Rational(1073741786, 1073741789),
+                 Rational(1, 1) - Rational(3, 1073741789))
+    assert_equal(Rational(3, 1073741789),
+                 Rational(1, 1) * Rational(3, 1073741789))
+    assert_equal(Rational(1073741789, 3),
+                 Rational(1, 1) / Rational(3, 1073741789))
+    assert_equal(Rational(1073741792, 3),
+                 Rational(1, 1) + Rational(1073741789, 3))
+    assert_equal(Rational(-1073741786, 3),
+                 Rational(1, 1) - Rational(1073741789, 3))
+    assert_equal(Rational(1073741789, 3),
+                 Rational(1, 1) * Rational(1073741789, 3))
+    assert_equal(Rational(3, 1073741789),
+                 Rational(1, 1) / Rational(1073741789, 3))
+    assert_equal(Rational(1073741830, 1073741827),
+                 Rational(1, 1) + Rational(3, 1073741827))
+    assert_equal(Rational(1073741824, 1073741827),
+                 Rational(1, 1) - Rational(3, 1073741827))
+    assert_equal(Rational(3, 1073741827),
+                 Rational(1, 1) * Rational(3, 1073741827))
+    assert_equal(Rational(1073741827, 3),
+                 Rational(1, 1) / Rational(3, 1073741827))
+    assert_equal(Rational(1073741830, 3),
+                 Rational(1, 1) + Rational(1073741827, 3))
+    assert_equal(Rational(-1073741824, 3),
+                 Rational(1, 1) - Rational(1073741827, 3))
+    assert_equal(Rational(1073741827, 3),
+                 Rational(1, 1) * Rational(1073741827, 3))
+    assert_equal(Rational(3, 1073741827),
+                 Rational(1, 1) / Rational(1073741827, 3))
+    assert_equal(Rational(2147483616, 1073741827),
+                 Rational(1, 1) + Rational(1073741789, 1073741827))
+    assert_equal(Rational(38, 1073741827),
+                 Rational(1, 1) - Rational(1073741789, 1073741827))
+    assert_equal(Rational(1073741789, 1073741827),
+                 Rational(1, 1) * Rational(1073741789, 1073741827))
+    assert_equal(Rational(1073741827, 1073741789),
+                 Rational(1, 1) / Rational(1073741789, 1073741827))
+    assert_equal(Rational(2147483616, 1073741789),
+                 Rational(1, 1) + Rational(1073741827, 1073741789))
+    assert_equal(Rational(-38, 1073741789),
+                 Rational(1, 1) - Rational(1073741827, 1073741789))
+    assert_equal(Rational(1073741827, 1073741789),
+                 Rational(1, 1) * Rational(1073741827, 1073741789))
+    assert_equal(Rational(1073741789, 1073741827),
+                 Rational(1, 1) / Rational(1073741827, 1073741789))
+    assert_equal(Rational(2, 1), +Rational(2, 1))
+    assert_equal(Rational(-2, 1), -Rational(2, 1))
+    assert_equal(Rational(3, 1),
+                 Rational(2, 1) + Rational(1, 1))
+    assert_equal(Rational(1, 1),
+                 Rational(2, 1) - Rational(1, 1))
+    assert_equal(Rational(2, 1),
+                 Rational(2, 1) * Rational(1, 1))
+    assert_equal(Rational(2, 1),
+                 Rational(2, 1) / Rational(1, 1))
+    assert_equal(Rational(4, 1),
+                 Rational(2, 1) + Rational(2, 1))
+    assert_equal(Rational(0, 1),
+                 Rational(2, 1) - Rational(2, 1))
+    assert_equal(Rational(4, 1),
+                 Rational(2, 1) * Rational(2, 1))
+    assert_equal(Rational(1, 1),
+                 Rational(2, 1) / Rational(2, 1))
+    assert_equal(Rational(5, 1),
+                 Rational(2, 1) + Rational(3, 1))
+    assert_equal(Rational(-1, 1),
+                 Rational(2, 1) - Rational(3, 1))
+    assert_equal(Rational(6, 1),
+                 Rational(2, 1) * Rational(3, 1))
+    assert_equal(Rational(2, 3),
+                 Rational(2, 1) / Rational(3, 1))
+    assert_equal(Rational(1073741791, 1),
+                 Rational(2, 1) + Rational(1073741789, 1))
+    assert_equal(Rational(-1073741787, 1),
+                 Rational(2, 1) - Rational(1073741789, 1))
+    assert_equal(Rational(2147483578, 1),
+                 Rational(2, 1) * Rational(1073741789, 1))
+    assert_equal(Rational(2, 1073741789),
+                 Rational(2, 1) / Rational(1073741789, 1))
+    assert_equal(Rational(1073741829, 1),
+                 Rational(2, 1) + Rational(1073741827, 1))
+    assert_equal(Rational(-1073741825, 1),
+                 Rational(2, 1) - Rational(1073741827, 1))
+    assert_equal(Rational(2147483654, 1),
+                 Rational(2, 1) * Rational(1073741827, 1))
+    assert_equal(Rational(2, 1073741827),
+                 Rational(2, 1) / Rational(1073741827, 1))
+    assert_equal(Rational(8, 3),
+                 Rational(2, 1) + Rational(2, 3))
+    assert_equal(Rational(4, 3),
+                 Rational(2, 1) - Rational(2, 3))
+    assert_equal(Rational(4, 3),
+                 Rational(2, 1) * Rational(2, 3))
+    assert_equal(Rational(3, 1),
+                 Rational(2, 1) / Rational(2, 3))
+    assert_equal(Rational(7, 2),
+                 Rational(2, 1) + Rational(3, 2))
+    assert_equal(Rational(1, 2),
+                 Rational(2, 1) - Rational(3, 2))
+    assert_equal(Rational(3, 1),
+                 Rational(2, 1) * Rational(3, 2))
+    assert_equal(Rational(4, 3),
+                 Rational(2, 1) / Rational(3, 2))
+    assert_equal(Rational(2147483581, 1073741789),
+                 Rational(2, 1) + Rational(3, 1073741789))
+    assert_equal(Rational(2147483575, 1073741789),
+                 Rational(2, 1) - Rational(3, 1073741789))
+    assert_equal(Rational(6, 1073741789),
+                 Rational(2, 1) * Rational(3, 1073741789))
+    assert_equal(Rational(2147483578, 3),
+                 Rational(2, 1) / Rational(3, 1073741789))
+    assert_equal(Rational(1073741795, 3),
+                 Rational(2, 1) + Rational(1073741789, 3))
+    assert_equal(Rational(-1073741783, 3),
+                 Rational(2, 1) - Rational(1073741789, 3))
+    assert_equal(Rational(2147483578, 3),
+                 Rational(2, 1) * Rational(1073741789, 3))
+    assert_equal(Rational(6, 1073741789),
+                 Rational(2, 1) / Rational(1073741789, 3))
+    assert_equal(Rational(2147483657, 1073741827),
+                 Rational(2, 1) + Rational(3, 1073741827))
+    assert_equal(Rational(2147483651, 1073741827),
+                 Rational(2, 1) - Rational(3, 1073741827))
+    assert_equal(Rational(6, 1073741827),
+                 Rational(2, 1) * Rational(3, 1073741827))
+    assert_equal(Rational(2147483654, 3),
+                 Rational(2, 1) / Rational(3, 1073741827))
+    assert_equal(Rational(1073741833, 3),
+                 Rational(2, 1) + Rational(1073741827, 3))
+    assert_equal(Rational(-1073741821, 3),
+                 Rational(2, 1) - Rational(1073741827, 3))
+    assert_equal(Rational(2147483654, 3),
+                 Rational(2, 1) * Rational(1073741827, 3))
+    assert_equal(Rational(6, 1073741827),
+                 Rational(2, 1) / Rational(1073741827, 3))
+    assert_equal(Rational(3221225443, 1073741827),
+                 Rational(2, 1) + Rational(1073741789, 1073741827))
+    assert_equal(Rational(1073741865, 1073741827),
+                 Rational(2, 1) - Rational(1073741789, 1073741827))
+    assert_equal(Rational(2147483578, 1073741827),
+                 Rational(2, 1) * Rational(1073741789, 1073741827))
+    assert_equal(Rational(2147483654, 1073741789),
+                 Rational(2, 1) / Rational(1073741789, 1073741827))
+    assert_equal(Rational(3221225405, 1073741789),
+                 Rational(2, 1) + Rational(1073741827, 1073741789))
+    assert_equal(Rational(1073741751, 1073741789),
+                 Rational(2, 1) - Rational(1073741827, 1073741789))
+    assert_equal(Rational(2147483654, 1073741789),
+                 Rational(2, 1) * Rational(1073741827, 1073741789))
+    assert_equal(Rational(2147483578, 1073741827),
+                 Rational(2, 1) / Rational(1073741827, 1073741789))
+    assert_equal(Rational(3, 1), +Rational(3, 1))
+    assert_equal(Rational(-3, 1), -Rational(3, 1))
+    assert_equal(Rational(4, 1),
+                 Rational(3, 1) + Rational(1, 1))
+    assert_equal(Rational(2, 1),
+                 Rational(3, 1) - Rational(1, 1))
+    assert_equal(Rational(3, 1),
+                 Rational(3, 1) * Rational(1, 1))
+    assert_equal(Rational(3, 1),
+                 Rational(3, 1) / Rational(1, 1))
+    assert_equal(Rational(5, 1),
+                 Rational(3, 1) + Rational(2, 1))
+    assert_equal(Rational(1, 1),
+                 Rational(3, 1) - Rational(2, 1))
+    assert_equal(Rational(6, 1),
+                 Rational(3, 1) * Rational(2, 1))
+    assert_equal(Rational(3, 2),
+                 Rational(3, 1) / Rational(2, 1))
+    assert_equal(Rational(6, 1),
+                 Rational(3, 1) + Rational(3, 1))
+    assert_equal(Rational(0, 1),
+                 Rational(3, 1) - Rational(3, 1))
+    assert_equal(Rational(9, 1),
+                 Rational(3, 1) * Rational(3, 1))
+    assert_equal(Rational(1, 1),
+                 Rational(3, 1) / Rational(3, 1))
+    assert_equal(Rational(1073741792, 1),
+                 Rational(3, 1) + Rational(1073741789, 1))
+    assert_equal(Rational(-1073741786, 1),
+                 Rational(3, 1) - Rational(1073741789, 1))
+    assert_equal(Rational(3221225367, 1),
+                 Rational(3, 1) * Rational(1073741789, 1))
+    assert_equal(Rational(3, 1073741789),
+                 Rational(3, 1) / Rational(1073741789, 1))
+    assert_equal(Rational(1073741830, 1),
+                 Rational(3, 1) + Rational(1073741827, 1))
+    assert_equal(Rational(-1073741824, 1),
+                 Rational(3, 1) - Rational(1073741827, 1))
+    assert_equal(Rational(3221225481, 1),
+                 Rational(3, 1) * Rational(1073741827, 1))
+    assert_equal(Rational(3, 1073741827),
+                 Rational(3, 1) / Rational(1073741827, 1))
+    assert_equal(Rational(11, 3),
+                 Rational(3, 1) + Rational(2, 3))
+    assert_equal(Rational(7, 3),
+                 Rational(3, 1) - Rational(2, 3))
+    assert_equal(Rational(2, 1),
+                 Rational(3, 1) * Rational(2, 3))
+    assert_equal(Rational(9, 2),
+                 Rational(3, 1) / Rational(2, 3))
+    assert_equal(Rational(9, 2),
+                 Rational(3, 1) + Rational(3, 2))
+    assert_equal(Rational(3, 2),
+                 Rational(3, 1) - Rational(3, 2))
+    assert_equal(Rational(9, 2),
+                 Rational(3, 1) * Rational(3, 2))
+    assert_equal(Rational(2, 1),
+                 Rational(3, 1) / Rational(3, 2))
+    assert_equal(Rational(3221225370, 1073741789),
+                 Rational(3, 1) + Rational(3, 1073741789))
+    assert_equal(Rational(3221225364, 1073741789),
+                 Rational(3, 1) - Rational(3, 1073741789))
+    assert_equal(Rational(9, 1073741789),
+                 Rational(3, 1) * Rational(3, 1073741789))
+    assert_equal(Rational(1073741789, 1),
+                 Rational(3, 1) / Rational(3, 1073741789))
+    assert_equal(Rational(1073741798, 3),
+                 Rational(3, 1) + Rational(1073741789, 3))
+    assert_equal(Rational(-1073741780, 3),
+                 Rational(3, 1) - Rational(1073741789, 3))
+    assert_equal(Rational(1073741789, 1),
+                 Rational(3, 1) * Rational(1073741789, 3))
+    assert_equal(Rational(9, 1073741789),
+                 Rational(3, 1) / Rational(1073741789, 3))
+    assert_equal(Rational(3221225484, 1073741827),
+                 Rational(3, 1) + Rational(3, 1073741827))
+    assert_equal(Rational(3221225478, 1073741827),
+                 Rational(3, 1) - Rational(3, 1073741827))
+    assert_equal(Rational(9, 1073741827),
+                 Rational(3, 1) * Rational(3, 1073741827))
+    assert_equal(Rational(1073741827, 1),
+                 Rational(3, 1) / Rational(3, 1073741827))
+    assert_equal(Rational(1073741836, 3),
+                 Rational(3, 1) + Rational(1073741827, 3))
+    assert_equal(Rational(-1073741818, 3),
+                 Rational(3, 1) - Rational(1073741827, 3))
+    assert_equal(Rational(1073741827, 1),
+                 Rational(3, 1) * Rational(1073741827, 3))
+    assert_equal(Rational(9, 1073741827),
+                 Rational(3, 1) / Rational(1073741827, 3))
+    assert_equal(Rational(4294967270, 1073741827),
+                 Rational(3, 1) + Rational(1073741789, 1073741827))
+    assert_equal(Rational(2147483692, 1073741827),
+                 Rational(3, 1) - Rational(1073741789, 1073741827))
+    assert_equal(Rational(3221225367, 1073741827),
+                 Rational(3, 1) * Rational(1073741789, 1073741827))
+    assert_equal(Rational(3221225481, 1073741789),
+                 Rational(3, 1) / Rational(1073741789, 1073741827))
+    assert_equal(Rational(4294967194, 1073741789),
+                 Rational(3, 1) + Rational(1073741827, 1073741789))
+    assert_equal(Rational(2147483540, 1073741789),
+                 Rational(3, 1) - Rational(1073741827, 1073741789))
+    assert_equal(Rational(3221225481, 1073741789),
+                 Rational(3, 1) * Rational(1073741827, 1073741789))
+    assert_equal(Rational(3221225367, 1073741827),
+                 Rational(3, 1) / Rational(1073741827, 1073741789))
+    assert_equal(Rational(1073741789, 1), +Rational(1073741789, 1))
+    assert_equal(Rational(-1073741789, 1), -Rational(1073741789, 1))
+    assert_equal(Rational(1073741790, 1),
+                 Rational(1073741789, 1) + Rational(1, 1))
+    assert_equal(Rational(1073741788, 1),
+                 Rational(1073741789, 1) - Rational(1, 1))
+    assert_equal(Rational(1073741789, 1),
+                 Rational(1073741789, 1) * Rational(1, 1))
+    assert_equal(Rational(1073741789, 1),
+                 Rational(1073741789, 1) / Rational(1, 1))
+    assert_equal(Rational(1073741791, 1),
+                 Rational(1073741789, 1) + Rational(2, 1))
+    assert_equal(Rational(1073741787, 1),
+                 Rational(1073741789, 1) - Rational(2, 1))
+    assert_equal(Rational(2147483578, 1),
+                 Rational(1073741789, 1) * Rational(2, 1))
+    assert_equal(Rational(1073741789, 2),
+                 Rational(1073741789, 1) / Rational(2, 1))
+    assert_equal(Rational(1073741792, 1),
+                 Rational(1073741789, 1) + Rational(3, 1))
+    assert_equal(Rational(1073741786, 1),
+                 Rational(1073741789, 1) - Rational(3, 1))
+    assert_equal(Rational(3221225367, 1),
+                 Rational(1073741789, 1) * Rational(3, 1))
+    assert_equal(Rational(1073741789, 3),
+                 Rational(1073741789, 1) / Rational(3, 1))
+    assert_equal(Rational(2147483578, 1),
+                 Rational(1073741789, 1) + Rational(1073741789, 1))
+    assert_equal(Rational(0, 1),
+                 Rational(1073741789, 1) - Rational(1073741789, 1))
+    assert_equal(Rational(1152921429444920521, 1),
+                 Rational(1073741789, 1) * Rational(1073741789, 1))
+    assert_equal(Rational(1, 1),
+                 Rational(1073741789, 1) / Rational(1073741789, 1))
+    assert_equal(Rational(2147483616, 1),
+                 Rational(1073741789, 1) + Rational(1073741827, 1))
+    assert_equal(Rational(-38, 1),
+                 Rational(1073741789, 1) - Rational(1073741827, 1))
+    assert_equal(Rational(1152921470247108503, 1),
+                 Rational(1073741789, 1) * Rational(1073741827, 1))
+    assert_equal(Rational(1073741789, 1073741827),
+                 Rational(1073741789, 1) / Rational(1073741827, 1))
+    assert_equal(Rational(3221225369, 3),
+                 Rational(1073741789, 1) + Rational(2, 3))
+    assert_equal(Rational(3221225365, 3),
+                 Rational(1073741789, 1) - Rational(2, 3))
+    assert_equal(Rational(2147483578, 3),
+                 Rational(1073741789, 1) * Rational(2, 3))
+    assert_equal(Rational(3221225367, 2),
+                 Rational(1073741789, 1) / Rational(2, 3))
+    assert_equal(Rational(2147483581, 2),
+                 Rational(1073741789, 1) + Rational(3, 2))
+    assert_equal(Rational(2147483575, 2),
+                 Rational(1073741789, 1) - Rational(3, 2))
+    assert_equal(Rational(3221225367, 2),
+                 Rational(1073741789, 1) * Rational(3, 2))
+    assert_equal(Rational(2147483578, 3),
+                 Rational(1073741789, 1) / Rational(3, 2))
+    assert_equal(Rational(1152921429444920524, 1073741789),
+                 Rational(1073741789, 1) + Rational(3, 1073741789))
+    assert_equal(Rational(1152921429444920518, 1073741789),
+                 Rational(1073741789, 1) - Rational(3, 1073741789))
+    assert_equal(Rational(3, 1),
+                 Rational(1073741789, 1) * Rational(3, 1073741789))
+    assert_equal(Rational(1152921429444920521, 3),
+                 Rational(1073741789, 1) / Rational(3, 1073741789))
+    assert_equal(Rational(4294967156, 3),
+                 Rational(1073741789, 1) + Rational(1073741789, 3))
+    assert_equal(Rational(2147483578, 3),
+                 Rational(1073741789, 1) - Rational(1073741789, 3))
+    assert_equal(Rational(1152921429444920521, 3),
+                 Rational(1073741789, 1) * Rational(1073741789, 3))
+    assert_equal(Rational(3, 1),
+                 Rational(1073741789, 1) / Rational(1073741789, 3))
+    assert_equal(Rational(1152921470247108506, 1073741827),
+                 Rational(1073741789, 1) + Rational(3, 1073741827))
+    assert_equal(Rational(1152921470247108500, 1073741827),
+                 Rational(1073741789, 1) - Rational(3, 1073741827))
+    assert_equal(Rational(3221225367, 1073741827),
+                 Rational(1073741789, 1) * Rational(3, 1073741827))
+    assert_equal(Rational(1152921470247108503, 3),
+                 Rational(1073741789, 1) / Rational(3, 1073741827))
+    assert_equal(Rational(4294967194, 3),
+                 Rational(1073741789, 1) + Rational(1073741827, 3))
+    assert_equal(Rational(2147483540, 3),
+                 Rational(1073741789, 1) - Rational(1073741827, 3))
+    assert_equal(Rational(1152921470247108503, 3),
+                 Rational(1073741789, 1) * Rational(1073741827, 3))
+    assert_equal(Rational(3221225367, 1073741827),
+                 Rational(1073741789, 1) / Rational(1073741827, 3))
+    assert_equal(Rational(1152921471320850292, 1073741827),
+                 Rational(1073741789, 1) + Rational(1073741789, 1073741827))
+    assert_equal(Rational(1152921469173366714, 1073741827),
+                 Rational(1073741789, 1) - Rational(1073741789, 1073741827))
+    assert_equal(Rational(1152921429444920521, 1073741827),
+                 Rational(1073741789, 1) * Rational(1073741789, 1073741827))
+    assert_equal(Rational(1073741827, 1),
+                 Rational(1073741789, 1) / Rational(1073741789, 1073741827))
+    assert_equal(Rational(1152921430518662348, 1073741789),
+                 Rational(1073741789, 1) + Rational(1073741827, 1073741789))
+    assert_equal(Rational(1152921428371178694, 1073741789),
+                 Rational(1073741789, 1) - Rational(1073741827, 1073741789))
+    assert_equal(Rational(1073741827, 1),
+                 Rational(1073741789, 1) * Rational(1073741827, 1073741789))
+    assert_equal(Rational(1152921429444920521, 1073741827),
+                 Rational(1073741789, 1) / Rational(1073741827, 1073741789))
+    assert_equal(Rational(1073741827, 1), +Rational(1073741827, 1))
+    assert_equal(Rational(-1073741827, 1), -Rational(1073741827, 1))
+    assert_equal(Rational(1073741828, 1),
+                 Rational(1073741827, 1) + Rational(1, 1))
+    assert_equal(Rational(1073741826, 1),
+                 Rational(1073741827, 1) - Rational(1, 1))
+    assert_equal(Rational(1073741827, 1),
+                 Rational(1073741827, 1) * Rational(1, 1))
+    assert_equal(Rational(1073741827, 1),
+                 Rational(1073741827, 1) / Rational(1, 1))
+    assert_equal(Rational(1073741829, 1),
+                 Rational(1073741827, 1) + Rational(2, 1))
+    assert_equal(Rational(1073741825, 1),
+                 Rational(1073741827, 1) - Rational(2, 1))
+    assert_equal(Rational(2147483654, 1),
+                 Rational(1073741827, 1) * Rational(2, 1))
+    assert_equal(Rational(1073741827, 2),
+                 Rational(1073741827, 1) / Rational(2, 1))
+    assert_equal(Rational(1073741830, 1),
+                 Rational(1073741827, 1) + Rational(3, 1))
+    assert_equal(Rational(1073741824, 1),
+                 Rational(1073741827, 1) - Rational(3, 1))
+    assert_equal(Rational(3221225481, 1),
+                 Rational(1073741827, 1) * Rational(3, 1))
+    assert_equal(Rational(1073741827, 3),
+                 Rational(1073741827, 1) / Rational(3, 1))
+    assert_equal(Rational(2147483616, 1),
+                 Rational(1073741827, 1) + Rational(1073741789, 1))
+    assert_equal(Rational(38, 1),
+                 Rational(1073741827, 1) - Rational(1073741789, 1))
+    assert_equal(Rational(1152921470247108503, 1),
+                 Rational(1073741827, 1) * Rational(1073741789, 1))
+    assert_equal(Rational(1073741827, 1073741789),
+                 Rational(1073741827, 1) / Rational(1073741789, 1))
+    assert_equal(Rational(2147483654, 1),
+                 Rational(1073741827, 1) + Rational(1073741827, 1))
+    assert_equal(Rational(0, 1),
+                 Rational(1073741827, 1) - Rational(1073741827, 1))
+    assert_equal(Rational(1152921511049297929, 1),
+                 Rational(1073741827, 1) * Rational(1073741827, 1))
+    assert_equal(Rational(1, 1),
+                 Rational(1073741827, 1) / Rational(1073741827, 1))
+    assert_equal(Rational(3221225483, 3),
+                 Rational(1073741827, 1) + Rational(2, 3))
+    assert_equal(Rational(3221225479, 3),
+                 Rational(1073741827, 1) - Rational(2, 3))
+    assert_equal(Rational(2147483654, 3),
+                 Rational(1073741827, 1) * Rational(2, 3))
+    assert_equal(Rational(3221225481, 2),
+                 Rational(1073741827, 1) / Rational(2, 3))
+    assert_equal(Rational(2147483657, 2),
+                 Rational(1073741827, 1) + Rational(3, 2))
+    assert_equal(Rational(2147483651, 2),
+                 Rational(1073741827, 1) - Rational(3, 2))
+    assert_equal(Rational(3221225481, 2),
+                 Rational(1073741827, 1) * Rational(3, 2))
+    assert_equal(Rational(2147483654, 3),
+                 Rational(1073741827, 1) / Rational(3, 2))
+    assert_equal(Rational(1152921470247108506, 1073741789),
+                 Rational(1073741827, 1) + Rational(3, 1073741789))
+    assert_equal(Rational(1152921470247108500, 1073741789),
+                 Rational(1073741827, 1) - Rational(3, 1073741789))
+    assert_equal(Rational(3221225481, 1073741789),
+                 Rational(1073741827, 1) * Rational(3, 1073741789))
+    assert_equal(Rational(1152921470247108503, 3),
+                 Rational(1073741827, 1) / Rational(3, 1073741789))
+    assert_equal(Rational(4294967270, 3),
+                 Rational(1073741827, 1) + Rational(1073741789, 3))
+    assert_equal(Rational(2147483692, 3),
+                 Rational(1073741827, 1) - Rational(1073741789, 3))
+    assert_equal(Rational(1152921470247108503, 3),
+                 Rational(1073741827, 1) * Rational(1073741789, 3))
+    assert_equal(Rational(3221225481, 1073741789),
+                 Rational(1073741827, 1) / Rational(1073741789, 3))
+    assert_equal(Rational(1152921511049297932, 1073741827),
+                 Rational(1073741827, 1) + Rational(3, 1073741827))
+    assert_equal(Rational(1152921511049297926, 1073741827),
+                 Rational(1073741827, 1) - Rational(3, 1073741827))
+    assert_equal(Rational(3, 1),
+                 Rational(1073741827, 1) * Rational(3, 1073741827))
+    assert_equal(Rational(1152921511049297929, 3),
+                 Rational(1073741827, 1) / Rational(3, 1073741827))
+    assert_equal(Rational(4294967308, 3),
+                 Rational(1073741827, 1) + Rational(1073741827, 3))
+    assert_equal(Rational(2147483654, 3),
+                 Rational(1073741827, 1) - Rational(1073741827, 3))
+    assert_equal(Rational(1152921511049297929, 3),
+                 Rational(1073741827, 1) * Rational(1073741827, 3))
+    assert_equal(Rational(3, 1),
+                 Rational(1073741827, 1) / Rational(1073741827, 3))
+    assert_equal(Rational(1152921512123039718, 1073741827),
+                 Rational(1073741827, 1) + Rational(1073741789, 1073741827))
+    assert_equal(Rational(1152921509975556140, 1073741827),
+                 Rational(1073741827, 1) - Rational(1073741789, 1073741827))
+    assert_equal(Rational(1073741789, 1),
+                 Rational(1073741827, 1) * Rational(1073741789, 1073741827))
+    assert_equal(Rational(1152921511049297929, 1073741789),
+                 Rational(1073741827, 1) / Rational(1073741789, 1073741827))
+    assert_equal(Rational(1152921471320850330, 1073741789),
+                 Rational(1073741827, 1) + Rational(1073741827, 1073741789))
+    assert_equal(Rational(1152921469173366676, 1073741789),
+                 Rational(1073741827, 1) - Rational(1073741827, 1073741789))
+    assert_equal(Rational(1152921511049297929, 1073741789),
+                 Rational(1073741827, 1) * Rational(1073741827, 1073741789))
+    assert_equal(Rational(1073741789, 1),
+                 Rational(1073741827, 1) / Rational(1073741827, 1073741789))
+    assert_equal(Rational(2, 3), +Rational(2, 3))
+    assert_equal(Rational(-2, 3), -Rational(2, 3))
+    assert_equal(Rational(5, 3),
+                 Rational(2, 3) + Rational(1, 1))
+    assert_equal(Rational(-1, 3),
+                 Rational(2, 3) - Rational(1, 1))
+    assert_equal(Rational(2, 3),
+                 Rational(2, 3) * Rational(1, 1))
+    assert_equal(Rational(2, 3),
+                 Rational(2, 3) / Rational(1, 1))
+    assert_equal(Rational(8, 3),
+                 Rational(2, 3) + Rational(2, 1))
+    assert_equal(Rational(-4, 3),
+                 Rational(2, 3) - Rational(2, 1))
+    assert_equal(Rational(4, 3),
+                 Rational(2, 3) * Rational(2, 1))
+    assert_equal(Rational(1, 3),
+                 Rational(2, 3) / Rational(2, 1))
+    assert_equal(Rational(11, 3),
+                 Rational(2, 3) + Rational(3, 1))
+    assert_equal(Rational(-7, 3),
+                 Rational(2, 3) - Rational(3, 1))
+    assert_equal(Rational(2, 1),
+                 Rational(2, 3) * Rational(3, 1))
+    assert_equal(Rational(2, 9),
+                 Rational(2, 3) / Rational(3, 1))
+    assert_equal(Rational(3221225369, 3),
+                 Rational(2, 3) + Rational(1073741789, 1))
+    assert_equal(Rational(-3221225365, 3),
+                 Rational(2, 3) - Rational(1073741789, 1))
+    assert_equal(Rational(2147483578, 3),
+                 Rational(2, 3) * Rational(1073741789, 1))
+    assert_equal(Rational(2, 3221225367),
+                 Rational(2, 3) / Rational(1073741789, 1))
+    assert_equal(Rational(3221225483, 3),
+                 Rational(2, 3) + Rational(1073741827, 1))
+    assert_equal(Rational(-3221225479, 3),
+                 Rational(2, 3) - Rational(1073741827, 1))
+    assert_equal(Rational(2147483654, 3),
+                 Rational(2, 3) * Rational(1073741827, 1))
+    assert_equal(Rational(2, 3221225481),
+                 Rational(2, 3) / Rational(1073741827, 1))
+    assert_equal(Rational(4, 3),
+                 Rational(2, 3) + Rational(2, 3))
+    assert_equal(Rational(0, 1),
+                 Rational(2, 3) - Rational(2, 3))
+    assert_equal(Rational(4, 9),
+                 Rational(2, 3) * Rational(2, 3))
+    assert_equal(Rational(1, 1),
+                 Rational(2, 3) / Rational(2, 3))
+    assert_equal(Rational(13, 6),
+                 Rational(2, 3) + Rational(3, 2))
+    assert_equal(Rational(-5, 6),
+                 Rational(2, 3) - Rational(3, 2))
+    assert_equal(Rational(1, 1),
+                 Rational(2, 3) * Rational(3, 2))
+    assert_equal(Rational(4, 9),
+                 Rational(2, 3) / Rational(3, 2))
+    assert_equal(Rational(2147483587, 3221225367),
+                 Rational(2, 3) + Rational(3, 1073741789))
+    assert_equal(Rational(2147483569, 3221225367),
+                 Rational(2, 3) - Rational(3, 1073741789))
+    assert_equal(Rational(2, 1073741789),
+                 Rational(2, 3) * Rational(3, 1073741789))
+    assert_equal(Rational(2147483578, 9),
+                 Rational(2, 3) / Rational(3, 1073741789))
+    assert_equal(Rational(1073741791, 3),
+                 Rational(2, 3) + Rational(1073741789, 3))
+    assert_equal(Rational(-357913929, 1),
+                 Rational(2, 3) - Rational(1073741789, 3))
+    assert_equal(Rational(2147483578, 9),
+                 Rational(2, 3) * Rational(1073741789, 3))
+    assert_equal(Rational(2, 1073741789),
+                 Rational(2, 3) / Rational(1073741789, 3))
+    assert_equal(Rational(2147483663, 3221225481),
+                 Rational(2, 3) + Rational(3, 1073741827))
+    assert_equal(Rational(2147483645, 3221225481),
+                 Rational(2, 3) - Rational(3, 1073741827))
+    assert_equal(Rational(2, 1073741827),
+                 Rational(2, 3) * Rational(3, 1073741827))
+    assert_equal(Rational(2147483654, 9),
+                 Rational(2, 3) / Rational(3, 1073741827))
+    assert_equal(Rational(357913943, 1),
+                 Rational(2, 3) + Rational(1073741827, 3))
+    assert_equal(Rational(-1073741825, 3),
+                 Rational(2, 3) - Rational(1073741827, 3))
+    assert_equal(Rational(2147483654, 9),
+                 Rational(2, 3) * Rational(1073741827, 3))
+    assert_equal(Rational(2, 1073741827),
+                 Rational(2, 3) / Rational(1073741827, 3))
+    assert_equal(Rational(5368709021, 3221225481),
+                 Rational(2, 3) + Rational(1073741789, 1073741827))
+    assert_equal(Rational(-1073741713, 3221225481),
+                 Rational(2, 3) - Rational(1073741789, 1073741827))
+    assert_equal(Rational(2147483578, 3221225481),
+                 Rational(2, 3) * Rational(1073741789, 1073741827))
+    assert_equal(Rational(2147483654, 3221225367),
+                 Rational(2, 3) / Rational(1073741789, 1073741827))
+    assert_equal(Rational(5368709059, 3221225367),
+                 Rational(2, 3) + Rational(1073741827, 1073741789))
+    assert_equal(Rational(-1073741903, 3221225367),
+                 Rational(2, 3) - Rational(1073741827, 1073741789))
+    assert_equal(Rational(2147483654, 3221225367),
+                 Rational(2, 3) * Rational(1073741827, 1073741789))
+    assert_equal(Rational(2147483578, 3221225481),
+                 Rational(2, 3) / Rational(1073741827, 1073741789))
+    assert_equal(Rational(3, 2), +Rational(3, 2))
+    assert_equal(Rational(-3, 2), -Rational(3, 2))
+    assert_equal(Rational(5, 2),
+                 Rational(3, 2) + Rational(1, 1))
+    assert_equal(Rational(1, 2),
+                 Rational(3, 2) - Rational(1, 1))
+    assert_equal(Rational(3, 2),
+                 Rational(3, 2) * Rational(1, 1))
+    assert_equal(Rational(3, 2),
+                 Rational(3, 2) / Rational(1, 1))
+    assert_equal(Rational(7, 2),
+                 Rational(3, 2) + Rational(2, 1))
+    assert_equal(Rational(-1, 2),
+                 Rational(3, 2) - Rational(2, 1))
+    assert_equal(Rational(3, 1),
+                 Rational(3, 2) * Rational(2, 1))
+    assert_equal(Rational(3, 4),
+                 Rational(3, 2) / Rational(2, 1))
+    assert_equal(Rational(9, 2),
+                 Rational(3, 2) + Rational(3, 1))
+    assert_equal(Rational(-3, 2),
+                 Rational(3, 2) - Rational(3, 1))
+    assert_equal(Rational(9, 2),
+                 Rational(3, 2) * Rational(3, 1))
+    assert_equal(Rational(1, 2),
+                 Rational(3, 2) / Rational(3, 1))
+    assert_equal(Rational(2147483581, 2),
+                 Rational(3, 2) + Rational(1073741789, 1))
+    assert_equal(Rational(-2147483575, 2),
+                 Rational(3, 2) - Rational(1073741789, 1))
+    assert_equal(Rational(3221225367, 2),
+                 Rational(3, 2) * Rational(1073741789, 1))
+    assert_equal(Rational(3, 2147483578),
+                 Rational(3, 2) / Rational(1073741789, 1))
+    assert_equal(Rational(2147483657, 2),
+                 Rational(3, 2) + Rational(1073741827, 1))
+    assert_equal(Rational(-2147483651, 2),
+                 Rational(3, 2) - Rational(1073741827, 1))
+    assert_equal(Rational(3221225481, 2),
+                 Rational(3, 2) * Rational(1073741827, 1))
+    assert_equal(Rational(3, 2147483654),
+                 Rational(3, 2) / Rational(1073741827, 1))
+    assert_equal(Rational(13, 6),
+                 Rational(3, 2) + Rational(2, 3))
+    assert_equal(Rational(5, 6),
+                 Rational(3, 2) - Rational(2, 3))
+    assert_equal(Rational(1, 1),
+                 Rational(3, 2) * Rational(2, 3))
+    assert_equal(Rational(9, 4),
+                 Rational(3, 2) / Rational(2, 3))
+    assert_equal(Rational(3, 1),
+                 Rational(3, 2) + Rational(3, 2))
+    assert_equal(Rational(0, 1),
+                 Rational(3, 2) - Rational(3, 2))
+    assert_equal(Rational(9, 4),
+                 Rational(3, 2) * Rational(3, 2))
+    assert_equal(Rational(1, 1),
+                 Rational(3, 2) / Rational(3, 2))
+    assert_equal(Rational(3221225373, 2147483578),
+                 Rational(3, 2) + Rational(3, 1073741789))
+    assert_equal(Rational(3221225361, 2147483578),
+                 Rational(3, 2) - Rational(3, 1073741789))
+    assert_equal(Rational(9, 2147483578),
+                 Rational(3, 2) * Rational(3, 1073741789))
+    assert_equal(Rational(1073741789, 2),
+                 Rational(3, 2) / Rational(3, 1073741789))
+    assert_equal(Rational(2147483587, 6),
+                 Rational(3, 2) + Rational(1073741789, 3))
+    assert_equal(Rational(-2147483569, 6),
+                 Rational(3, 2) - Rational(1073741789, 3))
+    assert_equal(Rational(1073741789, 2),
+                 Rational(3, 2) * Rational(1073741789, 3))
+    assert_equal(Rational(9, 2147483578),
+                 Rational(3, 2) / Rational(1073741789, 3))
+    assert_equal(Rational(3221225487, 2147483654),
+                 Rational(3, 2) + Rational(3, 1073741827))
+    assert_equal(Rational(3221225475, 2147483654),
+                 Rational(3, 2) - Rational(3, 1073741827))
+    assert_equal(Rational(9, 2147483654),
+                 Rational(3, 2) * Rational(3, 1073741827))
+    assert_equal(Rational(1073741827, 2),
+                 Rational(3, 2) / Rational(3, 1073741827))
+    assert_equal(Rational(2147483663, 6),
+                 Rational(3, 2) + Rational(1073741827, 3))
+    assert_equal(Rational(-2147483645, 6),
+                 Rational(3, 2) - Rational(1073741827, 3))
+    assert_equal(Rational(1073741827, 2),
+                 Rational(3, 2) * Rational(1073741827, 3))
+    assert_equal(Rational(9, 2147483654),
+                 Rational(3, 2) / Rational(1073741827, 3))
+    assert_equal(Rational(5368709059, 2147483654),
+                 Rational(3, 2) + Rational(1073741789, 1073741827))
+    assert_equal(Rational(1073741903, 2147483654),
+                 Rational(3, 2) - Rational(1073741789, 1073741827))
+    assert_equal(Rational(3221225367, 2147483654),
+                 Rational(3, 2) * Rational(1073741789, 1073741827))
+    assert_equal(Rational(3221225481, 2147483578),
+                 Rational(3, 2) / Rational(1073741789, 1073741827))
+    assert_equal(Rational(5368709021, 2147483578),
+                 Rational(3, 2) + Rational(1073741827, 1073741789))
+    assert_equal(Rational(1073741713, 2147483578),
+                 Rational(3, 2) - Rational(1073741827, 1073741789))
+    assert_equal(Rational(3221225481, 2147483578),
+                 Rational(3, 2) * Rational(1073741827, 1073741789))
+    assert_equal(Rational(3221225367, 2147483654),
+                 Rational(3, 2) / Rational(1073741827, 1073741789))
+    assert_equal(Rational(3, 1073741789), +Rational(3, 1073741789))
+    assert_equal(Rational(-3, 1073741789), -Rational(3, 1073741789))
+    assert_equal(Rational(1073741792, 1073741789),
+                 Rational(3, 1073741789) + Rational(1, 1))
+    assert_equal(Rational(-1073741786, 1073741789),
+                 Rational(3, 1073741789) - Rational(1, 1))
+    assert_equal(Rational(3, 1073741789),
+                 Rational(3, 1073741789) * Rational(1, 1))
+    assert_equal(Rational(3, 1073741789),
+                 Rational(3, 1073741789) / Rational(1, 1))
+    assert_equal(Rational(2147483581, 1073741789),
+                 Rational(3, 1073741789) + Rational(2, 1))
+    assert_equal(Rational(-2147483575, 1073741789),
+                 Rational(3, 1073741789) - Rational(2, 1))
+    assert_equal(Rational(6, 1073741789),
+                 Rational(3, 1073741789) * Rational(2, 1))
+    assert_equal(Rational(3, 2147483578),
+                 Rational(3, 1073741789) / Rational(2, 1))
+    assert_equal(Rational(3221225370, 1073741789),
+                 Rational(3, 1073741789) + Rational(3, 1))
+    assert_equal(Rational(-3221225364, 1073741789),
+                 Rational(3, 1073741789) - Rational(3, 1))
+    assert_equal(Rational(9, 1073741789),
+                 Rational(3, 1073741789) * Rational(3, 1))
+    assert_equal(Rational(1, 1073741789),
+                 Rational(3, 1073741789) / Rational(3, 1))
+    assert_equal(Rational(1152921429444920524, 1073741789),
+                 Rational(3, 1073741789) + Rational(1073741789, 1))
+    assert_equal(Rational(-1152921429444920518, 1073741789),
+                 Rational(3, 1073741789) - Rational(1073741789, 1))
+    assert_equal(Rational(3, 1),
+                 Rational(3, 1073741789) * Rational(1073741789, 1))
+    assert_equal(Rational(3, 1152921429444920521),
+                 Rational(3, 1073741789) / Rational(1073741789, 1))
+    assert_equal(Rational(1152921470247108506, 1073741789),
+                 Rational(3, 1073741789) + Rational(1073741827, 1))
+    assert_equal(Rational(-1152921470247108500, 1073741789),
+                 Rational(3, 1073741789) - Rational(1073741827, 1))
+    assert_equal(Rational(3221225481, 1073741789),
+                 Rational(3, 1073741789) * Rational(1073741827, 1))
+    assert_equal(Rational(3, 1152921470247108503),
+                 Rational(3, 1073741789) / Rational(1073741827, 1))
+    assert_equal(Rational(2147483587, 3221225367),
+                 Rational(3, 1073741789) + Rational(2, 3))
+    assert_equal(Rational(-2147483569, 3221225367),
+                 Rational(3, 1073741789) - Rational(2, 3))
+    assert_equal(Rational(2, 1073741789),
+                 Rational(3, 1073741789) * Rational(2, 3))
+    assert_equal(Rational(9, 2147483578),
+                 Rational(3, 1073741789) / Rational(2, 3))
+    assert_equal(Rational(3221225373, 2147483578),
+                 Rational(3, 1073741789) + Rational(3, 2))
+    assert_equal(Rational(-3221225361, 2147483578),
+                 Rational(3, 1073741789) - Rational(3, 2))
+    assert_equal(Rational(9, 2147483578),
+                 Rational(3, 1073741789) * Rational(3, 2))
+    assert_equal(Rational(2, 1073741789),
+                 Rational(3, 1073741789) / Rational(3, 2))
+    assert_equal(Rational(6, 1073741789),
+                 Rational(3, 1073741789) + Rational(3, 1073741789))
+    assert_equal(Rational(0, 1),
+                 Rational(3, 1073741789) - Rational(3, 1073741789))
+    assert_equal(Rational(9, 1152921429444920521),
+                 Rational(3, 1073741789) * Rational(3, 1073741789))
+    assert_equal(Rational(1, 1),
+                 Rational(3, 1073741789) / Rational(3, 1073741789))
+    assert_equal(Rational(1152921429444920530, 3221225367),
+                 Rational(3, 1073741789) + Rational(1073741789, 3))
+    assert_equal(Rational(-1152921429444920512, 3221225367),
+                 Rational(3, 1073741789) - Rational(1073741789, 3))
+    assert_equal(Rational(1, 1),
+                 Rational(3, 1073741789) * Rational(1073741789, 3))
+    assert_equal(Rational(9, 1152921429444920521),
+                 Rational(3, 1073741789) / Rational(1073741789, 3))
+    assert_equal(Rational(6442450848, 1152921470247108503),
+                 Rational(3, 1073741789) + Rational(3, 1073741827))
+    assert_equal(Rational(114, 1152921470247108503),
+                 Rational(3, 1073741789) - Rational(3, 1073741827))
+    assert_equal(Rational(9, 1152921470247108503),
+                 Rational(3, 1073741789) * Rational(3, 1073741827))
+    assert_equal(Rational(1073741827, 1073741789),
+                 Rational(3, 1073741789) / Rational(3, 1073741827))
+    assert_equal(Rational(1152921470247108512, 3221225367),
+                 Rational(3, 1073741789) + Rational(1073741827, 3))
+    assert_equal(Rational(-1152921470247108494, 3221225367),
+                 Rational(3, 1073741789) - Rational(1073741827, 3))
+    assert_equal(Rational(1073741827, 1073741789),
+                 Rational(3, 1073741789) * Rational(1073741827, 3))
+    assert_equal(Rational(9, 1152921470247108503),
+                 Rational(3, 1073741789) / Rational(1073741827, 3))
+    assert_equal(Rational(1152921432666146002, 1152921470247108503),
+                 Rational(3, 1073741789) + Rational(1073741789, 1073741827))
+    assert_equal(Rational(-1152921426223695040, 1152921470247108503),
+                 Rational(3, 1073741789) - Rational(1073741789, 1073741827))
+    assert_equal(Rational(3, 1073741827),
+                 Rational(3, 1073741789) * Rational(1073741789, 1073741827))
+    assert_equal(Rational(3221225481, 1152921429444920521),
+                 Rational(3, 1073741789) / Rational(1073741789, 1073741827))
+    assert_equal(Rational(1073741830, 1073741789),
+                 Rational(3, 1073741789) + Rational(1073741827, 1073741789))
+    assert_equal(Rational(-1073741824, 1073741789),
+                 Rational(3, 1073741789) - Rational(1073741827, 1073741789))
+    assert_equal(Rational(3221225481, 1152921429444920521),
+                 Rational(3, 1073741789) * Rational(1073741827, 1073741789))
+    assert_equal(Rational(3, 1073741827),
+                 Rational(3, 1073741789) / Rational(1073741827, 1073741789))
+    assert_equal(Rational(1073741789, 3), +Rational(1073741789, 3))
+    assert_equal(Rational(-1073741789, 3), -Rational(1073741789, 3))
+    assert_equal(Rational(1073741792, 3),
+                 Rational(1073741789, 3) + Rational(1, 1))
+    assert_equal(Rational(1073741786, 3),
+                 Rational(1073741789, 3) - Rational(1, 1))
+    assert_equal(Rational(1073741789, 3),
+                 Rational(1073741789, 3) * Rational(1, 1))
+    assert_equal(Rational(1073741789, 3),
+                 Rational(1073741789, 3) / Rational(1, 1))
+    assert_equal(Rational(1073741795, 3),
+                 Rational(1073741789, 3) + Rational(2, 1))
+    assert_equal(Rational(1073741783, 3),
+                 Rational(1073741789, 3) - Rational(2, 1))
+    assert_equal(Rational(2147483578, 3),
+                 Rational(1073741789, 3) * Rational(2, 1))
+    assert_equal(Rational(1073741789, 6),
+                 Rational(1073741789, 3) / Rational(2, 1))
+    assert_equal(Rational(1073741798, 3),
+                 Rational(1073741789, 3) + Rational(3, 1))
+    assert_equal(Rational(1073741780, 3),
+                 Rational(1073741789, 3) - Rational(3, 1))
+    assert_equal(Rational(1073741789, 1),
+                 Rational(1073741789, 3) * Rational(3, 1))
+    assert_equal(Rational(1073741789, 9),
+                 Rational(1073741789, 3) / Rational(3, 1))
+    assert_equal(Rational(4294967156, 3),
+                 Rational(1073741789, 3) + Rational(1073741789, 1))
+    assert_equal(Rational(-2147483578, 3),
+                 Rational(1073741789, 3) - Rational(1073741789, 1))
+    assert_equal(Rational(1152921429444920521, 3),
+                 Rational(1073741789, 3) * Rational(1073741789, 1))
+    assert_equal(Rational(1, 3),
+                 Rational(1073741789, 3) / Rational(1073741789, 1))
+    assert_equal(Rational(4294967270, 3),
+                 Rational(1073741789, 3) + Rational(1073741827, 1))
+    assert_equal(Rational(-2147483692, 3),
+                 Rational(1073741789, 3) - Rational(1073741827, 1))
+    assert_equal(Rational(1152921470247108503, 3),
+                 Rational(1073741789, 3) * Rational(1073741827, 1))
+    assert_equal(Rational(1073741789, 3221225481),
+                 Rational(1073741789, 3) / Rational(1073741827, 1))
+    assert_equal(Rational(1073741791, 3),
+                 Rational(1073741789, 3) + Rational(2, 3))
+    assert_equal(Rational(357913929, 1),
+                 Rational(1073741789, 3) - Rational(2, 3))
+    assert_equal(Rational(2147483578, 9),
+                 Rational(1073741789, 3) * Rational(2, 3))
+    assert_equal(Rational(1073741789, 2),
+                 Rational(1073741789, 3) / Rational(2, 3))
+    assert_equal(Rational(2147483587, 6),
+                 Rational(1073741789, 3) + Rational(3, 2))
+    assert_equal(Rational(2147483569, 6),
+                 Rational(1073741789, 3) - Rational(3, 2))
+    assert_equal(Rational(1073741789, 2),
+                 Rational(1073741789, 3) * Rational(3, 2))
+    assert_equal(Rational(2147483578, 9),
+                 Rational(1073741789, 3) / Rational(3, 2))
+    assert_equal(Rational(1152921429444920530, 3221225367),
+                 Rational(1073741789, 3) + Rational(3, 1073741789))
+    assert_equal(Rational(1152921429444920512, 3221225367),
+                 Rational(1073741789, 3) - Rational(3, 1073741789))
+    assert_equal(Rational(1, 1),
+                 Rational(1073741789, 3) * Rational(3, 1073741789))
+    assert_equal(Rational(1152921429444920521, 9),
+                 Rational(1073741789, 3) / Rational(3, 1073741789))
+    assert_equal(Rational(2147483578, 3),
+                 Rational(1073741789, 3) + Rational(1073741789, 3))
+    assert_equal(Rational(0, 1),
+                 Rational(1073741789, 3) - Rational(1073741789, 3))
+    assert_equal(Rational(1152921429444920521, 9),
+                 Rational(1073741789, 3) * Rational(1073741789, 3))
+    assert_equal(Rational(1, 1),
+                 Rational(1073741789, 3) / Rational(1073741789, 3))
+    assert_equal(Rational(1152921470247108512, 3221225481),
+                 Rational(1073741789, 3) + Rational(3, 1073741827))
+    assert_equal(Rational(1152921470247108494, 3221225481),
+                 Rational(1073741789, 3) - Rational(3, 1073741827))
+    assert_equal(Rational(1073741789, 1073741827),
+                 Rational(1073741789, 3) * Rational(3, 1073741827))
+    assert_equal(Rational(1152921470247108503, 9),
+                 Rational(1073741789, 3) / Rational(3, 1073741827))
+    assert_equal(Rational(715827872, 1),
+                 Rational(1073741789, 3) + Rational(1073741827, 3))
+    assert_equal(Rational(-38, 3),
+                 Rational(1073741789, 3) - Rational(1073741827, 3))
+    assert_equal(Rational(1152921470247108503, 9),
+                 Rational(1073741789, 3) * Rational(1073741827, 3))
+    assert_equal(Rational(1073741789, 1073741827),
+                 Rational(1073741789, 3) / Rational(1073741827, 3))
+    assert_equal(Rational(1152921473468333870, 3221225481),
+                 Rational(1073741789, 3) + Rational(1073741789, 1073741827))
+    assert_equal(Rational(1152921467025883136, 3221225481),
+                 Rational(1073741789, 3) - Rational(1073741789, 1073741827))
+    assert_equal(Rational(1152921429444920521, 3221225481),
+                 Rational(1073741789, 3) * Rational(1073741789, 1073741827))
+    assert_equal(Rational(1073741827, 3),
+                 Rational(1073741789, 3) / Rational(1073741789, 1073741827))
+    assert_equal(Rational(1152921432666146002, 3221225367),
+                 Rational(1073741789, 3) + Rational(1073741827, 1073741789))
+    assert_equal(Rational(1152921426223695040, 3221225367),
+                 Rational(1073741789, 3) - Rational(1073741827, 1073741789))
+    assert_equal(Rational(1073741827, 3),
+                 Rational(1073741789, 3) * Rational(1073741827, 1073741789))
+    assert_equal(Rational(1152921429444920521, 3221225481),
+                 Rational(1073741789, 3) / Rational(1073741827, 1073741789))
+    assert_equal(Rational(3, 1073741827), +Rational(3, 1073741827))
+    assert_equal(Rational(-3, 1073741827), -Rational(3, 1073741827))
+    assert_equal(Rational(1073741830, 1073741827),
+                 Rational(3, 1073741827) + Rational(1, 1))
+    assert_equal(Rational(-1073741824, 1073741827),
+                 Rational(3, 1073741827) - Rational(1, 1))
+    assert_equal(Rational(3, 1073741827),
+                 Rational(3, 1073741827) * Rational(1, 1))
+    assert_equal(Rational(3, 1073741827),
+                 Rational(3, 1073741827) / Rational(1, 1))
+    assert_equal(Rational(2147483657, 1073741827),
+                 Rational(3, 1073741827) + Rational(2, 1))
+    assert_equal(Rational(-2147483651, 1073741827),
+                 Rational(3, 1073741827) - Rational(2, 1))
+    assert_equal(Rational(6, 1073741827),
+                 Rational(3, 1073741827) * Rational(2, 1))
+    assert_equal(Rational(3, 2147483654),
+                 Rational(3, 1073741827) / Rational(2, 1))
+    assert_equal(Rational(3221225484, 1073741827),
+                 Rational(3, 1073741827) + Rational(3, 1))
+    assert_equal(Rational(-3221225478, 1073741827),
+                 Rational(3, 1073741827) - Rational(3, 1))
+    assert_equal(Rational(9, 1073741827),
+                 Rational(3, 1073741827) * Rational(3, 1))
+    assert_equal(Rational(1, 1073741827),
+                 Rational(3, 1073741827) / Rational(3, 1))
+    assert_equal(Rational(1152921470247108506, 1073741827),
+                 Rational(3, 1073741827) + Rational(1073741789, 1))
+    assert_equal(Rational(-1152921470247108500, 1073741827),
+                 Rational(3, 1073741827) - Rational(1073741789, 1))
+    assert_equal(Rational(3221225367, 1073741827),
+                 Rational(3, 1073741827) * Rational(1073741789, 1))
+    assert_equal(Rational(3, 1152921470247108503),
+                 Rational(3, 1073741827) / Rational(1073741789, 1))
+    assert_equal(Rational(1152921511049297932, 1073741827),
+                 Rational(3, 1073741827) + Rational(1073741827, 1))
+    assert_equal(Rational(-1152921511049297926, 1073741827),
+                 Rational(3, 1073741827) - Rational(1073741827, 1))
+    assert_equal(Rational(3, 1),
+                 Rational(3, 1073741827) * Rational(1073741827, 1))
+    assert_equal(Rational(3, 1152921511049297929),
+                 Rational(3, 1073741827) / Rational(1073741827, 1))
+    assert_equal(Rational(2147483663, 3221225481),
+                 Rational(3, 1073741827) + Rational(2, 3))
+    assert_equal(Rational(-2147483645, 3221225481),
+                 Rational(3, 1073741827) - Rational(2, 3))
+    assert_equal(Rational(2, 1073741827),
+                 Rational(3, 1073741827) * Rational(2, 3))
+    assert_equal(Rational(9, 2147483654),
+                 Rational(3, 1073741827) / Rational(2, 3))
+    assert_equal(Rational(3221225487, 2147483654),
+                 Rational(3, 1073741827) + Rational(3, 2))
+    assert_equal(Rational(-3221225475, 2147483654),
+                 Rational(3, 1073741827) - Rational(3, 2))
+    assert_equal(Rational(9, 2147483654),
+                 Rational(3, 1073741827) * Rational(3, 2))
+    assert_equal(Rational(2, 1073741827),
+                 Rational(3, 1073741827) / Rational(3, 2))
+    assert_equal(Rational(6442450848, 1152921470247108503),
+                 Rational(3, 1073741827) + Rational(3, 1073741789))
+    assert_equal(Rational(-114, 1152921470247108503),
+                 Rational(3, 1073741827) - Rational(3, 1073741789))
+    assert_equal(Rational(9, 1152921470247108503),
+                 Rational(3, 1073741827) * Rational(3, 1073741789))
+    assert_equal(Rational(1073741789, 1073741827),
+                 Rational(3, 1073741827) / Rational(3, 1073741789))
+    assert_equal(Rational(1152921470247108512, 3221225481),
+                 Rational(3, 1073741827) + Rational(1073741789, 3))
+    assert_equal(Rational(-1152921470247108494, 3221225481),
+                 Rational(3, 1073741827) - Rational(1073741789, 3))
+    assert_equal(Rational(1073741789, 1073741827),
+                 Rational(3, 1073741827) * Rational(1073741789, 3))
+    assert_equal(Rational(9, 1152921470247108503),
+                 Rational(3, 1073741827) / Rational(1073741789, 3))
+    assert_equal(Rational(6, 1073741827),
+                 Rational(3, 1073741827) + Rational(3, 1073741827))
+    assert_equal(Rational(0, 1),
+                 Rational(3, 1073741827) - Rational(3, 1073741827))
+    assert_equal(Rational(9, 1152921511049297929),
+                 Rational(3, 1073741827) * Rational(3, 1073741827))
+    assert_equal(Rational(1, 1),
+                 Rational(3, 1073741827) / Rational(3, 1073741827))
+    assert_equal(Rational(1152921511049297938, 3221225481),
+                 Rational(3, 1073741827) + Rational(1073741827, 3))
+    assert_equal(Rational(-1152921511049297920, 3221225481),
+                 Rational(3, 1073741827) - Rational(1073741827, 3))
+    assert_equal(Rational(1, 1),
+                 Rational(3, 1073741827) * Rational(1073741827, 3))
+    assert_equal(Rational(9, 1152921511049297929),
+                 Rational(3, 1073741827) / Rational(1073741827, 3))
+    assert_equal(Rational(1073741792, 1073741827),
+                 Rational(3, 1073741827) + Rational(1073741789, 1073741827))
+    assert_equal(Rational(-1073741786, 1073741827),
+                 Rational(3, 1073741827) - Rational(1073741789, 1073741827))
+    assert_equal(Rational(3221225367, 1152921511049297929),
+                 Rational(3, 1073741827) * Rational(1073741789, 1073741827))
+    assert_equal(Rational(3, 1073741789),
+                 Rational(3, 1073741827) / Rational(1073741789, 1073741827))
+    assert_equal(Rational(1152921514270523296, 1152921470247108503),
+                 Rational(3, 1073741827) + Rational(1073741827, 1073741789))
+    assert_equal(Rational(-1152921507828072562, 1152921470247108503),
+                 Rational(3, 1073741827) - Rational(1073741827, 1073741789))
+    assert_equal(Rational(3, 1073741789),
+                 Rational(3, 1073741827) * Rational(1073741827, 1073741789))
+    assert_equal(Rational(3221225367, 1152921511049297929),
+                 Rational(3, 1073741827) / Rational(1073741827, 1073741789))
+    assert_equal(Rational(1073741827, 3), +Rational(1073741827, 3))
+    assert_equal(Rational(-1073741827, 3), -Rational(1073741827, 3))
+    assert_equal(Rational(1073741830, 3),
+                 Rational(1073741827, 3) + Rational(1, 1))
+    assert_equal(Rational(1073741824, 3),
+                 Rational(1073741827, 3) - Rational(1, 1))
+    assert_equal(Rational(1073741827, 3),
+                 Rational(1073741827, 3) * Rational(1, 1))
+    assert_equal(Rational(1073741827, 3),
+                 Rational(1073741827, 3) / Rational(1, 1))
+    assert_equal(Rational(1073741833, 3),
+                 Rational(1073741827, 3) + Rational(2, 1))
+    assert_equal(Rational(1073741821, 3),
+                 Rational(1073741827, 3) - Rational(2, 1))
+    assert_equal(Rational(2147483654, 3),
+                 Rational(1073741827, 3) * Rational(2, 1))
+    assert_equal(Rational(1073741827, 6),
+                 Rational(1073741827, 3) / Rational(2, 1))
+    assert_equal(Rational(1073741836, 3),
+                 Rational(1073741827, 3) + Rational(3, 1))
+    assert_equal(Rational(1073741818, 3),
+                 Rational(1073741827, 3) - Rational(3, 1))
+    assert_equal(Rational(1073741827, 1),
+                 Rational(1073741827, 3) * Rational(3, 1))
+    assert_equal(Rational(1073741827, 9),
+                 Rational(1073741827, 3) / Rational(3, 1))
+    assert_equal(Rational(4294967194, 3),
+                 Rational(1073741827, 3) + Rational(1073741789, 1))
+    assert_equal(Rational(-2147483540, 3),
+                 Rational(1073741827, 3) - Rational(1073741789, 1))
+    assert_equal(Rational(1152921470247108503, 3),
+                 Rational(1073741827, 3) * Rational(1073741789, 1))
+    assert_equal(Rational(1073741827, 3221225367),
+                 Rational(1073741827, 3) / Rational(1073741789, 1))
+    assert_equal(Rational(4294967308, 3),
+                 Rational(1073741827, 3) + Rational(1073741827, 1))
+    assert_equal(Rational(-2147483654, 3),
+                 Rational(1073741827, 3) - Rational(1073741827, 1))
+    assert_equal(Rational(1152921511049297929, 3),
+                 Rational(1073741827, 3) * Rational(1073741827, 1))
+    assert_equal(Rational(1, 3),
+                 Rational(1073741827, 3) / Rational(1073741827, 1))
+    assert_equal(Rational(357913943, 1),
+                 Rational(1073741827, 3) + Rational(2, 3))
+    assert_equal(Rational(1073741825, 3),
+                 Rational(1073741827, 3) - Rational(2, 3))
+    assert_equal(Rational(2147483654, 9),
+                 Rational(1073741827, 3) * Rational(2, 3))
+    assert_equal(Rational(1073741827, 2),
+                 Rational(1073741827, 3) / Rational(2, 3))
+    assert_equal(Rational(2147483663, 6),
+                 Rational(1073741827, 3) + Rational(3, 2))
+    assert_equal(Rational(2147483645, 6),
+                 Rational(1073741827, 3) - Rational(3, 2))
+    assert_equal(Rational(1073741827, 2),
+                 Rational(1073741827, 3) * Rational(3, 2))
+    assert_equal(Rational(2147483654, 9),
+                 Rational(1073741827, 3) / Rational(3, 2))
+    assert_equal(Rational(1152921470247108512, 3221225367),
+                 Rational(1073741827, 3) + Rational(3, 1073741789))
+    assert_equal(Rational(1152921470247108494, 3221225367),
+                 Rational(1073741827, 3) - Rational(3, 1073741789))
+    assert_equal(Rational(1073741827, 1073741789),
+                 Rational(1073741827, 3) * Rational(3, 1073741789))
+    assert_equal(Rational(1152921470247108503, 9),
+                 Rational(1073741827, 3) / Rational(3, 1073741789))
+    assert_equal(Rational(715827872, 1),
+                 Rational(1073741827, 3) + Rational(1073741789, 3))
+    assert_equal(Rational(38, 3),
+                 Rational(1073741827, 3) - Rational(1073741789, 3))
+    assert_equal(Rational(1152921470247108503, 9),
+                 Rational(1073741827, 3) * Rational(1073741789, 3))
+    assert_equal(Rational(1073741827, 1073741789),
+                 Rational(1073741827, 3) / Rational(1073741789, 3))
+    assert_equal(Rational(1152921511049297938, 3221225481),
+                 Rational(1073741827, 3) + Rational(3, 1073741827))
+    assert_equal(Rational(1152921511049297920, 3221225481),
+                 Rational(1073741827, 3) - Rational(3, 1073741827))
+    assert_equal(Rational(1, 1),
+                 Rational(1073741827, 3) * Rational(3, 1073741827))
+    assert_equal(Rational(1152921511049297929, 9),
+                 Rational(1073741827, 3) / Rational(3, 1073741827))
+    assert_equal(Rational(2147483654, 3),
+                 Rational(1073741827, 3) + Rational(1073741827, 3))
+    assert_equal(Rational(0, 1),
+                 Rational(1073741827, 3) - Rational(1073741827, 3))
+    assert_equal(Rational(1152921511049297929, 9),
+                 Rational(1073741827, 3) * Rational(1073741827, 3))
+    assert_equal(Rational(1, 1),
+                 Rational(1073741827, 3) / Rational(1073741827, 3))
+    assert_equal(Rational(1152921514270523296, 3221225481),
+                 Rational(1073741827, 3) + Rational(1073741789, 1073741827))
+    assert_equal(Rational(1152921507828072562, 3221225481),
+                 Rational(1073741827, 3) - Rational(1073741789, 1073741827))
+    assert_equal(Rational(1073741789, 3),
+                 Rational(1073741827, 3) * Rational(1073741789, 1073741827))
+    assert_equal(Rational(1152921511049297929, 3221225367),
+                 Rational(1073741827, 3) / Rational(1073741789, 1073741827))
+    assert_equal(Rational(1152921473468333984, 3221225367),
+                 Rational(1073741827, 3) + Rational(1073741827, 1073741789))
+    assert_equal(Rational(1152921467025883022, 3221225367),
+                 Rational(1073741827, 3) - Rational(1073741827, 1073741789))
+    assert_equal(Rational(1152921511049297929, 3221225367),
+                 Rational(1073741827, 3) * Rational(1073741827, 1073741789))
+    assert_equal(Rational(1073741789, 3),
+                 Rational(1073741827, 3) / Rational(1073741827, 1073741789))
+    assert_equal(Rational(1073741789, 1073741827), +Rational(1073741789, 1073741827))
+    assert_equal(Rational(-1073741789, 1073741827), -Rational(1073741789, 1073741827))
+    assert_equal(Rational(2147483616, 1073741827),
+                 Rational(1073741789, 1073741827) + Rational(1, 1))
+    assert_equal(Rational(-38, 1073741827),
+                 Rational(1073741789, 1073741827) - Rational(1, 1))
+    assert_equal(Rational(1073741789, 1073741827),
+                 Rational(1073741789, 1073741827) * Rational(1, 1))
+    assert_equal(Rational(1073741789, 1073741827),
+                 Rational(1073741789, 1073741827) / Rational(1, 1))
+    assert_equal(Rational(3221225443, 1073741827),
+                 Rational(1073741789, 1073741827) + Rational(2, 1))
+    assert_equal(Rational(-1073741865, 1073741827),
+                 Rational(1073741789, 1073741827) - Rational(2, 1))
+    assert_equal(Rational(2147483578, 1073741827),
+                 Rational(1073741789, 1073741827) * Rational(2, 1))
+    assert_equal(Rational(1073741789, 2147483654),
+                 Rational(1073741789, 1073741827) / Rational(2, 1))
+    assert_equal(Rational(4294967270, 1073741827),
+                 Rational(1073741789, 1073741827) + Rational(3, 1))
+    assert_equal(Rational(-2147483692, 1073741827),
+                 Rational(1073741789, 1073741827) - Rational(3, 1))
+    assert_equal(Rational(3221225367, 1073741827),
+                 Rational(1073741789, 1073741827) * Rational(3, 1))
+    assert_equal(Rational(1073741789, 3221225481),
+                 Rational(1073741789, 1073741827) / Rational(3, 1))
+    assert_equal(Rational(1152921471320850292, 1073741827),
+                 Rational(1073741789, 1073741827) + Rational(1073741789, 1))
+    assert_equal(Rational(-1152921469173366714, 1073741827),
+                 Rational(1073741789, 1073741827) - Rational(1073741789, 1))
+    assert_equal(Rational(1152921429444920521, 1073741827),
+                 Rational(1073741789, 1073741827) * Rational(1073741789, 1))
+    assert_equal(Rational(1, 1073741827),
+                 Rational(1073741789, 1073741827) / Rational(1073741789, 1))
+    assert_equal(Rational(1152921512123039718, 1073741827),
+                 Rational(1073741789, 1073741827) + Rational(1073741827, 1))
+    assert_equal(Rational(-1152921509975556140, 1073741827),
+                 Rational(1073741789, 1073741827) - Rational(1073741827, 1))
+    assert_equal(Rational(1073741789, 1),
+                 Rational(1073741789, 1073741827) * Rational(1073741827, 1))
+    assert_equal(Rational(1073741789, 1152921511049297929),
+                 Rational(1073741789, 1073741827) / Rational(1073741827, 1))
+    assert_equal(Rational(5368709021, 3221225481),
+                 Rational(1073741789, 1073741827) + Rational(2, 3))
+    assert_equal(Rational(1073741713, 3221225481),
+                 Rational(1073741789, 1073741827) - Rational(2, 3))
+    assert_equal(Rational(2147483578, 3221225481),
+                 Rational(1073741789, 1073741827) * Rational(2, 3))
+    assert_equal(Rational(3221225367, 2147483654),
+                 Rational(1073741789, 1073741827) / Rational(2, 3))
+    assert_equal(Rational(5368709059, 2147483654),
+                 Rational(1073741789, 1073741827) + Rational(3, 2))
+    assert_equal(Rational(-1073741903, 2147483654),
+                 Rational(1073741789, 1073741827) - Rational(3, 2))
+    assert_equal(Rational(3221225367, 2147483654),
+                 Rational(1073741789, 1073741827) * Rational(3, 2))
+    assert_equal(Rational(2147483578, 3221225481),
+                 Rational(1073741789, 1073741827) / Rational(3, 2))
+    assert_equal(Rational(1152921432666146002, 1152921470247108503),
+                 Rational(1073741789, 1073741827) + Rational(3, 1073741789))
+    assert_equal(Rational(1152921426223695040, 1152921470247108503),
+                 Rational(1073741789, 1073741827) - Rational(3, 1073741789))
+    assert_equal(Rational(3, 1073741827),
+                 Rational(1073741789, 1073741827) * Rational(3, 1073741789))
+    assert_equal(Rational(1152921429444920521, 3221225481),
+                 Rational(1073741789, 1073741827) / Rational(3, 1073741789))
+    assert_equal(Rational(1152921473468333870, 3221225481),
+                 Rational(1073741789, 1073741827) + Rational(1073741789, 3))
+    assert_equal(Rational(-1152921467025883136, 3221225481),
+                 Rational(1073741789, 1073741827) - Rational(1073741789, 3))
+    assert_equal(Rational(1152921429444920521, 3221225481),
+                 Rational(1073741789, 1073741827) * Rational(1073741789, 3))
+    assert_equal(Rational(3, 1073741827),
+                 Rational(1073741789, 1073741827) / Rational(1073741789, 3))
+    assert_equal(Rational(1073741792, 1073741827),
+                 Rational(1073741789, 1073741827) + Rational(3, 1073741827))
+    assert_equal(Rational(1073741786, 1073741827),
+                 Rational(1073741789, 1073741827) - Rational(3, 1073741827))
+    assert_equal(Rational(3221225367, 1152921511049297929),
+                 Rational(1073741789, 1073741827) * Rational(3, 1073741827))
+    assert_equal(Rational(1073741789, 3),
+                 Rational(1073741789, 1073741827) / Rational(3, 1073741827))
+    assert_equal(Rational(1152921514270523296, 3221225481),
+                 Rational(1073741789, 1073741827) + Rational(1073741827, 3))
+    assert_equal(Rational(-1152921507828072562, 3221225481),
+                 Rational(1073741789, 1073741827) - Rational(1073741827, 3))
+    assert_equal(Rational(1073741789, 3),
+                 Rational(1073741789, 1073741827) * Rational(1073741827, 3))
+    assert_equal(Rational(3221225367, 1152921511049297929),
+                 Rational(1073741789, 1073741827) / Rational(1073741827, 3))
+    assert_equal(Rational(2147483578, 1073741827),
+                 Rational(1073741789, 1073741827) + Rational(1073741789, 1073741827))
+    assert_equal(Rational(0, 1),
+                 Rational(1073741789, 1073741827) - Rational(1073741789, 1073741827))
+    assert_equal(Rational(1152921429444920521, 1152921511049297929),
+                 Rational(1073741789, 1073741827) * Rational(1073741789, 1073741827))
+    assert_equal(Rational(1, 1),
+                 Rational(1073741789, 1073741827) / Rational(1073741789, 1073741827))
+    assert_equal(Rational(2305842940494218450, 1152921470247108503),
+                 Rational(1073741789, 1073741827) + Rational(1073741827, 1073741789))
+    assert_equal(Rational(-81604377408, 1152921470247108503),
+                 Rational(1073741789, 1073741827) - Rational(1073741827, 1073741789))
+    assert_equal(Rational(1, 1),
+                 Rational(1073741789, 1073741827) * Rational(1073741827, 1073741789))
+    assert_equal(Rational(1152921429444920521, 1152921511049297929),
+                 Rational(1073741789, 1073741827) / Rational(1073741827, 1073741789))
+    assert_equal(Rational(1073741827, 1073741789), +Rational(1073741827, 1073741789))
+    assert_equal(Rational(-1073741827, 1073741789), -Rational(1073741827, 1073741789))
+    assert_equal(Rational(2147483616, 1073741789),
+                 Rational(1073741827, 1073741789) + Rational(1, 1))
+    assert_equal(Rational(38, 1073741789),
+                 Rational(1073741827, 1073741789) - Rational(1, 1))
+    assert_equal(Rational(1073741827, 1073741789),
+                 Rational(1073741827, 1073741789) * Rational(1, 1))
+    assert_equal(Rational(1073741827, 1073741789),
+                 Rational(1073741827, 1073741789) / Rational(1, 1))
+    assert_equal(Rational(3221225405, 1073741789),
+                 Rational(1073741827, 1073741789) + Rational(2, 1))
+    assert_equal(Rational(-1073741751, 1073741789),
+                 Rational(1073741827, 1073741789) - Rational(2, 1))
+    assert_equal(Rational(2147483654, 1073741789),
+                 Rational(1073741827, 1073741789) * Rational(2, 1))
+    assert_equal(Rational(1073741827, 2147483578),
+                 Rational(1073741827, 1073741789) / Rational(2, 1))
+    assert_equal(Rational(4294967194, 1073741789),
+                 Rational(1073741827, 1073741789) + Rational(3, 1))
+    assert_equal(Rational(-2147483540, 1073741789),
+                 Rational(1073741827, 1073741789) - Rational(3, 1))
+    assert_equal(Rational(3221225481, 1073741789),
+                 Rational(1073741827, 1073741789) * Rational(3, 1))
+    assert_equal(Rational(1073741827, 3221225367),
+                 Rational(1073741827, 1073741789) / Rational(3, 1))
+    assert_equal(Rational(1152921430518662348, 1073741789),
+                 Rational(1073741827, 1073741789) + Rational(1073741789, 1))
+    assert_equal(Rational(-1152921428371178694, 1073741789),
+                 Rational(1073741827, 1073741789) - Rational(1073741789, 1))
+    assert_equal(Rational(1073741827, 1),
+                 Rational(1073741827, 1073741789) * Rational(1073741789, 1))
+    assert_equal(Rational(1073741827, 1152921429444920521),
+                 Rational(1073741827, 1073741789) / Rational(1073741789, 1))
+    assert_equal(Rational(1152921471320850330, 1073741789),
+                 Rational(1073741827, 1073741789) + Rational(1073741827, 1))
+    assert_equal(Rational(-1152921469173366676, 1073741789),
+                 Rational(1073741827, 1073741789) - Rational(1073741827, 1))
+    assert_equal(Rational(1152921511049297929, 1073741789),
+                 Rational(1073741827, 1073741789) * Rational(1073741827, 1))
+    assert_equal(Rational(1, 1073741789),
+                 Rational(1073741827, 1073741789) / Rational(1073741827, 1))
+    assert_equal(Rational(5368709059, 3221225367),
+                 Rational(1073741827, 1073741789) + Rational(2, 3))
+    assert_equal(Rational(1073741903, 3221225367),
+                 Rational(1073741827, 1073741789) - Rational(2, 3))
+    assert_equal(Rational(2147483654, 3221225367),
+                 Rational(1073741827, 1073741789) * Rational(2, 3))
+    assert_equal(Rational(3221225481, 2147483578),
+                 Rational(1073741827, 1073741789) / Rational(2, 3))
+    assert_equal(Rational(5368709021, 2147483578),
+                 Rational(1073741827, 1073741789) + Rational(3, 2))
+    assert_equal(Rational(-1073741713, 2147483578),
+                 Rational(1073741827, 1073741789) - Rational(3, 2))
+    assert_equal(Rational(3221225481, 2147483578),
+                 Rational(1073741827, 1073741789) * Rational(3, 2))
+    assert_equal(Rational(2147483654, 3221225367),
+                 Rational(1073741827, 1073741789) / Rational(3, 2))
+    assert_equal(Rational(1073741830, 1073741789),
+                 Rational(1073741827, 1073741789) + Rational(3, 1073741789))
+    assert_equal(Rational(1073741824, 1073741789),
+                 Rational(1073741827, 1073741789) - Rational(3, 1073741789))
+    assert_equal(Rational(3221225481, 1152921429444920521),
+                 Rational(1073741827, 1073741789) * Rational(3, 1073741789))
+    assert_equal(Rational(1073741827, 3),
+                 Rational(1073741827, 1073741789) / Rational(3, 1073741789))
+    assert_equal(Rational(1152921432666146002, 3221225367),
+                 Rational(1073741827, 1073741789) + Rational(1073741789, 3))
+    assert_equal(Rational(-1152921426223695040, 3221225367),
+                 Rational(1073741827, 1073741789) - Rational(1073741789, 3))
+    assert_equal(Rational(1073741827, 3),
+                 Rational(1073741827, 1073741789) * Rational(1073741789, 3))
+    assert_equal(Rational(3221225481, 1152921429444920521),
+                 Rational(1073741827, 1073741789) / Rational(1073741789, 3))
+    assert_equal(Rational(1152921514270523296, 1152921470247108503),
+                 Rational(1073741827, 1073741789) + Rational(3, 1073741827))
+    assert_equal(Rational(1152921507828072562, 1152921470247108503),
+                 Rational(1073741827, 1073741789) - Rational(3, 1073741827))
+    assert_equal(Rational(3, 1073741789),
+                 Rational(1073741827, 1073741789) * Rational(3, 1073741827))
+    assert_equal(Rational(1152921511049297929, 3221225367),
+                 Rational(1073741827, 1073741789) / Rational(3, 1073741827))
+    assert_equal(Rational(1152921473468333984, 3221225367),
+                 Rational(1073741827, 1073741789) + Rational(1073741827, 3))
+    assert_equal(Rational(-1152921467025883022, 3221225367),
+                 Rational(1073741827, 1073741789) - Rational(1073741827, 3))
+    assert_equal(Rational(1152921511049297929, 3221225367),
+                 Rational(1073741827, 1073741789) * Rational(1073741827, 3))
+    assert_equal(Rational(3, 1073741789),
+                 Rational(1073741827, 1073741789) / Rational(1073741827, 3))
+    assert_equal(Rational(2305842940494218450, 1152921470247108503),
+                 Rational(1073741827, 1073741789) + Rational(1073741789, 1073741827))
+    assert_equal(Rational(81604377408, 1152921470247108503),
+                 Rational(1073741827, 1073741789) - Rational(1073741789, 1073741827))
+    assert_equal(Rational(1, 1),
+                 Rational(1073741827, 1073741789) * Rational(1073741789, 1073741827))
+    assert_equal(Rational(1152921511049297929, 1152921429444920521),
+                 Rational(1073741827, 1073741789) / Rational(1073741789, 1073741827))
+    assert_equal(Rational(2147483654, 1073741789),
+                 Rational(1073741827, 1073741789) + Rational(1073741827, 1073741789))
+    assert_equal(Rational(0, 1),
+                 Rational(1073741827, 1073741789) - Rational(1073741827, 1073741789))
+    assert_equal(Rational(1152921511049297929, 1152921429444920521),
+                 Rational(1073741827, 1073741789) * Rational(1073741827, 1073741789))
+    assert_equal(Rational(1, 1),
+                 Rational(1073741827, 1073741789) / Rational(1073741827, 1073741789))
+  end
+
+end
--- a/test/ruby/suicide.rb
+++ b/test/ruby/suicide.rb
@@ -1,2 +1,4 @@
 STDERR.reopen(STDOUT)
-at_exit{Process.kill(:INT, $$)}
+at_exit{Process.kill(:INT, $$); sleep 0}
+# brent@mbari.org says
+#  sleep 0 avoids race between process termination and signal reception
--- a/test/ruby/test_range.rb
+++ b/test/ruby/test_range.rb
@@ -20,7 +20,9 @@
     assert_equal(5, (1.1...6).step.to_a.size)
     assert_equal(5, (1...6).step(1.1).to_a.size)
     assert_equal(3, (1.0...6.3).step(1.8).to_a.size)
-    assert_equal(3, (1.0...6.4).step(1.8).to_a.size)
+    #binary floating point cannot represent 0.1 decimal exactly
+    #Use BigDecimal if you want an exact representation of 0.1 !
+    assert_equal(4, (1.0...6.4000000000001).step(1.8).to_a.size)
     assert_equal(4, (1.0...6.5).step(1.8).to_a.size)
   end
 end
--- a/version.c
+++ b/version.c
@@ -11,12 +11,14 @@
 **********************************************************************/
 
 #include "ruby.h"
+#include "rubysig.h"
 #include "version.h"
 #include <stdio.h>
 
 #define PRINT(type) puts(ruby_##type)
 #define MKSTR(type) rb_obj_freeze(rb_str_new(ruby_##type, sizeof(ruby_##type)-1))
 
+const char ruby_engine[] = RUBY_ENGINE;
 const char ruby_version[] = RUBY_VERSION;
 const char ruby_release_date[] = RUBY_RELEASE_DATE;
 const char ruby_platform[] = RUBY_PLATFORM;
@@ -24,24 +26,30 @@
 const char *ruby_description;
 const char *ruby_copyright;
 
+#define REE_VERSION "2012.02"
+
 void
 Init_version()
 {
     static char description[128];
     static char copyright[128];
+    VALUE e = MKSTR(engine);
     VALUE v = MKSTR(version);
     VALUE d = MKSTR(release_date);
     VALUE p = MKSTR(platform);
     VALUE tmp;
 
+    rb_define_global_const("RUBY_ENGINE", e);
     rb_define_global_const("RUBY_VERSION", v);
     rb_define_global_const("RUBY_RELEASE_DATE", d);
     rb_define_global_const("RUBY_PLATFORM", p);
     rb_define_global_const("RUBY_PATCHLEVEL", INT2FIX(RUBY_PATCHLEVEL));
 
-    snprintf(description, sizeof(description), "ruby %s (%s %s %d) [%s]",
+    snprintf(description, sizeof(description),
+             "ruby %s (%s %s %d) [%s], MBARI 0x%x, Ruby Enterprise Edition %s",
              RUBY_VERSION, RUBY_RELEASE_DATE, RUBY_RELEASE_STR,
-             RUBY_RELEASE_NUM, RUBY_PLATFORM);
+             RUBY_RELEASE_NUM, RUBY_PLATFORM,
+             STACK_WIPE_SITES, REE_VERSION);
     ruby_description = description;
     tmp = rb_obj_freeze(rb_str_new2(description));
     rb_define_global_const("RUBY_DESCRIPTION", tmp);
--- a/version.h
+++ b/version.h
@@ -1,3 +1,4 @@
+#define RUBY_ENGINE "ruby"
 #define RUBY_VERSION "1.8.7"
 #define RUBY_RELEASE_DATE "2013-06-27"
 #define RUBY_VERSION_CODE 187
@@ -25,5 +26,17 @@
 #define RUBY_BIRTH_MONTH 2
 #define RUBY_BIRTH_DAY 24
 
-#define RUBY_RELEASE_STR "patchlevel"
+#include "rubysig.h"
+
+#define string_arg(s) #s
+
+#ifdef MBARI_API
+#define _mbari_rev_ "MBARI"
+#else
+#define _mbari_rev_ "mbari"
+#endif
+
+#define MBARI_RELEASE(wipe_sites) _mbari_rev_ " 8/" string_arg(wipe_sites)
+
+#define RUBY_RELEASE_STR MBARI_RELEASE(STACK_WIPE_SITES) " on patchlevel"
 #define RUBY_RELEASE_NUM RUBY_PATCHLEVEL
