#!/bin/sh -e
##
## 01_play_speed_patch
##

. debian/patches/patch-opts

if [ $# -ne 1 ]; then
    echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
    exit 1
fi

case "$1" in
       -patch) patch $patch_opts -p1 < $0;;
       -unpatch) patch $patch_opts -p1 -R < $0;;
        *)
                echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
                exit 1;;
esac

exit 0

@DPATCH@
diff -ruN xine-lib-1.1.2/include/xine.h.in xine-lib-1.1.2-new/include/xine.h.in
--- xine-lib-1.1.2/include/xine.h.in	2006-09-01 00:15:32.000000000 +0300
+++ xine-lib-1.1.2-new/include/xine.h.in	2006-09-01 01:05:33.000000000 +0300
@@ -251,6 +251,31 @@
 int  xine_play (xine_stream_t *stream, int start_pos, int start_time);
 
 /*
+ * seeks a stream to a given position
+ * 
+ * semantics is similar to xine_play, but previous playback 
+ * speed is not changed (e.g. if a stream was paused it will remain paused
+ */
+int  xine_seek (xine_stream_t *stream, int start_pos, int start_time);
+
+/* starts seeking playback (audio is muted, video is played with given speed)
+ * trick_speed: 
+ * 1x = 1.000.000 of trick speed, 
+ * positive - forward, negative - backward
+ * returns:
+ * 1 - no error
+ * 0 - error
+ */
+int xine_start_trick_play(xine_stream_t *stream, int trick_speed);
+
+/* stops trick playback and restore original playback mode
+ * returns:
+ * 1 - no error
+ * 0 - error
+ */
+int xine_stop_trick_play(xine_stream_t *stream);
+
+/*
  * set xine to a trick mode for fast forward, backwards playback,
  * low latency seeking. Please note that this works only with some
  * input plugins. mode constants see below.
@@ -907,6 +932,15 @@
 #define XINE_STREAM_INFO_DVD_ANGLE_NUMBER   34
 #define XINE_STREAM_INFO_DVD_ANGLE_COUNT    35
 
+
+/* custom values for xine_(start|stop)_trick_play functionality */
+#define XINE_STREAM_INFO_TRICK_PLAY_SUPPORTED    51 /* 0 - not supported, 1 - supported */
+#define XINE_STREAM_INFO_TRICK_PLAY_ENABLED 52 /* trick play is on now */
+#define XINE_STREAM_INFO_TRICK_PLAY_CURRENT_SPEED 53 /* current trick play speed */
+#define XINE_STREAM_INFO_TRICK_PLAY_ORIGINAL_SPEED 54 /* original speed to restore to */
+#define XINE_STREAM_INFO_TRICK_PLAY_DISTINCTS_FRAME_TYPE 55 /* if stream distincts frames types */
+
+
 /* possible values for XINE_STREAM_INFO_VIDEO_AFD */
 #define XINE_VIDEO_AFD_NOT_PRESENT         -1
 #define XINE_VIDEO_AFD_RESERVED_0          0
diff -ruN xine-lib-1.1.2/src/libmpeg2/decode.c xine-lib-1.1.2-new/src/libmpeg2/decode.c
--- xine-lib-1.1.2/src/libmpeg2/decode.c	2006-09-01 00:12:22.000000000 +0300
+++ xine-lib-1.1.2-new/src/libmpeg2/decode.c	2006-09-01 01:05:33.000000000 +0300
@@ -151,6 +151,8 @@
   frame->duration = (int) ceil (duration);
   _x_stream_info_set(mpeg2dec->stream, XINE_STREAM_INFO_FRAME_DURATION, frame->duration);
   /*printf("mpeg2dec: rff=%u\n",frame->repeat_first_field);*/
+  _x_stream_info_set(mpeg2dec->stream, XINE_STREAM_INFO_TRICK_PLAY_SUPPORTED, 1);
+  _x_stream_info_set(mpeg2dec->stream, XINE_STREAM_INFO_TRICK_PLAY_DISTINCTS_FRAME_TYPE, 1);
 } 
 
 static double get_aspect_ratio(mpeg2dec_t *mpeg2dec)
diff -ruN xine-lib-1.1.2/src/xine-engine/video_out.c xine-lib-1.1.2-new/src/xine-engine/video_out.c
--- xine-lib-1.1.2/src/xine-engine/video_out.c	2006-09-01 00:13:00.000000000 +0300
+++ xine-lib-1.1.2-new/src/xine-engine/video_out.c	2006-09-01 01:08:35.000000000 +0300
@@ -497,6 +497,45 @@
       return 0;
     }
   }
+  
+  // trick playback code
+  // doing frames skip depending on skip mode and stream smartness
+  if (stream->trick_play_stream_distincts_frame_type)
+  {
+	  switch (stream->trick_play_frame_skip_mode)
+	  {
+		 // no skip
+		case 0:
+			break;
+		
+		// skip B-frames
+		  case 1:
+			  xprintf (stream->xine, XINE_VERBOSITY_DEBUG, "trick_play: skipping B-frame\n");
+			  frames_to_skip = 2;
+			  if ((img->picture_coding_type!=1)&&(img->picture_coding_type!=2))
+				  return 2;
+			break;
+		
+		// skip B&P-frames
+		  case 2:
+			  xprintf (stream->xine, XINE_VERBOSITY_DEBUG, "trick_play: skipping B/P-frame\n");
+			  frames_to_skip = 4;
+			  if ((img->picture_coding_type!=1))
+				  return 4;
+			  break;
+		// no skip
+		  default:
+			  break;
+	  }
+  }
+  else
+  {
+	  if (stream->trick_play_frame_skip_mode)
+	  {
+		  xprintf (stream->xine, XINE_VERBOSITY_DEBUG, "trick_play: skipping ?-frame\n");
+		  frames_to_skip = 1;
+	  }
+  }
 
 
   if (!img->bad_frame) {
@@ -549,6 +588,11 @@
       stream = xine_list_get_value(this->streams, ite);
       if (stream == XINE_ANON_STREAM) continue;
       pthread_mutex_lock (&stream->first_frame_lock);
+      if (stream->first_frame_flag == 3) {
+      	stream->first_frame_flag = 1;
+	img->is_first = FIRST_FRAME_MAX_POLL;
+      }
+      else
       if (stream->first_frame_flag == 2) {
         if (this->grab_only) {
           stream->first_frame_flag = 0;
@@ -645,6 +689,7 @@
     this->num_frames_skipped   = 0;
   }
   
+  //return frames_to_skip;
   return frames_to_skip;
 }
 
diff -ruN xine-lib-1.1.2/src/xine-engine/xine.c xine-lib-1.1.2-new/src/xine-engine/xine.c
--- xine-lib-1.1.2/src/xine-engine/xine.c	2006-09-01 00:13:00.000000000 +0300
+++ xine-lib-1.1.2-new/src/xine-engine/xine.c	2006-09-01 01:16:45.000000000 +0300
@@ -56,6 +56,7 @@
 #define XINE_ENABLE_EXPERIMENTAL_FEATURES
 #define XINE_ENGINE_INTERNAL
 #define METRONOM_CLOCK_INTERNAL
+#define METRONOM_INTERNAL
 
 #include "xine_internal.h"
 #include "plugin_catalog.h"
@@ -1236,6 +1237,322 @@
   return ret;
 }
 
+static void wait_first_frame_and_set_speed (xine_stream_t *stream, int speed) {
+  printf ("wait_first_frame_and_set_speed<=\n");
+  if (stream->video_decoder_plugin) {
+    pthread_mutex_lock (&stream->first_frame_lock);
+    if (stream->first_frame_flag > 0) {
+      struct timeval  tv;
+      struct timespec ts;
+      gettimeofday(&tv, NULL);
+      ts.tv_sec  = tv.tv_sec + 10;
+      ts.tv_nsec = tv.tv_usec * 1000;
+      pthread_cond_timedwait(&stream->first_frame_reached, &stream->first_frame_lock, &ts);
+    }
+    pthread_mutex_unlock (&stream->first_frame_lock);
+  }
+  // setting speed
+  set_speed_internal(stream, speed);
+  printf ("wait_first_frame_and_set_speed=>\n");
+}
+
+static int seek_internal (xine_stream_t *stream, int start_pos, int start_time) {
+
+	int        demux_status;
+	int        demux_thread_running;
+	int        xine_original_speed;
+
+	xprintf (stream->xine, XINE_VERBOSITY_DEBUG, "xine_seek\n");
+
+	if (!stream->demux_plugin) {
+		xine_log (stream->xine, XINE_LOG_MSG, _("xine_seek: no demux available\n"));
+		stream->err = XINE_ERROR_NO_DEMUX_PLUGIN;
+
+		return 0;
+	}
+
+	xine_original_speed = _x_get_speed(stream);
+  
+	/* hint demuxer thread we want to interrupt it */
+	stream->demux_action_pending = 1;
+
+	/* set normal speed */
+	if (_x_get_speed(stream) != XINE_SPEED_NORMAL)
+		set_speed_internal (stream, XINE_FINE_SPEED_NORMAL);
+  
+	stream->xine->port_ticket->acquire(stream->xine->port_ticket, 1);
+  
+	/* only flush/discard output ports on master streams */
+	if( stream->master == stream && !stream->gapless_switch) {
+		/* discard audio/video buffers to get engine going and take the lock faster */
+		if (stream->audio_out)
+			stream->audio_out->set_property(stream->audio_out, AO_PROP_DISCARD_BUFFERS, 1);
+		if (stream->video_out)
+			stream->video_out->set_property(stream->video_out, VO_PROP_DISCARD_FRAMES, 1);
+	}
+  
+	pthread_mutex_lock( &stream->demux_lock );
+	/* demux_lock taken. now demuxer is suspended */
+	stream->demux_action_pending = 0;
+
+  /* set normal speed again (now that demuxer/input pair is suspended) 
+	* some input plugin may have changed speed by itself, we must ensure
+	* the engine is not paused.
+  */
+	if (_x_get_speed(stream) != XINE_SPEED_NORMAL)
+		set_speed_internal (stream, XINE_FINE_SPEED_NORMAL);
+  
+  /*
+	* start/seek demux
+  */
+
+	/* seek to new position (no data is sent to decoders yet) */
+	demux_status = stream->demux_plugin->seek (stream->demux_plugin,
+			start_pos, start_time, 
+			stream->demux_thread_running);
+
+	/* only flush/discard output ports on master streams */
+	if( stream->master == stream && !stream->gapless_switch) {
+		if (stream->audio_out)
+			stream->audio_out->set_property(stream->audio_out, AO_PROP_DISCARD_BUFFERS, 0);
+		if (stream->video_out)
+			stream->video_out->set_property(stream->video_out, VO_PROP_DISCARD_FRAMES, 0);
+	}
+  
+	stream->xine->port_ticket->release(stream->xine->port_ticket, 1);
+  
+	/* before resuming the demuxer, set first_frame_flag and ask stop after first frame decode */
+	pthread_mutex_lock (&stream->first_frame_lock);
+	stream->first_frame_flag = 3;
+	pthread_mutex_unlock (&stream->first_frame_lock);
+
+	/* before resuming the demuxer, reset current position information */
+	pthread_mutex_lock( &stream->current_extra_info_lock );
+	_x_extra_info_reset( stream->current_extra_info );
+	pthread_mutex_unlock( &stream->current_extra_info_lock );
+
+	demux_thread_running = stream->demux_thread_running;
+  
+	/* now resume demuxer thread if it is running already */
+	pthread_mutex_unlock( &stream->demux_lock );
+
+	if (demux_status != DEMUX_OK) {
+		xine_log (stream->xine, XINE_LOG_MSG, _("xine_seek: demux failed to start\n"));
+
+		stream->err = XINE_ERROR_DEMUX_FAILED;
+		stream->first_frame_flag = 0;
+		return 0;
+
+	} else {
+		if (!demux_thread_running) {
+			_x_demux_start_thread( stream );
+			stream->status = XINE_STATUS_PLAY;
+		}
+	}
+
+	/* wait until the first frame is produced and restore speed to original */
+ 
+        wait_first_frame_and_set_speed (stream, xine_original_speed);
+  
+	xprintf (stream->xine, XINE_VERBOSITY_DEBUG, "seek_internal ...done\n");
+
+	return 1;
+}
+
+int xine_seek (xine_stream_t *stream, int start_pos, int start_time) {
+
+	int ret;
+
+	pthread_mutex_lock (&stream->frontend_lock);
+
+	ret = seek_internal (stream, start_pos, start_time);
+	if( stream->slave && (stream->slave_affection & XINE_MASTER_SLAVE_PLAY) )
+		xine_seek (stream->slave, start_pos, start_time);
+  
+	stream->gapless_switch = 0;
+
+	pthread_mutex_unlock (&stream->frontend_lock);
+  
+	return ret;
+}
+
+static int start_trick_play_internal(xine_stream_t *stream, int trick_speed)
+{
+	xprintf (stream->xine, XINE_VERBOSITY_DEBUG, "start_trick_play_internal\n");
+
+	if (_x_stream_info_get(stream, XINE_STREAM_INFO_TRICK_PLAY_SUPPORTED)==0)
+	{
+//		xprintf (stream->xine, XINE_VERBOSITY_DEBUG, "start_trick_play_internal: stream doesn't support trick play\n");
+//		return 0;
+	}
+	
+	// backward playback is impossible at the moment
+	if (trick_speed<0)
+	{
+		xprintf (stream->xine, XINE_VERBOSITY_DEBUG, "start_trick_play_internal: stream doesn't support reverse trick play\n");
+		return 0;
+	}
+	
+	_x_stream_info_set(stream, XINE_STREAM_INFO_TRICK_PLAY_ORIGINAL_SPEED, _x_get_fine_speed(stream));
+	_x_stream_info_set(stream, XINE_STREAM_INFO_TRICK_PLAY_CURRENT_SPEED, trick_speed);
+	
+	// 0x - 4x => showing all frames
+	// 4x - 8x => skipping B-frames
+	// >8x => skipping P-frames
+	
+	xine_set_param(stream, XINE_PARAM_IGNORE_AUDIO, 1);
+	
+	stream->trick_play_stream_distincts_frame_type = _x_stream_info_get(stream, XINE_STREAM_INFO_TRICK_PLAY_DISTINCTS_FRAME_TYPE);	
+	
+	if (trick_speed<=4*XINE_FINE_SPEED_NORMAL)
+	{
+		stream->trick_play_frame_skip_mode = 0;
+	}
+	else if (trick_speed<=8*XINE_FINE_SPEED_NORMAL)
+	{
+		stream->trick_play_frame_skip_mode = 1;
+	}
+	else
+	{
+		stream->trick_play_frame_skip_mode = 2;
+	}
+	
+	set_speed_internal(stream, trick_speed);
+	
+	_x_stream_info_set(stream, XINE_STREAM_INFO_TRICK_PLAY_ENABLED, 1);
+	
+	xprintf (stream->xine, XINE_VERBOSITY_DEBUG, "start_trick_play_internal: ...done\n");
+	
+	return 1;
+}
+
+int xine_start_trick_play(xine_stream_t *stream, int trick_speed) {
+
+	int ret;
+
+	pthread_mutex_lock (&stream->frontend_lock);
+
+	ret = start_trick_play_internal (stream, trick_speed);
+	if( stream->slave && (stream->slave_affection & XINE_MASTER_SLAVE_PLAY) )
+		xine_start_trick_play (stream->slave, trick_speed);
+  
+	pthread_mutex_unlock (&stream->frontend_lock);
+  
+	return ret;
+}
+
+static int get_current_position(xine_stream_t *stream);
+
+static int stop_trick_play_internal(xine_stream_t *stream)
+{
+	xprintf (stream->xine, XINE_VERBOSITY_DEBUG, "stop_trick_play_internal\n");
+
+	if (_x_stream_info_get(stream, XINE_STREAM_INFO_TRICK_PLAY_SUPPORTED)==0)
+	{
+		xprintf (stream->xine, XINE_VERBOSITY_DEBUG, "stop_trick_play_internal: stream doesn't support trick play\n");
+		return 0;
+	}
+	
+	if (_x_stream_info_get(stream, XINE_STREAM_INFO_TRICK_PLAY_ENABLED)==0)
+	{
+		xprintf (stream->xine, XINE_VERBOSITY_DEBUG, "stop_trick_play_internal: stream is not in trick play mode\n");
+		return 1;
+	}
+	
+	xprintf (stream->xine, XINE_VERBOSITY_DEBUG, "stop_trick_play_internal: attempting to flush video buffer\n");
+
+	if (!stream->demux_plugin) {
+		xine_log (stream->xine, XINE_LOG_MSG, _("stop_trick_play_internal: no demux available\n"));
+	
+		stream->trick_play_frame_skip_mode = 0;
+		
+		set_speed_internal(stream, _x_stream_info_get(stream, XINE_STREAM_INFO_TRICK_PLAY_ORIGINAL_SPEED) );	
+	}
+	else
+	{
+			/* hint demuxer thread we want to interrupt it */
+		stream->demux_action_pending = 1;
+
+		stream->xine->port_ticket->acquire(stream->xine->port_ticket, 1);
+
+		/* discard audio/video buffers to get engine going and take the lock faster */
+		if (stream->video_out)
+			stream->video_out->set_property(stream->video_out, VO_PROP_DISCARD_FRAMES, 1);
+
+		pthread_mutex_lock( &stream->demux_lock );
+		/* demux_lock taken. now demuxer is suspended */
+		stream->demux_action_pending = 0;
+
+		int64_t last_video_pts = stream->metronom->last_video_pts;
+		xprintf (stream->xine, XINE_VERBOSITY_DEBUG, "stop_trick_play_internal: last_video_pts: %" PRId64 "\n", last_video_pts);
+		
+		int64_t video_vpts = stream->metronom->video_vpts;
+		xprintf (stream->xine, XINE_VERBOSITY_DEBUG, "stop_trick_play_internal: video_vpts: %" PRId64 "\n", video_vpts);
+
+		int64_t vpts_offset = stream->metronom->vpts_offset;
+		xprintf (stream->xine, XINE_VERBOSITY_DEBUG, "stop_trick_play_internal: vpts_offset: %" PRId64 "\n", vpts_offset);
+		
+		int64_t vpts = stream->xine->clock->get_current_time(stream->xine->clock); 
+		xprintf (stream->xine, XINE_VERBOSITY_DEBUG, "stop_trick_play_internal: vpts: %" PRId64 "\n", vpts);
+
+		pthread_mutex_lock( &stream->current_extra_info_lock );
+		int64_t spos = stream->current_extra_info->input_time;
+		pthread_mutex_unlock( &stream->current_extra_info_lock );
+		xprintf (stream->xine, XINE_VERBOSITY_DEBUG, "stop_trick_play_internal: spos: %" PRId64 "\n", spos);
+		stream->demux_plugin->seek (stream->demux_plugin, 0, spos, stream->demux_thread_running);
+		/*
+		if ( (spos>=0) && ((vpts - video_vpts)>0) && ((spos - (vpts - video_vpts)/90)>0) && ((spos-(vpts - video_vpts)/90)<(stream->demux_plugin->get_stream_length(stream->demux_plugin))) )
+		{
+			xprintf (stream->xine, XINE_VERBOSITY_DEBUG, "stop_trick_play_internal: jumping back: %" PRId64 "ms\n", (vpts - video_vpts)/90);
+			stream->demux_plugin->seek (stream->demux_plugin,
+			0, (spos-(vpts - video_vpts)/90), 
+			stream->demux_thread_running);
+		}
+		*/
+		stream->trick_play_frame_skip_mode = 0;
+
+		stream->xine->port_ticket->release(stream->xine->port_ticket, 1);
+		
+		set_speed_internal(stream, _x_stream_info_get(stream, XINE_STREAM_INFO_TRICK_PLAY_ORIGINAL_SPEED) );	
+
+		stream->xine->port_ticket->acquire(stream->xine->port_ticket, 1);
+
+		if (stream->video_out)
+			stream->video_out->set_property(stream->video_out, VO_PROP_DISCARD_FRAMES, 0);
+
+		stream->xine->port_ticket->release(stream->xine->port_ticket, 1);
+
+		pthread_mutex_unlock( &stream->demux_lock );
+
+		xprintf (stream->xine, XINE_VERBOSITY_DEBUG, "stop_trick_play_internal: flushed video buffer\n");
+	}
+
+	_x_stream_info_set(stream, XINE_STREAM_INFO_TRICK_PLAY_ENABLED, 0);
+		
+	xine_set_param(stream, XINE_PARAM_IGNORE_AUDIO, 0);
+	
+	_x_stream_info_set(stream, XINE_STREAM_INFO_TRICK_PLAY_ORIGINAL_SPEED, 0);
+	_x_stream_info_set(stream, XINE_STREAM_INFO_TRICK_PLAY_CURRENT_SPEED, 0);
+	
+	xprintf (stream->xine, XINE_VERBOSITY_DEBUG, "stop_trick_play_internal: ...done\n");
+	
+	return 1;
+}
+
+int xine_stop_trick_play(xine_stream_t *stream) {
+	int ret;
+
+	pthread_mutex_lock (&stream->frontend_lock);
+
+	ret = stop_trick_play_internal (stream);
+	if( stream->slave && (stream->slave_affection & XINE_MASTER_SLAVE_PLAY) )
+		xine_stop_trick_play (stream->slave);
+  
+	pthread_mutex_unlock (&stream->frontend_lock);
+  
+	return ret;
+}
+
 int xine_eject (xine_stream_t *stream) {
   
   int status;
diff -ruN xine-lib-1.1.2/src/xine-engine/xine_internal.h xine-lib-1.1.2-new/src/xine-engine/xine_internal.h
--- xine-lib-1.1.2/src/xine-engine/xine_internal.h	2006-09-01 00:13:00.000000000 +0300
+++ xine-lib-1.1.2-new/src/xine-engine/xine_internal.h	2006-09-01 01:05:33.000000000 +0300
@@ -342,7 +342,13 @@
                                                * layers as they cannot call xine_stop. */
   int                        early_finish_event; /* do not wait fifos get empty before sending event */
   int                        gapless_switch;     /* next stream switch will be gapless */
   int                        delay_finish_event; /* delay event in 1/10 sec units. 0=>no delay, -1=>forever */
+  
+  int                        trick_play_frame_skip_mode; /* what frames to skip: 0 - no frames skipped 
+  					* by trick play, 1 - B-frames are skipped, 2 - B&P-frames are skipped, 
+					 * 3 - B&P&I-frames are skipped (impossible) */
+  int                        trick_play_stream_distincts_frame_type; /* 0 - doesn't distinct between I/P/B-frames (ffmpeg decoder), 
+							    * 1 - distincts between I/P/B-frames (see xvmc.h header ) */
 #endif
 };
 
