Index: xine-lib/configure.ac
===================================================================
RCS file: /cvsroot/xine/xine-lib/configure.ac,v
retrieving revision 1.319
diff -u -r1.319 configure.ac
--- xine-lib/configure.ac	3 May 2005 21:27:30 -0000	1.319
+++ xine-lib/configure.ac	8 May 2005 19:31:48 -0000
@@ -2311,6 +2311,7 @@
 src/video_out/vidix/drivers/Makefile
 src/xine-utils/Makefile
 src/xine-engine/Makefile
+src/vdr/Makefile
 win32/Makefile
 win32/contrib/Makefile
 win32/contrib/pthreads/Makefile
@@ -2369,7 +2370,7 @@
 echo "   - stdin_fifo    - rtp"
 echo "   - http          - mms"
 echo "   - pnm           - rtsp"
-echo "   - dvb"
+echo "   - dvb           - vdr"
 if test x"$external_dvdnav" = "xyes"; then
   echo "   - dvd (external libs)"
 else
@@ -2520,6 +2521,7 @@
 echo "   - eq              - eq2"
 echo "   - boxblur         - denoise3d"
 echo "   - unsharp         - tvtime"
+echo "   - vdr"
 echo "  * SFX:"
 echo "   - goom            - oscope"
 echo "   - fftscope        - mosaico"
Index: xine-lib/include/xine.h.in
===================================================================
RCS file: /cvsroot/xine/xine-lib/include/xine.h.in,v
retrieving revision 1.140
diff -u -r1.140 xine.h.in
--- xine-lib/include/xine.h.in	21 Apr 2005 21:50:42 -0000	1.140
+++ xine-lib/include/xine.h.in	8 May 2005 19:31:55 -0000
@@ -895,6 +895,26 @@
 #define XINE_STREAM_INFO_AUDIO_MODE        26
 #define XINE_STREAM_INFO_SKIPPED_FRAMES    27 /* for 1000 frames delivered */
 #define XINE_STREAM_INFO_DISCARDED_FRAMES  28 /* for 1000 frames delivered */
+#define XINE_STREAM_INFO_VIDEO_AFD         29
+
+/* possible values for XINE_STREAM_INFO_VIDEO_AFD */
+#define XINE_VIDEO_AFD_NOT_PRESENT         -1
+#define XINE_VIDEO_AFD_RESERVED_0          0
+#define XINE_VIDEO_AFD_RESERVED_1          1
+#define XINE_VIDEO_AFD_BOX_16_9_TOP        2
+#define XINE_VIDEO_AFD_BOX_14_9_TOP        3
+#define XINE_VIDEO_AFD_BOX_GT_16_9_CENTRE  4
+#define XINE_VIDEO_AFD_RESERVED_5          5
+#define XINE_VIDEO_AFD_RESERVED_6          6
+#define XINE_VIDEO_AFD_RESERVED_7          7
+#define XINE_VIDEO_AFD_SAME_AS_FRAME       8
+#define XINE_VIDEO_AFD_4_3_CENTRE          9
+#define XINE_VIDEO_AFD_16_9_CENTRE         10
+#define XINE_VIDEO_AFD_14_9_CENTRE         11
+#define XINE_VIDEO_AFD_RESERVED_12         12
+#define XINE_VIDEO_AFD_4_3_PROTECT_14_9    13
+#define XINE_VIDEO_AFD_16_9_PROTECT_14_9   14
+#define XINE_VIDEO_AFD_16_9_PROTECT_4_3    15
 
 /* xine_get_meta_info */
 #define XINE_META_INFO_TITLE               0
Index: xine-lib/src/Makefile.am
===================================================================
RCS file: /cvsroot/xine/xine-lib/src/Makefile.am,v
retrieving revision 1.54
diff -u -r1.54 Makefile.am
--- xine-lib/src/Makefile.am	14 Jan 2005 15:24:08 -0000	1.54
+++ xine-lib/src/Makefile.am	8 May 2005 19:31:55 -0000
@@ -30,4 +30,5 @@
 	libfaad \
 	libflac \
         libmusepack \
-	post
+	post \
+	vdr
Index: xine-lib/src/demuxers/demux_mpeg_pes.c
===================================================================
RCS file: /cvsroot/xine/xine-lib/src/demuxers/demux_mpeg_pes.c,v
retrieving revision 1.30
diff -u -r1.30 demux_mpeg_pes.c
--- xine-lib/src/demuxers/demux_mpeg_pes.c	6 Feb 2005 15:26:17 -0000	1.30
+++ xine-lib/src/demuxers/demux_mpeg_pes.c	8 May 2005 19:31:56 -0000
@@ -51,7 +51,7 @@
 #define NUM_PREVIEW_BUFFERS   250
 #define DISC_TRESHOLD       90000
 
-#define WRAP_THRESHOLD     120000 
+#define WRAP_THRESHOLD     270000 
 #define PTS_AUDIO 0
 #define PTS_VIDEO 1
 
@@ -157,7 +157,42 @@
   }
   
   if( pts )
+  {
+    /* don't detect a discontinuity only for video respectively audio. It's also a discontinuity
+       indication when audio and video pts differ to much e. g. when a pts wrap happens.
+       The original code worked well when the wrap happend like this:
+
+       V7 A7 V8 V9 A9 Dv V0 V1 da A1 V2 V3 A3 V4
+       
+       Legend:
+       Vn = video packet with timestamp n
+       An = audio packet with timestamp n
+       Dv = discontinuity detected on following video packet
+       Da = discontinuity detected on following audio packet
+       dv = discontinuity detected on following video packet but ignored
+       da = discontinuity detected on following audio packet but ignored
+
+       But with a certain delay between audio and video packets (e. g. the way DVB-S broadcasts
+       the packets) the code didn't work:
+
+       V7 V8 A7 V9 Dv V0 _A9_ V1 V2 Da _A1_ V3 V4 A3
+
+       Packet A9 caused audio to jump forward and A1 caused it to jump backward with inserting
+       a delay of almoust 26.5 hours!
+
+       The new code gives the following sequences for the above examples:
+       
+       V7 A7 V8 V9 A9 Dv V0 V1 A1 V2 V3 A3 V4
+
+       V7 V8 A7 V9 Dv V0 Da A9 Dv V1 V2 A1 V3 V4 A3
+
+       After proving this code it should be cleaned up to use just a single variable "last_pts". */
+    
+/*
     this->last_pts[video] = pts;
+*/    
+    this->last_pts[video] = this->last_pts[1-video] = pts;
+  }
 }
 
 static void demux_mpeg_pes_parse_pack (demux_mpeg_pes_t *this, int preview_mode) {
Index: xine-lib/src/libmpeg2/decode.c
===================================================================
RCS file: /cvsroot/xine/xine-lib/src/libmpeg2/decode.c,v
retrieving revision 1.127
diff -u -r1.127 decode.c
--- xine-lib/src/libmpeg2/decode.c	6 May 2005 07:42:20 -0000	1.127
+++ xine-lib/src/libmpeg2/decode.c	8 May 2005 19:31:58 -0000
@@ -180,7 +180,7 @@
    *       once and cached!
    */
 
-  if( !picture->mpeg1 ) {
+  if( !picture->delayed_mpeg1 ) {
     /* these hardcoded values are defined on mpeg2 standard for
      * aspect ratio. other values are reserved or forbidden.  */
     switch(picture->aspect_ratio_information) {
@@ -256,6 +256,7 @@
     picture_t * picture;
     int is_frame_done;
     double ratio;
+    int delayed_mpeg1;
     
     /* wait for sequence_header_code */
     if (mpeg2dec->is_sequence_needed) {
@@ -403,6 +404,8 @@
         break;
 
     case 0xb3:	/* sequence_header_code */
+	delayed_mpeg1 = picture->mpeg1;
+
 	if (mpeg2_header_sequence (picture, buffer)) {
 	    fprintf (stderr, "bad sequence header\n");
 	    /* abort(); */
@@ -416,7 +419,8 @@
 
 	if (mpeg2dec->is_sequence_needed 
 	    || (picture->frame_width != picture->coded_picture_width)
-	    || (picture->frame_height != picture->coded_picture_height)) {
+	    || (picture->frame_height != picture->coded_picture_height)
+	    || (picture->delayed_mpeg1 != delayed_mpeg1)) {
 	    xine_event_t event;
 	    xine_format_change_data_t data;
 	    
@@ -451,6 +455,7 @@
 
 	    picture->frame_width = picture->coded_picture_width;
 	    picture->frame_height = picture->coded_picture_height;
+	    picture->delayed_mpeg1 = delayed_mpeg1;
 	}
 	break;
 
@@ -593,6 +598,18 @@
     uint8_t * limit;
     uint8_t byte;
 
+    /* sequence end code 0xb7 doesn't have any data and there might be the case
+     * that no start code will follow this code for quite some time (e. g. in case
+     * of a still image.
+     * Therefore, return immediately with a chunk_size of 0. Setting code to 0xb4
+     * will eat up any trailing garbage next time.
+     */
+    if (mpeg2dec->code == 0xb7) {
+       mpeg2dec->code = 0xb4;
+       mpeg2dec->chunk_size = 0;
+       return current;
+    }
+
     shift = mpeg2dec->shift;
     chunk_ptr = mpeg2dec->chunk_ptr;
     limit = current + (mpeg2dec->chunk_buffer + BUFFER_SIZE - chunk_ptr);
@@ -644,7 +661,7 @@
     if (pts)
       mpeg2dec->pts = pts;
 
-    while (current != end) {
+    while (current != end || mpeg2dec->code == 0xb7) {
 	code = mpeg2dec->code;
 	current = copy_chunk (mpeg2dec, current, end);
 	if (current == NULL) 
@@ -927,4 +944,12 @@
       mpeg2dec->cc_dec->decode_data(mpeg2dec->cc_dec, &buf);
     }
   }
+  /* check Active Format Description ETSI TS 101 154 V1.5.1 */
+  else if (buffer[0] == 0x44 && buffer[1] == 0x54 && buffer[2] == 0x47 && buffer[3] == 0x31)
+  {
+    int afd = (buffer[4] & 0x40) ? (buffer[5] & 0x0f) : -1;
+    _x_stream_info_set(mpeg2dec->stream, XINE_STREAM_INFO_VIDEO_AFD, afd);
+    
+fprintf(stderr, "AFD present: %d\n", afd);
+  }
 }
Index: xine-lib/src/libmpeg2/mpeg2_internal.h
===================================================================
RCS file: /cvsroot/xine/xine-lib/src/libmpeg2/mpeg2_internal.h,v
retrieving revision 1.23
diff -u -r1.23 mpeg2_internal.h
--- xine-lib/src/libmpeg2/mpeg2_internal.h	9 Apr 2005 11:22:16 -0000	1.23
+++ xine-lib/src/libmpeg2/mpeg2_internal.h	8 May 2005 19:31:59 -0000
@@ -161,7 +161,7 @@
 
     int second_field;
 
-    int mpeg1;
+    int mpeg1, delayed_mpeg1;
 
     int skip_non_intra_dct;
 
Index: xine-lib/src/post/deinterlace/xine_plugin.c
===================================================================
RCS file: /cvsroot/xine/xine-lib/src/post/deinterlace/xine_plugin.c,v
retrieving revision 1.37
diff -u -r1.37 xine_plugin.c
--- xine-lib/src/post/deinterlace/xine_plugin.c	29 Sep 2004 18:30:37 -0000	1.37
+++ xine-lib/src/post/deinterlace/xine_plugin.c	8 May 2005 19:32:00 -0000
@@ -563,6 +563,11 @@
     frame->flags | VO_BOTH_FIELDS);
   pthread_mutex_lock (&this->lock);
     
+  deinterlaced_frame->crop_left   = frame->crop_left;
+  deinterlaced_frame->crop_right  = frame->crop_right;
+  deinterlaced_frame->crop_top    = frame->crop_top;
+  deinterlaced_frame->crop_bottom = frame->crop_bottom;
+     
   _x_extra_info_merge(deinterlaced_frame->extra_info, frame->extra_info);
     
   if( skip > 0 && !this->pulldown ) {
Index: xine-lib/src/post/planar/expand.c
===================================================================
RCS file: /cvsroot/xine/xine-lib/src/post/planar/expand.c,v
retrieving revision 1.13
diff -u -r1.13 expand.c
--- xine-lib/src/post/planar/expand.c	17 Apr 2004 19:54:32 -0000	1.13
+++ xine-lib/src/post/planar/expand.c	8 May 2005 19:32:00 -0000
@@ -21,7 +21,8 @@
  *
  * expand video filter by James Stembridge 24/05/2003
  *            improved by Michael Roitzsch
- * 
+ *            centre_crop_out_mode by Reinhard Nissl
+ *
  * based on invert.c
  *
  */
@@ -52,6 +53,11 @@
  * This way, the decoder (or any other post plugin up the tree) will only
  * see the frame area between the black bars and by that modify the
  * enlarged version directly. No need for later copying.
+ *
+ * When centre_crop_out_mode is enabled, the plugin will detect the black
+ * bars to the left and right of the image and will then set up cropping
+ * to efficiently remove the black border around the 4:3 image, which the
+ * plugin would produce otherwise for this case.
  */ 
 
 
@@ -62,6 +68,7 @@
 typedef struct expand_parameters_s {
   int enable_automatic_shift;
   int overlay_y_offset;
+  int centre_cut_out_mode;
 } expand_parameters_t;
 
 START_PARAM_DESCR(expand_parameters_t)
@@ -69,6 +76,8 @@
   "enable automatic overlay shifting")
 PARAM_ITEM(POST_PARAM_TYPE_INT, overlay_y_offset, NULL, -500, 500, 0,
   "manually shift the overlay vertically")
+PARAM_ITEM(POST_PARAM_TYPE_BOOL, centre_cut_out_mode, NULL, 0, 1, 0,
+  "cut out centered 4:3 image contained in 16:9 frame")
 END_PARAM_DESCR(expand_param_descr)
 
 typedef struct post_expand_s {
@@ -79,6 +88,8 @@
   int                      enable_automatic_shift;
   int                      overlay_y_offset;
   int                      top_bar_height;
+  int                      centre_cut_out_mode;
+  int                      cropping_active;
 } post_expand_t;
 
 /* plugin class functions */
@@ -103,6 +114,9 @@
 				       uint32_t height, double ratio, 
 				       int format, int flags);
 
+/* replaced vo_frame functions */
+static int            expand_draw(vo_frame_t *frame, xine_stream_t *stream);
+
 /* overlay manager intercept check */
 static int            expand_intercept_ovl(post_video_port_t *port);
 
@@ -147,11 +161,14 @@
   
   this->enable_automatic_shift = 0;
   this->overlay_y_offset       = 0;
+  this->centre_cut_out_mode    = 0;
+  this->cropping_active        = 0;
   
   port = _x_post_intercept_video_port(&this->post, video_target[0], &input, &output);
   port->new_port.get_frame     = expand_get_frame;
   port->intercept_ovl          = expand_intercept_ovl;
   port->new_manager->add_event = expand_overlay_add_event;
+  port->new_frame->draw        = expand_draw;
   
   input_param       = &this->parameter_input;
   input_param->name = "parameters";
@@ -159,8 +176,8 @@
   input_param->data = &post_api;
   xine_list_append_content(this->post.input, input_param);
   
-  input->xine_in.name     = "video";
-  output->xine_out.name   = "expanded video";
+  input->xine_in.name   = "video";
+  output->xine_out.name = "expanded video";
   
   this->post.xine_post.video_input[0] = &port->new_port;
   
@@ -206,6 +223,8 @@
   
   this->enable_automatic_shift = param->enable_automatic_shift;
   this->overlay_y_offset       = param->overlay_y_offset;
+  this->centre_cut_out_mode    = param->centre_cut_out_mode;
+  
   return 1;
 }
 
@@ -216,6 +235,8 @@
   
   param->enable_automatic_shift = this->enable_automatic_shift;
   param->overlay_y_offset       = this->overlay_y_offset;
+  param->centre_cut_out_mode    = this->centre_cut_out_mode;
+  
   return 1;
 }
 
@@ -228,6 +249,7 @@
            "Parameters (FIXME: better help)\n"
            "  Enable_automatic_shift: Enable automatic overlay shifting\n"
            "  Overlay_y_offset: Manually shift the overlay vertically\n"
+           "  Centre_cut_out_mode: extracts 4:3 image contained in 16:9 frame\n"
            "\n"
          );
 }
@@ -314,6 +336,10 @@
 
 static int expand_intercept_ovl(post_video_port_t *port)
 {
+  post_expand_t         *this = (post_expand_t *)port->post;
+
+  if (this->centre_cut_out_mode && this->cropping_active) return 0;
+  
   /* we always intercept overlay manager */
   return 1;
 }
@@ -342,3 +368,79 @@
   
   return port->original_manager->add_event(port->original_manager, event_gen);
 }
+
+
+static int is_pixel_black(vo_frame_t *frame, int x, int y)
+{
+  int Y = 0x00, Cr = 0x00, Cb = 0x00;
+
+  if (x < 0)              x = 0;
+  if (x >= frame->width)  x = frame->width - 1;
+  if (y < 0)              y = 0;
+  if (y >= frame->height) y = frame->height - 1;
+  
+  switch (frame->format)
+  {
+  case XINE_IMGFMT_YV12:
+    Y  = *(frame->base[ 0 ] + frame->pitches[ 0 ] * y     + x);
+    Cr = *(frame->base[ 1 ] + frame->pitches[ 1 ] * y / 2 + x / 2);
+    Cb = *(frame->base[ 2 ] + frame->pitches[ 2 ] * y / 2 + x / 2);
+    break;
+    
+  case XINE_IMGFMT_YUY2:
+    Y  = *(frame->base[ 0 ] + frame->pitches[ 0 ] * y + x * 2 + 0);
+    x &= ~1;
+    Cr = *(frame->base[ 0 ] + frame->pitches[ 0 ] * y + x * 2 + 1);
+    Cb = *(frame->base[ 0 ] + frame->pitches[ 0 ] * y + x * 2 + 3);
+    break;
+  }
+
+  return (Y == 0x10 && Cr == 0x80 && Cb == 0x80);
+}
+
+
+static int expand_draw(vo_frame_t *frame, xine_stream_t *stream)
+{
+  post_video_port_t *port = (post_video_port_t *)frame->port;
+  post_expand_t     *this = (post_expand_t *)port->post;
+  int                skip;
+
+  if (this->centre_cut_out_mode && !frame->bad_frame)
+  {
+    /* expected area of inner 4:3 image */
+    int centre_width = frame->width * (9 * 4) / (16 * 3);
+    int centre_left  = (frame->width - centre_width ) / 2;
+
+    /* centre point for detecting a black frame */
+    int centre_x = frame->width  / 2;
+    int centre_y = frame->height / 2;
+
+    /* ignore a black frame as it could lead to wrong results */
+    if (!is_pixel_black(frame, centre_x, centre_y))
+    {
+      /* coordinates for testing black border near the centre area */
+      int test_left  = centre_left - 16;
+      int test_right = centre_left + 16 + centre_width;
+
+      /* enable cropping when these pixels are black */
+      this->cropping_active = is_pixel_black(frame, test_left, centre_y)
+        && is_pixel_black(frame, test_right, centre_y);
+    }
+
+    /* crop frame */
+    if (this->centre_cut_out_mode && this->cropping_active) {
+      frame->crop_left  += centre_left;
+      frame->crop_right += centre_left;
+
+      /* get_frame() allocated an extra high frame */
+      frame->crop_top    += (frame->next->height - frame->height) / 2;
+      frame->crop_bottom += (frame->next->height - frame->height) / 2;
+    }
+  }
+
+  _x_post_frame_copy_down(frame, frame->next);
+  skip = frame->next->draw(frame->next, stream);
+  _x_post_frame_copy_up(frame, frame->next);
+
+  return skip;
+}
Index: xine-lib/src/xine-engine/post.c
===================================================================
RCS file: /cvsroot/xine/xine-lib/src/xine-engine/post.c,v
retrieving revision 1.29
diff -u -r1.29 post.c
--- xine-lib/src/xine-engine/post.c	7 May 2005 09:11:39 -0000	1.29
+++ xine-lib/src/xine-engine/post.c	8 May 2005 19:32:03 -0000
@@ -420,6 +420,10 @@
   to->drawn               = from->drawn;
   to->accel_data          = from->accel_data;
   to->stream              = from->stream;
+  to->crop_left           = from->crop_left;
+  to->crop_right          = from->crop_right;
+  to->crop_top            = from->crop_top;
+  to->crop_bottom         = from->crop_bottom;
   
   if (to->extra_info != from->extra_info)
     _x_extra_info_merge(to->extra_info, from->extra_info);
Index: xine-lib/src/xine-engine/video_out.c
===================================================================
RCS file: /cvsroot/xine/xine-lib/src/xine-engine/video_out.c,v
retrieving revision 1.218
diff -u -r1.218 video_out.c
--- xine-lib/src/xine-engine/video_out.c	14 Feb 2005 14:04:55 -0000	1.218
+++ xine-lib/src/xine-engine/video_out.c	8 May 2005 19:32:04 -0000
@@ -500,6 +500,7 @@
     vo_append_to_img_buf_queue (this->display_img_buf_queue, img);
     
   } else {
+    fprintf (stderr, "bad_frame\n");
     lprintf ("bad_frame\n");
 
     if (stream) {
Index: xine-lib/src/xine-engine/video_overlay.h
===================================================================
RCS file: /cvsroot/xine/xine-lib/src/xine-engine/video_overlay.h,v
retrieving revision 1.19
diff -u -r1.19 video_overlay.h
--- xine-lib/src/xine-engine/video_overlay.h	8 Dec 2004 18:18:24 -0000	1.19
+++ xine-lib/src/xine-engine/video_overlay.h	8 May 2005 19:32:04 -0000
@@ -38,7 +38,7 @@
 
 #define MAX_OBJECTS   50
 #define MAX_EVENTS    50
-#define MAX_SHOWING   16
+#define MAX_SHOWING   (5 + 16)
 
 #define OVERLAY_EVENT_NULL             0
 #define OVERLAY_EVENT_SHOW             1
Index: xine-lib/src/xine-engine/xine.c
===================================================================
RCS file: /cvsroot/xine/xine-lib/src/xine-engine/xine.c,v
retrieving revision 1.312
diff -u -r1.312 xine.c
--- xine-lib/src/xine-engine/xine.c	6 Mar 2005 11:08:40 -0000	1.312
+++ xine-lib/src/xine-engine/xine.c	8 May 2005 19:32:06 -0000
@@ -35,6 +35,7 @@
 #include <string.h>
 #include <stdlib.h>
 #include <pthread.h>
+#include <errno.h>
 #include <stdarg.h>
 #if defined (__linux__)
 #include <endian.h>
@@ -298,7 +299,7 @@
 
 void xine_stop (xine_stream_t *stream) {
 
-  pthread_mutex_lock (&stream->frontend_lock);
+  _x_rmutex_lock (&stream->frontend_lock);
 
   stream->ignore_speed_change = 1;
   stream->xine->port_ticket->acquire(stream->xine->port_ticket, 1);
@@ -321,7 +322,7 @@
   stream->xine->port_ticket->release(stream->xine->port_ticket, 1);
   stream->ignore_speed_change = 0;
   
-  pthread_mutex_unlock (&stream->frontend_lock);
+  _x_rmutex_unlock (&stream->frontend_lock);
 }
 
 
@@ -387,7 +388,7 @@
 
 void xine_close (xine_stream_t *stream) {
 
-  pthread_mutex_lock (&stream->frontend_lock);
+  _x_rmutex_lock (&stream->frontend_lock);
 
   close_internal (stream);
 
@@ -401,7 +402,7 @@
   if (stream->status != XINE_STATUS_QUIT)
     stream->status = XINE_STATUS_IDLE;
 
-  pthread_mutex_unlock (&stream->frontend_lock);
+  _x_rmutex_unlock (&stream->frontend_lock);
 }
 
 static int stream_rewire_audio(xine_post_out_t *output, void *data)
@@ -523,7 +524,7 @@
   pthread_mutex_init (&stream->info_mutex, NULL);
   pthread_mutex_init (&stream->meta_mutex, NULL);
   pthread_mutex_init (&stream->demux_lock, NULL);
-  pthread_mutex_init (&stream->frontend_lock, NULL);
+  _x_rmutex_init (&stream->frontend_lock);
   pthread_mutex_init (&stream->event_queues_lock, NULL);
   pthread_mutex_init (&stream->counter_lock, NULL);
   pthread_cond_init  (&stream->counter_changed, NULL);
@@ -1068,13 +1069,13 @@
 
   int ret;
 
-  pthread_mutex_lock (&stream->frontend_lock);
+  _x_rmutex_lock (&stream->frontend_lock);
 
   lprintf ("open MRL:%s\n", mrl);
 
   ret = open_internal (stream, mrl);
 
-  pthread_mutex_unlock (&stream->frontend_lock);
+  _x_rmutex_unlock (&stream->frontend_lock);
 
   return ret;
 }
@@ -1200,13 +1201,13 @@
 
   int ret;
 
-  pthread_mutex_lock (&stream->frontend_lock);
+  _x_rmutex_lock (&stream->frontend_lock);
 
   ret = play_internal (stream, start_pos, start_time);
   if( stream->slave && (stream->slave_affection & XINE_MASTER_SLAVE_PLAY) )
     xine_play (stream->slave, start_pos, start_time);
 
-  pthread_mutex_unlock (&stream->frontend_lock);
+  _x_rmutex_unlock (&stream->frontend_lock);
   
   return ret;
 }
@@ -1218,7 +1219,7 @@
   if (!stream->eject_class) 
     return 0;
   
-  pthread_mutex_lock (&stream->frontend_lock);
+  _x_rmutex_lock (&stream->frontend_lock);
 
   status = 0;
   /* only eject, if we are stopped OR a different input plugin is playing */
@@ -1229,7 +1230,7 @@
     status = stream->eject_class->eject_media (stream->eject_class);
   }
 
-  pthread_mutex_unlock (&stream->frontend_lock);
+  _x_rmutex_unlock (&stream->frontend_lock);
   return status;
 }
 
@@ -1240,7 +1241,7 @@
   lprintf("stream: %p\n", stream);
   pthread_mutex_destroy (&stream->info_mutex);
   pthread_mutex_destroy (&stream->meta_mutex);
-  pthread_mutex_destroy (&stream->frontend_lock);
+  _x_rmutex_destroy (&stream->frontend_lock);
   pthread_mutex_destroy (&stream->counter_lock);
   pthread_mutex_destroy (&stream->event_queues_lock);
   pthread_mutex_destroy (&stream->current_extra_info_lock);
@@ -1547,7 +1548,7 @@
 
 void _x_select_spu_channel (xine_stream_t *stream, int channel) {
 
-  pthread_mutex_lock (&stream->frontend_lock);
+  _x_rmutex_lock (&stream->frontend_lock);
   stream->spu_channel_user = (channel >= -2 ? channel : -2);
 
   stream->xine->port_ticket->acquire(stream->xine->port_ticket, 0);
@@ -1572,18 +1573,18 @@
 
   stream->xine->port_ticket->release(stream->xine->port_ticket, 0);
   
-  pthread_mutex_unlock (&stream->frontend_lock);
+  _x_rmutex_unlock (&stream->frontend_lock);
 }
 
 static int get_current_position (xine_stream_t *stream) {
 
   int pos;
 
-  pthread_mutex_lock (&stream->frontend_lock);
+  _x_rmutex_lock (&stream->frontend_lock);
 
   if (!stream->input_plugin) {
     lprintf ("no input source\n");
-    pthread_mutex_unlock (&stream->frontend_lock);
+    _x_rmutex_unlock (&stream->frontend_lock);
     return -1;
   }
 
@@ -1595,7 +1596,7 @@
   }
 
   if ( stream->current_extra_info->seek_count != stream->video_seek_count ) {
-    pthread_mutex_unlock (&stream->frontend_lock);
+    _x_rmutex_unlock (&stream->frontend_lock);
     return -1; /* position not yet known */
   }
 
@@ -1603,7 +1604,7 @@
   pos = stream->current_extra_info->input_normpos;
   pthread_mutex_unlock( &stream->current_extra_info_lock );
 
-  pthread_mutex_unlock (&stream->frontend_lock);
+  _x_rmutex_unlock (&stream->frontend_lock);
 
   return pos;
 }
@@ -1922,3 +1923,155 @@
   slave->master = master->master;
   return 1;
 }
+
+int _x_continue_stream_processing(xine_stream_t *stream)
+{
+  return stream->status != XINE_STATUS_STOP
+    && stream->status != XINE_STATUS_QUIT;
+}
+
+void _x_trigger_relaxed_frame_drop_mode(xine_stream_t *stream)
+{
+  stream->first_frame_flag = 2;
+}
+
+void _x_reset_relaxed_frame_drop_mode(xine_stream_t *stream)
+{
+  stream->first_frame_flag = 1;
+}
+
+void _x_query_buffer_usage(xine_stream_t *stream, int *num_video_buffers, int *num_audio_buffers, int *num_video_frames, int *num_audio_frames)
+{
+  stream->xine->port_ticket->acquire(stream->xine->port_ticket, 0);
+
+  if (num_video_buffers)
+    *num_video_buffers = (stream->video_fifo ? stream->video_fifo->size(stream->video_fifo) : 0);
+    
+  if (num_audio_buffers)
+    *num_audio_buffers = (stream->audio_fifo ? stream->audio_fifo->size(stream->audio_fifo) : 0);
+    
+  if (num_video_frames)
+    *num_video_frames = (stream->video_out ? stream->video_out->get_property(stream->video_out, VO_PROP_BUFS_IN_FIFO) : 0);
+
+  if (num_audio_frames)
+    *num_audio_frames = (stream->audio_out ? stream->audio_out->get_property(stream->audio_out, AO_PROP_BUFS_IN_FIFO) : 0);
+
+  stream->xine->port_ticket->release(stream->xine->port_ticket, 0);
+}
+
+int _x_query_unprocessed_osd_events(xine_stream_t *stream)
+{
+  video_overlay_manager_t *ovl;
+  int redraw_needed;
+  
+  stream->xine->port_ticket->acquire(stream->xine->port_ticket, 0);
+
+  ovl = stream->video_out->get_overlay_manager(stream->video_out);
+  redraw_needed = ovl->redraw_needed(ovl, 0);
+  
+  stream->xine->port_ticket->release(stream->xine->port_ticket, 0);
+
+  return redraw_needed;
+}
+
+int _x_demux_seek(xine_stream_t *stream, off_t start_pos, int start_time, int playing)
+{
+  return stream->demux_plugin->seek(stream->demux_plugin, start_pos, start_time, playing);
+}
+
+int _x_lock_frontend(xine_stream_t *stream, int ms_to_time_out)
+{
+  return (0 == _x_rmutex_timedlock(&stream->frontend_lock, ms_to_time_out));
+}
+
+void _x_unlock_frontend(xine_stream_t *stream)
+{
+  _x_rmutex_unlock(&stream->frontend_lock);
+}
+
+int _x_rmutex_init(xine_rmutex_t *rmutex)
+{
+  pthread_mutex_init(&rmutex->access_rmutex, 0);
+  pthread_cond_init(&rmutex->unlock_cond, 0);
+  rmutex->lock_count = 0;
+
+  return 0;
+}
+
+int _x_rmutex_lock(xine_rmutex_t *rmutex)
+{
+  return _x_rmutex_timedlock(rmutex, -1);
+}
+
+#include "assert.h"
+
+int _x_rmutex_timedlock(xine_rmutex_t *rmutex, int ms_to_time_out)
+{
+  int r = 0;
+
+  struct timespec abstime;
+  {
+    struct timeval now;
+    gettimeofday(&now, 0);
+    
+    abstime.tv_sec = now.tv_sec + ms_to_time_out / 1000;
+    abstime.tv_nsec = now.tv_usec * 1000 + (ms_to_time_out % 1000) * 1e6;
+    
+    if (abstime.tv_nsec > 1e9)
+    {
+      abstime.tv_nsec -= 1e9;
+      abstime.tv_sec++;
+    }
+  }
+  
+  pthread_mutex_lock(&rmutex->access_rmutex);
+
+  assert(rmutex->lock_count >= 0);
+  
+  while (0 == r
+         && rmutex->lock_count > 0
+         && !pthread_equal(rmutex->lock_owner, pthread_self()))
+  {
+    if (ms_to_time_out < 0)
+      pthread_cond_wait(&rmutex->unlock_cond, &rmutex->access_rmutex);
+    else
+      r = pthread_cond_timedwait(&rmutex->unlock_cond, &rmutex->access_rmutex, &abstime);
+  }
+
+  if (0 == r)
+  {
+    rmutex->lock_owner = pthread_self();
+    rmutex->lock_count++;
+  }
+
+  pthread_mutex_unlock(&rmutex->access_rmutex);
+
+  return r;
+}
+
+int _x_rmutex_unlock(xine_rmutex_t *rmutex)
+{
+  int r = 0;
+  
+  pthread_mutex_lock(&rmutex->access_rmutex);
+
+  assert(rmutex->lock_count > 0);
+  assert(pthread_equal(rmutex->lock_owner, pthread_self()));
+  
+  rmutex->lock_count--;
+
+  if (rmutex->lock_count == 0)
+    pthread_cond_broadcast(&rmutex->unlock_cond);
+  
+  pthread_mutex_unlock(&rmutex->access_rmutex);
+
+  return r;
+}
+
+int _x_rmutex_destroy(xine_rmutex_t *rmutex)
+{
+  pthread_cond_destroy(&rmutex->unlock_cond);
+  pthread_mutex_destroy(&rmutex->access_rmutex);
+
+  return 0;
+}
Index: xine-lib/src/xine-engine/xine_interface.c
===================================================================
RCS file: /cvsroot/xine/xine-lib/src/xine-engine/xine_interface.c,v
retrieving revision 1.88
diff -u -r1.88 xine_interface.c
--- xine-lib/src/xine-engine/xine_interface.c	20 Apr 2005 11:19:35 -0000	1.88
+++ xine-lib/src/xine-engine/xine_interface.c	8 May 2005 19:32:07 -0000
@@ -329,15 +329,15 @@
 
   switch (param) {
   case XINE_PARAM_SPEED:
-    pthread_mutex_lock (&stream->frontend_lock);
+    _x_rmutex_lock (&stream->frontend_lock);
     _x_set_speed (stream, value);
-    pthread_mutex_unlock (&stream->frontend_lock);
+    _x_rmutex_unlock (&stream->frontend_lock);
     break;
   
   case XINE_PARAM_FINE_SPEED:
-    pthread_mutex_lock (&stream->frontend_lock);
+    _x_rmutex_lock (&stream->frontend_lock);
     _x_set_fine_speed (stream, value);
-    pthread_mutex_unlock (&stream->frontend_lock);
+    _x_rmutex_unlock (&stream->frontend_lock);
     break;
 
   case XINE_PARAM_AV_OFFSET:
@@ -349,11 +349,11 @@
     break;
 
   case XINE_PARAM_AUDIO_CHANNEL_LOGICAL:
-    pthread_mutex_lock (&stream->frontend_lock);
+    _x_rmutex_lock (&stream->frontend_lock);
     if (value < -2)
       value = -2;
     stream->audio_channel_user = value;
-    pthread_mutex_unlock (&stream->frontend_lock);
+    _x_rmutex_unlock (&stream->frontend_lock);
     break;
 
   case XINE_PARAM_SPU_CHANNEL:
@@ -361,11 +361,11 @@
     break;
 
   case XINE_PARAM_VIDEO_CHANNEL:
-    pthread_mutex_lock (&stream->frontend_lock);
+    _x_rmutex_lock (&stream->frontend_lock);
     if (value<0)
       value = 0;
     stream->video_channel = value;
-    pthread_mutex_unlock (&stream->frontend_lock);
+    _x_rmutex_unlock (&stream->frontend_lock);
     break;
 
   case XINE_PARAM_AUDIO_VOLUME:
@@ -671,6 +671,7 @@
   case XINE_STREAM_INFO_IGNORE_AUDIO:
   case XINE_STREAM_INFO_IGNORE_SPU:
   case XINE_STREAM_INFO_VIDEO_HAS_STILL:
+  case XINE_STREAM_INFO_VIDEO_AFD:
     return _x_stream_info_get_public(stream, info);
 
   case XINE_STREAM_INFO_MAX_AUDIO_CHANNEL:
Index: xine-lib/src/xine-engine/xine_internal.h
===================================================================
RCS file: /cvsroot/xine/xine-lib/src/xine-engine/xine_internal.h,v
retrieving revision 1.164
diff -u -r1.164 xine_internal.h
--- xine-lib/src/xine-engine/xine_internal.h	9 Feb 2005 20:03:21 -0000	1.164
+++ xine-lib/src/xine-engine/xine_internal.h	8 May 2005 19:32:07 -0000
@@ -186,6 +186,25 @@
 };
 
 /*
+ * xine_rmutex - xine's recursive mutex emulation
+ */
+
+struct xine_rmutex_s {
+  pthread_mutex_t            access_rmutex;
+  pthread_cond_t             unlock_cond;
+  int                        lock_count;
+  pthread_t                  lock_owner;
+};
+
+typedef struct xine_rmutex_s xine_rmutex_t;
+
+int _x_rmutex_init(xine_rmutex_t *rmutex);
+int _x_rmutex_lock(xine_rmutex_t *rmutex);
+int _x_rmutex_timedlock(xine_rmutex_t *rmutex, int ms_to_time_out);
+int _x_rmutex_unlock(xine_rmutex_t *rmutex);
+int _x_rmutex_destroy(xine_rmutex_t *rmutex);
+
+/*
  * xine_stream - per-stream parts of the xine engine
  */
 
@@ -277,7 +296,7 @@
 /*  int                        spu_channel; */
 
   /* lock for public xine player functions */
-  pthread_mutex_t            frontend_lock;
+  xine_rmutex_t              frontend_lock;
 
   /* stream meta information */
   /* NEVER access directly, use helpers (see info_helper.c) */
@@ -342,6 +361,15 @@
  * private function prototypes:
  */
 
+int _x_continue_stream_processing(xine_stream_t *stream);
+void _x_trigger_relaxed_frame_drop_mode(xine_stream_t *stream);
+void _x_reset_relaxed_frame_drop_mode(xine_stream_t *stream);
+void _x_query_buffer_usage(xine_stream_t *stream, int *num_video_buffers, int *num_audio_buffers, int *num_video_frames, int *num_audio_frames);
+int _x_query_unprocessed_osd_events(xine_stream_t *stream);
+int _x_demux_seek(xine_stream_t *stream, off_t start_pos, int start_time, int playing);
+int _x_lock_frontend(xine_stream_t *stream, int ms_to_time_out);
+void _x_unlock_frontend(xine_stream_t *stream);
+
 void _x_handle_stream_end      (xine_stream_t *stream, int non_user);
 
 /* report message to UI. usually these are async errors */
diff -Nurp ../xine-cvs/xine-lib/src/vdr/Makefile.am xine-lib/src/vdr/Makefile.am
--- ../xine-cvs/xine-lib/src/vdr/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ xine-lib/src/vdr/Makefile.am	2004-08-10 20:55:21.000000000 +0200
@@ -0,0 +1,30 @@
+include $(top_srcdir)/misc/Makefile.common
+
+
+
+libdir = $(XINE_PLUGINDIR)
+
+AM_CFLAGS = -D_LARGEFILE64_SOURCE
+
+lib_LTLIBRARIES = \
+	xineplug_inp_vdr.la
+
+xineplug_inp_vdr_la_SOURCES = input_vdr.c
+xineplug_inp_vdr_la_LIBADD = $(XINE_LIB)
+xineplug_inp_vdr_la_LDFLAGS = -avoid-version -module @XINE_PLUGIN_MIN_SYMS@
+
+include_HEADERS = input_vdr.h
+
+
+
+postlibdir = $(XINE_PLUGINDIR)/post
+
+postlib_LTLIBRARIES = \
+	xineplug_post_vdr.la
+
+xineplug_post_vdr_la_SOURCES = post_vdr.c
+xineplug_post_vdr_la_LIBADD = $(XINE_LIB)
+xineplug_post_vdr_la_LDFLAGS = -avoid-version -module @XINE_PLUGIN_MIN_SYMS@
+
+noinst_HEADERS = post_vdr.h
+
diff -Nurp ../xine-cvs/xine-lib/src/vdr/input_vdr.c xine-lib/src/vdr/input_vdr.c
--- ../xine-cvs/xine-lib/src/vdr/input_vdr.c	1970-01-01 01:00:00.000000000 +0100
+++ xine-lib/src/vdr/input_vdr.c	2005-05-08 21:23:57.000000000 +0200
@@ -0,0 +1,1747 @@
+/*
+ * Copyright (C) 2003-2004 the xine project
+ *
+ * This file is part of xine, a free video player.
+ * 
+ * xine is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * xine is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
+ *
+ * $Id: input_vdr.c,v 1.51 2003/05/02 15:02:11 miguelfreitas Exp $
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <sys/poll.h>
+#include <errno.h>
+#include <pthread.h>
+
+#define LOG_MODULE "input_vdr"
+#define LOG_VERBOSE
+/*
+#define LOG
+*/
+#include "xine_internal.h"
+#include "xineutils.h"
+#include "input_plugin.h"
+
+#include "input_vdr.h"
+#include "post_vdr.h"
+
+
+
+#define VDR_MAX_NUM_WINDOWS 16
+#define VDR_ABS_FIFO_DIR "/tmp/vdr-xine"
+
+
+
+#define BUF_SIZE 1024
+
+#define LOG_OSD(x)
+/*
+#define LOG_OSD(x) x
+*/
+
+
+typedef struct
+{
+  input_plugin_t      input_plugin;
+   
+  xine_stream_t      *stream;
+  xine_stream_t      *stream_external;
+
+  int                 fh;
+  int                 fh_control;
+  int                 fh_result;
+  int                 fh_event;
+  
+  char               *mrl;
+
+  off_t               curpos;
+  char                seek_buf[ BUF_SIZE ];
+   
+  char                preview[ MAX_PREVIEW_SIZE ];
+  off_t               preview_size;
+   
+  enum funcs          cur_func;
+  off_t               cur_size;
+  off_t               cur_done;
+
+  xine_osd_t         *osd_window[ VDR_MAX_NUM_WINDOWS ];
+  uint8_t            *osd_buffer;
+  uint32_t            osd_buffer_size;
+  uint8_t             osd_unscaled_blending;
+  
+  uint8_t             mute_mode;
+  uint8_t             dont_change_xine_volume;
+  int                 last_volume;
+  vdr_frame_size_changed_data_t frame_size;
+  
+  pthread_t           rpc_thread;
+  int                 rpc_thread_shutdown;
+  pthread_mutex_t     rpc_thread_shutdown_lock;
+  pthread_cond_t      rpc_thread_shutdown_cond;
+
+  xine_event_queue_t *event_queue;
+  xine_event_queue_t *event_queue_external;
+
+}
+vdr_input_plugin_t;
+
+
+
+typedef struct
+{
+  input_class_t       input_class;
+  xine_t             *xine;
+  char               *mrls[ 2 ];
+}
+vdr_input_class_t;
+
+
+
+static int vdr_write(int f, void *b, int n)
+{
+  int t = 0, r;
+  
+  while (t < n)
+  {
+    /*
+     * System calls are not a thread cancellation point in Linux
+     * pthreads.  However, the RT signal sent to cancel the thread
+     * will cause recv() to return with EINTR, and we can manually
+     * check cancellation.
+     */
+    pthread_testcancel();
+    r = write(f, ((char *)b) + t, n - t);
+    pthread_testcancel();
+
+    if (r < 0
+        && (errno == EINTR
+          || errno == EAGAIN))
+    {
+      continue;
+    }
+    
+    if (r < 0)
+      return r;
+    
+    t += r;
+  }
+  
+  return t;
+}
+
+
+
+static int internal_write_event_play_external(vdr_input_plugin_t *this, uint32_t key);
+
+static void event_handler_external(void *user_data, const xine_event_t *event)
+{
+  vdr_input_plugin_t *this = (vdr_input_plugin_t *)user_data;
+  uint32_t key = key_none;
+/*  
+  printf("event_handler_external(): event->type: %d\n", event->type);
+*/
+  switch (event->type)
+  {
+  case XINE_EVENT_UI_PLAYBACK_FINISHED:
+    break;
+
+  default:
+    return;
+  }	
+  
+  if (0 != internal_write_event_play_external(this, key))
+    xprintf(this->stream->xine, XINE_VERBOSITY_LOG, 
+            _(LOG_MODULE ": input event write: %s.\n"), strerror(errno));
+}
+
+static void external_stream_stop(vdr_input_plugin_t *this)
+{
+  if (this->stream_external)
+  {    
+    xine_stop(this->stream_external);
+    xine_close(this->stream_external);
+
+    if (this->event_queue_external)
+    {
+      xine_event_dispose_queue(this->event_queue_external);
+      this->event_queue_external = 0;
+    }
+
+    _x_demux_flush_engine(this->stream_external);
+    
+    xine_dispose(this->stream_external);    
+    this->stream_external = 0;
+  }
+}
+
+static void external_stream_play(vdr_input_plugin_t *this, char *file_name)
+{
+  external_stream_stop(this);
+
+  this->stream_external = xine_stream_new(this->stream->xine, this->stream->audio_out, this->stream->video_out);
+  
+  this->event_queue_external = xine_event_new_queue(this->stream_external);
+
+  xine_event_create_listener_thread(this->event_queue_external, event_handler_external, this);
+
+  if (!xine_open(this->stream_external, file_name)
+      || !xine_play(this->stream_external, 0, 0))
+  {
+    uint32_t key = key_none;
+    
+    if ( 0 != internal_write_event_play_external(this, key))
+      xprintf(this->stream->xine, XINE_VERBOSITY_LOG, 
+              _(LOG_MODULE ": input event write: %s.\n"), strerror(errno));
+  }
+}
+
+static off_t vdr_read_abort(xine_stream_t *stream, int fd, char *buf, off_t todo)
+{  
+  off_t ret;
+  
+  while (1)
+  {
+    /*
+     * System calls are not a thread cancellation point in Linux
+     * pthreads.  However, the RT signal sent to cancel the thread
+     * will cause recv() to return with EINTR, and we can manually
+     * check cancellation.
+     */
+    pthread_testcancel();
+    ret = _x_read_abort(stream, fd, buf, todo);
+    pthread_testcancel();
+    
+    if (ret < 0
+        && (errno == EINTR
+          || errno == EAGAIN))
+    {
+      continue;
+    }
+    
+    break;
+  }
+
+  return ret;
+}
+
+#define READ_DATA_OR_FAIL(kind, log) \
+  data_##kind##_t *data = &data_union.kind; \
+  { \
+    log; \
+    n = vdr_read_abort(this->stream, this->fh_control, (char *)data + sizeof (data->header), sizeof (*data) - sizeof (data->header)); \
+    if (n != sizeof (*data) - sizeof (data->header)) \
+      return -1; \
+    \
+    this->cur_size -= n; \
+  } 
+
+static double _now()
+{
+  struct timeval tv;
+  
+  gettimeofday(&tv, 0);
+
+  return (tv.tv_sec * 1000000.0 + tv.tv_usec) / 1000.0;
+}
+
+static off_t vdr_execute_rpc_command(vdr_input_plugin_t *this)
+{
+  data_union_t data_union;
+  off_t n;
+   
+  n = vdr_read_abort(this->stream, this->fh_control, (char *)&data_union, sizeof (data_union.header));
+  if (n != sizeof (data_union.header))
+    return -1;
+  
+  this->cur_func = data_union.header.func;
+  this->cur_size = data_union.header.len - sizeof (data_union.header);
+  this->cur_done = 0;
+
+  switch (this->cur_func)
+  {
+  case func_nop:
+    {
+      READ_DATA_OR_FAIL(nop, lprintf("got NOP\n"));
+    }
+    break;
+
+  case func_osd_new:
+    {
+      READ_DATA_OR_FAIL(osd_new, LOG_OSD(lprintf("got OSDNEW\n")));
+/*
+      LOG_OSD(lprintf("... (%d,%d)-(%d,%d)\n", data->x, data->y, data->width, data->height));
+
+      fprintf(stderr, "vdr: osdnew %d\n", data->window);
+*/    
+      if (data->window >= VDR_MAX_NUM_WINDOWS)
+        return -1;
+      
+      if (0 != this->osd_window[ data->window ])
+        return -1;
+      
+      this->osd_window[ data->window ] = xine_osd_new(this->stream
+                                                     , data->x
+                                                     , data->y
+                                                     , data->width
+                                                     , data->height);
+      
+      if (0 == this->osd_window[ data->window ])
+        return -1;
+    }
+    break;
+
+  case func_osd_free:
+    {
+      READ_DATA_OR_FAIL(osd_free, LOG_OSD(lprintf("got OSDFREE\n")));
+/*      
+      fprintf(stderr, "vdr: osdfree %d\n", data->window);
+*/      
+      if (data->window >= VDR_MAX_NUM_WINDOWS)
+        return -1;
+      
+      if (0 != this->osd_window[ data->window ])
+        xine_osd_free(this->osd_window[ data->window ]);
+      
+      this->osd_window[ data->window ] = 0;
+    }
+    break;
+    
+  case func_osd_show:
+    {
+      READ_DATA_OR_FAIL(osd_show, LOG_OSD(lprintf("got OSDSHOW\n")));
+/*      
+      fprintf(stderr, "vdr: osdshow %d\n", data->window);
+*/      
+      if (data->window >= VDR_MAX_NUM_WINDOWS)
+        return -1;
+      
+      if (0 != this->osd_window[ data->window ])
+      {
+        if (this->osd_unscaled_blending)
+          xine_osd_show_unscaled(this->osd_window[ data->window ], 0);
+        else
+          xine_osd_show(this->osd_window[ data->window ], 0);
+      }
+    }
+    break;
+    
+  case func_osd_hide:
+    {
+      READ_DATA_OR_FAIL(osd_hide, LOG_OSD(lprintf("got OSDHIDE\n")));
+/*      
+      fprintf(stderr, "vdr: osdhide %d\n", data->window);
+*/      
+      if (data->window >= VDR_MAX_NUM_WINDOWS)
+        return -1;
+      
+      if (0 != this->osd_window[ data->window ])
+      {
+        if (this->osd_unscaled_blending)
+          xine_osd_show_unscaled(this->osd_window[ data->window ], 0);
+        else
+          xine_osd_show(this->osd_window[ data->window ], 0);
+      }
+    }
+    break;
+    
+  case func_osd_flush:
+    {
+      double _t1, _t2;
+      int _n = 0;
+      
+      READ_DATA_OR_FAIL(osd_flush, LOG_OSD(lprintf("got OSDFLUSH\n")));
+/*      
+      fprintf(stderr, "vdr: osdflush +\n");
+*/
+      _t1 = _now();
+      
+      while (_x_query_unprocessed_osd_events(this->stream))
+      {
+/*        
+        fprintf(stderr, "redraw_needed: 1\n");
+*/        
+//        sched_yield();
+        xine_usec_sleep(5000);
+        _n++;
+      }
+
+      _t2 = _now();
+      fprintf(stderr, "vdr: osdflush: n: %d, %.1lf\n", _n, _t2 - _t1);
+/*      
+      fprintf(stderr, "redraw_needed: 0\n");        
+      
+      fprintf(stderr, "vdr: osdflush -\n");
+*/
+    }
+    break;
+    
+  case func_osd_set_position:
+    {
+      READ_DATA_OR_FAIL(osd_set_position, LOG_OSD(lprintf("got OSDSETPOSITION\n")));
+/*
+      fprintf(stderr, "vdr: osdsetposition %d\n", data->window);    
+*/      
+      if (data->window >= VDR_MAX_NUM_WINDOWS)
+        return -1;
+      
+      if (0 != this->osd_window[ data->window ])
+        xine_osd_set_position(this->osd_window[ data->window ], data->x, data->y);
+    }
+    break;
+  
+  case func_osd_draw_bitmap:
+    {
+      READ_DATA_OR_FAIL(osd_draw_bitmap, LOG_OSD(lprintf("got OSDDRAWBITMAP\n")));
+/*
+      fprintf(stderr, "vdr: osddrawbitmap %d\n", data->window);    
+*/      
+      if (this->osd_buffer_size < this->cur_size)
+      {
+        if (this->osd_buffer)
+          free(this->osd_buffer);
+        
+        this->osd_buffer_size = 0;
+        
+        this->osd_buffer = xine_xmalloc(this->cur_size);
+        if (!this->osd_buffer)
+          return -1;
+        
+        this->osd_buffer_size = this->cur_size;
+      }
+      
+      n = vdr_read_abort (this->stream, this->fh_control, (char *)this->osd_buffer, this->cur_size);
+      if (n != this->cur_size)
+        return -1;
+      
+      this->cur_size -= n;
+      
+      if (data->window >= VDR_MAX_NUM_WINDOWS)
+        return -1;
+      
+      if (0 != this->osd_window[ data->window ])
+        xine_osd_draw_bitmap(this->osd_window[ data->window ], this->osd_buffer, data->x, data->y, data->width, data->height, 0);
+    }
+    break;
+    
+  case func_set_color:
+    {
+      uint32_t vdr_color[ 256 ];
+      
+      READ_DATA_OR_FAIL(set_color, lprintf("got SETCOLOR\n"));
+      
+      if (((data->num + 1) * sizeof (uint32_t)) != this->cur_size)
+        return -1;
+      
+      n = vdr_read_abort (this->stream, this->fh_control, (char *)&vdr_color[ data->index ], this->cur_size);
+      if (n != this->cur_size)
+        return -1;
+      
+      this->cur_size -= n;
+      
+      if (data->window >= VDR_MAX_NUM_WINDOWS)
+        return -1;
+      
+      if (0 != this->osd_window[ data->window ])
+      {
+        uint32_t color[ 256 ];
+        uint8_t trans[ 256 ];
+        
+        xine_osd_get_palette(this->osd_window[ data->window ], color, trans);
+        
+        {
+          int i;
+          
+          for (i = data->index; i <= (data->index + data->num); i++)
+          {
+            int a = (vdr_color[ i ] & 0xff000000) >> 0x18;
+            int r = (vdr_color[ i ] & 0x00ff0000) >> 0x10;
+            int g = (vdr_color[ i ] & 0x0000ff00) >> 0x08;
+            int b = (vdr_color[ i ] & 0x000000ff) >> 0x00;
+            
+            int y  = (( 66 * r + 129 * g +  25 * b + 128) >> 8) +  16;
+            int cr = ((112 * r -  94 * g -  18 * b + 128) >> 8) + 128;
+            int cb = ((-38 * r -  74 * g + 112 * b + 128) >> 8) + 128;
+            
+            color[ i ] = (y << 8 | cr) << 8 | cb;
+            trans[ i ] = a >> 4;
+          }
+        }
+        
+        xine_osd_set_palette(this->osd_window[ data->window ], color, trans);
+      }
+    }
+    break;
+
+  case func_play_external:
+    {
+      char file_name[ 1024 ];
+      int file_name_len = 0;
+      
+      READ_DATA_OR_FAIL(play_external, lprintf("got PLAYEXTERNAL\n"));
+
+      file_name_len = this->cur_size;
+
+      if (0 != file_name_len)
+      {
+        if (file_name_len <= 1
+            || file_name_len > sizeof (file_name))
+        {
+          return -1;
+        }
+      
+        n = vdr_read_abort (this->stream, this->fh_control, file_name, file_name_len);
+        if (n != file_name_len)
+          return -1;
+      
+        if (file_name[ file_name_len - 1 ] != '\0')
+          return -1;
+      
+        this->cur_size -= n;
+      }
+
+      lprintf((file_name_len > 0) ? "----------- play external: %s\n" : "---------- stop external\n", file_name);
+      
+      if (file_name_len > 0)
+        external_stream_play(this, file_name);
+      else
+        external_stream_stop(this);
+    }
+    break;
+
+  case func_clear:
+    {
+      READ_DATA_OR_FAIL(clear, lprintf("got CLEAR\n"));
+
+      {
+fprintf(stderr, "+++ CLEAR(%d)\n", data->n);       
+/*        
+        if (!this->dont_change_xine_volume)
+          xine_set_param(this->stream, XINE_PARAM_AUDIO_VOLUME, 0);
+*/      
+        _x_demux_flush_engine(this->stream);
+        _x_demux_seek(this->stream, 0, 0, 0);
+        _x_trigger_relaxed_frame_drop_mode(this->stream);
+//        _x_reset_relaxed_frame_drop_mode(this->stream);
+/*      
+        if (!this->dont_change_xine_volume)
+          xine_set_param(this->stream, XINE_PARAM_AUDIO_VOLUME, this->last_volume);
+*/
+fprintf(stderr, "--- CLEAR(%d)\n", data->n);       
+      }
+    }
+    break;
+
+  case func_first_frame:
+    {
+      READ_DATA_OR_FAIL(first_frame, lprintf("got FIRST FRAME\n"));
+
+      _x_trigger_relaxed_frame_drop_mode(this->stream);
+//      _x_reset_relaxed_frame_drop_mode(this->stream);
+    }
+    break;
+
+  case func_still_frame:
+    {
+      READ_DATA_OR_FAIL(still_frame, lprintf("got STILL FRAME\n"));
+
+      _x_reset_relaxed_frame_drop_mode(this->stream);
+    }
+    break;
+
+  case func_set_video_window:
+    {
+      READ_DATA_OR_FAIL(set_video_window, lprintf("got SET VIDEO WINDOW\n"));
+/*
+      fprintf(stderr, "svw: (%d, %d)x(%d, %d), (%d, %d)\n", data->x, data->y, data->w, data->h, data->wRef, data->hRef);
+*/    
+      {
+        xine_event_t event;
+        vdr_set_video_window_data_t event_data;
+        
+        event_data.x = data->x;
+        event_data.y = data->y;
+        event_data.w = data->w;
+        event_data.h = data->h;
+        event_data.w_ref = data->w_ref;
+        event_data.h_ref = data->h_ref;
+        
+        event.type = XINE_EVENT_VDR_SETVIDEOWINDOW;
+        event.data = &event_data;
+        event.data_length = sizeof (event_data);
+        
+        xine_event_send(this->stream, &event);
+      }
+    }
+    break;
+    
+  case func_flush:
+    {
+      READ_DATA_OR_FAIL(flush, lprintf("got FLUSH\n"));
+
+      if (!data->just_wait)
+      {
+        if (this->stream->video_fifo)
+        {
+          buf_element_t *buf = this->stream->video_fifo->buffer_pool_alloc(this->stream->video_fifo);
+          if (!buf)
+          {
+            xprintf(this->stream->xine, XINE_VERBOSITY_LOG, _(LOG_MODULE ": buffer_pool_alloc() failed!\n"));
+            return -1;
+          }
+          
+          buf->type = BUF_CONTROL_FLUSH_DECODER;
+          
+          this->stream->video_fifo->put(this->stream->video_fifo, buf);
+        }
+      }
+      
+      {
+        double _t1, _t2;
+        int _n = 0;
+        
+        int vb = -1, ab = -1, vf = -1, af = -1;
+        
+        uint8_t timed_out = 0;
+        
+        struct timeval now, then;
+        
+        if (data->ms_timeout >= 0)
+        {
+          gettimeofday(&now, 0);
+          
+          then = now;
+          then.tv_usec += (data->ms_timeout % 1000) * 1000;
+          then.tv_sec  += (data->ms_timeout / 1000);
+          
+          if (then.tv_usec >= 1000000)
+          {
+            then.tv_usec -= 1000000;
+            then.tv_sec  += 1;
+          }
+        }
+
+        _t1 = _now();
+        
+        while (1)
+        {
+          _x_query_buffer_usage(this->stream, &vb, &ab, &vf, &af);
+          
+          if (vb <= 0 && ab <= 0 && vf <= 0 && af <= 0)
+            break;
+          
+          if (data->ms_timeout >= 0
+              && timercmp(&now, &then, >))
+          {
+            timed_out++;
+            break;
+          }
+          
+//          sched_yield();
+          xine_usec_sleep(5000);
+          _n++;
+          
+          if (data->ms_timeout >= 0)
+            gettimeofday(&now, 0);          
+        }
+
+        _t2 = _now();
+        fprintf(stderr, "vdr: flush: n: %d, %.1lf\n", _n, _t2 - _t1);
+        
+        xprintf(this->stream->xine
+                , XINE_VERBOSITY_LOG
+                , _(LOG_MODULE ": flush buffers (vb: %d, ab: %d, vf: %d, af: %d) %s.\n")
+                , vb, ab, vf, af
+                , (timed_out ? "timed out" : "done"));
+        
+        {
+          result_flush_t result_flush;
+          result_flush.header.func = data->header.func;
+          result_flush.header.len = sizeof (result_flush);
+          
+          result_flush.timed_out = timed_out;
+          
+          if (sizeof (result_flush) != vdr_write(this->fh_result, &result_flush, sizeof (result_flush)))
+            return -1;
+        }
+      }
+    }
+    break;
+
+  case func_mute:
+    {
+      READ_DATA_OR_FAIL(mute, lprintf("got MUTE\n"));
+      
+      xine_set_param(this->stream, XINE_PARAM_AUDIO_MUTE, data->mute);
+    }
+    break;
+
+  case func_set_volume:
+    {
+      READ_DATA_OR_FAIL(set_volume, lprintf("got SETVOLUME\n"));
+
+      {
+        int change_volume = !this->dont_change_xine_volume;
+        int do_mute   = (0 != this->last_volume && 0 == data->volume);
+        int do_unmute = (0 == this->last_volume && 0 != data->volume);
+        int report_change = 0;
+        
+        this->last_volume = data->volume;
+
+        if (do_mute || do_unmute)
+        {
+          switch (this->mute_mode)
+          {
+          case INPUT_VDR_MUTE_EXECUTE:
+            report_change = 1;
+            xine_set_param(this->stream, XINE_PARAM_AUDIO_MUTE, do_mute);
+            
+          case INPUT_VDR_MUTE_IGNORE:
+            if (do_mute)
+              change_volume = 0;
+            break;
+
+          case INPUT_VDR_MUTE_SIMULATE:
+            change_volume = 1;
+            break;
+
+          default:
+            return -1;
+          };
+        }
+        
+        if (change_volume)
+        {
+          report_change = 1;
+          xine_set_param(this->stream, XINE_PARAM_AUDIO_VOLUME, this->last_volume);
+        }
+
+        if (report_change)
+        {
+          xine_event_t            event;
+          xine_audio_level_data_t data;
+          
+          data.left
+            = data.right
+            = xine_get_param(this->stream, XINE_PARAM_AUDIO_VOLUME);
+          data.mute
+            = xine_get_param(this->stream, XINE_PARAM_AUDIO_MUTE);
+          
+          event.type        = XINE_EVENT_AUDIO_LEVEL;
+          event.data        = &data;
+          event.data_length = sizeof (data);
+          
+          xine_event_send(this->stream, &event);
+        }
+      }
+    }
+    break;
+
+  case func_set_speed:
+    {
+      READ_DATA_OR_FAIL(set_speed, lprintf("got SETSPEED\n"));
+      
+      lprintf("... got SETSPEED %d\n", data->speed);
+      
+      if (data->speed != xine_get_param(this->stream, XINE_PARAM_FINE_SPEED))
+        xine_set_param(this->stream, XINE_PARAM_FINE_SPEED, data->speed);
+    }
+    break;
+
+  case func_set_prebuffer:
+    {
+      READ_DATA_OR_FAIL(set_prebuffer, lprintf("got SETPREBUFFER\n"));
+
+      xine_set_param(this->stream, XINE_PARAM_METRONOM_PREBUFFER, data->prebuffer);
+    }
+    break;
+
+  case func_metronom:
+    {
+      READ_DATA_OR_FAIL(metronom, lprintf("got METRONOM\n"));
+
+      _x_demux_control_newpts(this->stream, data->pts, data->flags);
+    }
+    break;
+    
+  case func_start:
+    {
+      READ_DATA_OR_FAIL(start, lprintf("got START\n"));
+
+      _x_demux_control_start(this->stream);
+      _x_demux_seek(this->stream, 0, 0, 0);
+    }
+    break;
+
+  case func_wait:
+    {
+      READ_DATA_OR_FAIL(wait, lprintf("got WAIT\n"));
+    }
+    break;
+
+  case func_setup:
+    {
+      READ_DATA_OR_FAIL(setup, lprintf("got SETUP\n"));
+
+      this->osd_unscaled_blending   = data->osd_unscaled_blending;
+      this->dont_change_xine_volume = data->dont_change_xine_volume;
+      this->mute_mode               = data->mute_mode;
+    }
+    break;
+
+  case func_grab_image:
+    {
+      READ_DATA_OR_FAIL(grab_image, lprintf("got GRABIMAGE\n"));
+
+      {
+        off_t ret_val = -1;
+        
+        uint8_t *img   = 0;
+        int frame_size = 0;
+        int width      = 0;
+        int height     = 0;       
+        int ratio_code = 0;
+        int format     = 0;
+        
+        int orig_speed = xine_get_param(this->stream, XINE_PARAM_FINE_SPEED);
+        if (XINE_SPEED_PAUSE != orig_speed)
+          xine_set_param(this->stream, XINE_PARAM_FINE_SPEED, XINE_SPEED_PAUSE);
+        
+        if (xine_get_current_frame(this->stream, &width, &height, &ratio_code, &format, 0))
+        {
+          switch (format)
+          {
+          case XINE_IMGFMT_YV12:
+            frame_size = width * height
+              + ((width + 1) / 2) * ((height + 1) / 2)
+              + ((width + 1) / 2) * ((height + 1) / 2);
+            break;
+            
+          case XINE_IMGFMT_YUY2:
+            frame_size = width * height
+              + ((width + 1) / 2) * height
+              + ((width + 1) / 2) * height;
+            break;
+          }
+          
+          img = xine_xmalloc(frame_size);
+          
+          if (!xine_get_current_frame(this->stream, &width, &height, &ratio_code, &format, img))
+            frame_size = 0;
+          
+          if (ratio_code == XINE_VO_ASPECT_SQUARE)
+            ratio_code = 10000;
+          else if (ratio_code == XINE_VO_ASPECT_4_3)
+            ratio_code = 13333;
+          else if (ratio_code == XINE_VO_ASPECT_ANAMORPHIC)
+            ratio_code = 17778;
+          else if (ratio_code == XINE_VO_ASPECT_DVB)
+            ratio_code = 21100;
+          
+          if (0 == frame_size)
+          {
+            width      = 0;
+            height     = 0;
+            ratio_code = 0;
+          }          
+        }
+        
+        if (XINE_SPEED_PAUSE != orig_speed)
+          xine_set_param(this->stream, XINE_PARAM_FINE_SPEED, orig_speed);
+        
+        {
+          result_grab_image_t result_grab_image;
+          result_grab_image.header.func = data->header.func;
+          result_grab_image.header.len = sizeof (result_grab_image) + frame_size;
+          
+          result_grab_image.width  = width;
+          result_grab_image.height = height;
+          result_grab_image.ratio  = ratio_code;
+          result_grab_image.format = format;
+          
+          if (sizeof (result_grab_image) == vdr_write(this->fh_result, &result_grab_image, sizeof (result_grab_image)))
+          {
+            if (frame_size == vdr_write(this->fh_result, img, frame_size))
+              ret_val = 0;
+          }
+        }
+        
+        if (img)
+          free(img);
+        
+        if (ret_val != 0)
+          return ret_val;
+      }
+    }
+    break;
+    
+  case func_get_pts:
+    {
+      READ_DATA_OR_FAIL(get_pts, lprintf("got GETPTS\n"));
+      
+      {
+        result_get_pts_t result_get_pts;
+        result_get_pts.header.func = data->header.func;
+        result_get_pts.header.len = sizeof (result_get_pts);
+        
+        result_get_pts.pts = xine_get_current_vpts(this->stream) - this->stream->metronom->get_option(this->stream->metronom, METRONOM_VPTS_OFFSET);
+        
+        if (sizeof (result_get_pts) != vdr_write(this->fh_result, &result_get_pts, sizeof (result_get_pts)))
+          return -1;
+      }
+    }
+    break;
+
+  case func_video_size:
+    {
+      READ_DATA_OR_FAIL(video_size, lprintf("got VIDEO SIZE\n"));
+
+      {
+        int format;
+        
+        result_video_size_t result_video_size;
+        result_video_size.header.func = data->header.func;
+        result_video_size.header.len = sizeof (result_video_size);
+        
+        result_video_size.top    = -1;
+        result_video_size.left   = -1;
+        result_video_size.width  = -1;
+        result_video_size.height = -1;
+        result_video_size.ratio  = 0;
+        
+        xine_get_current_frame(this->stream, &result_video_size.width, &result_video_size.height, &result_video_size.ratio, &format, 0);
+        
+        if (result_video_size.ratio == XINE_VO_ASPECT_SQUARE)
+          result_video_size.ratio = 10000;
+        else if (result_video_size.ratio == XINE_VO_ASPECT_4_3)
+          result_video_size.ratio = 13333;
+        else if (result_video_size.ratio == XINE_VO_ASPECT_ANAMORPHIC)
+          result_video_size.ratio = 17778;
+        else if (result_video_size.ratio == XINE_VO_ASPECT_DVB)
+          result_video_size.ratio = 21100;
+        
+        if (0 != this->frame_size.x
+            || 0 != this->frame_size.y
+            || 0 != this->frame_size.w
+            || 0 != this->frame_size.h)
+        {
+          result_video_size.left   = this->frame_size.x;
+          result_video_size.top    = this->frame_size.y;
+          result_video_size.width  = this->frame_size.w;
+          result_video_size.height = this->frame_size.h;
+        }
+        
+        if (sizeof (result_video_size) != vdr_write(this->fh_result, &result_video_size, sizeof (result_video_size)))
+          return -1;
+      }
+    }
+    break;
+
+  case func_reset_audio:
+    {
+      double _t1, _t2;
+      int _n = 0;
+      
+      READ_DATA_OR_FAIL(reset_audio, lprintf("got RESET AUDIO\n"));
+
+      if (this->stream->audio_fifo)
+      {
+        xine_set_param(this->stream, XINE_PARAM_IGNORE_AUDIO, 1);
+        xine_set_param(this->stream, XINE_PARAM_AUDIO_CHANNEL_LOGICAL, -2);
+
+        _t1 = _now();
+        
+        while (1)
+        {
+          int n = xine_get_stream_info(this->stream, XINE_STREAM_INFO_MAX_AUDIO_CHANNEL);
+          if (n <= 0)
+            break;
+          
+          // keep the decoder running
+          if (this->stream->audio_fifo)
+          {
+            buf_element_t *buf = this->stream->audio_fifo->buffer_pool_alloc(this->stream->audio_fifo);
+            if (!buf)
+            {
+              xprintf(this->stream->xine, XINE_VERBOSITY_LOG, _(LOG_MODULE ": buffer_pool_alloc() failed!\n"));
+              return -1;
+            }
+            
+            buf->type = BUF_CONTROL_NOP;
+            
+            this->stream->audio_fifo->put(this->stream->audio_fifo, buf);
+          }
+          
+//          sched_yield();
+          xine_usec_sleep(5000);
+          _n++;
+        }
+
+        _t2 = _now();
+        fprintf(stderr, "vdr: reset_audio: n: %d, %.1lf\n", _n, _t2 - _t1);
+        
+        xine_set_param(this->stream, XINE_PARAM_AUDIO_CHANNEL_LOGICAL, -1);
+        xine_set_param(this->stream, XINE_PARAM_IGNORE_AUDIO, 0);
+      }
+    }
+    break;
+    
+  default:
+    lprintf("unknown function: %d\n", this->cur_func);
+  }
+    
+  if (this->cur_size != this->cur_done)
+  {
+    off_t skip = this->cur_size - this->cur_done;
+
+    lprintf("func: %d, skipping: %lld\n", this->cur_func, skip);
+     
+    while (skip > BUF_SIZE)
+    {
+      n = vdr_read_abort(this->stream, this->fh_control, this->seek_buf, BUF_SIZE);
+      if (n != BUF_SIZE)
+        return -1;
+
+      skip -= BUF_SIZE;
+    }
+
+    n = vdr_read_abort(this->stream, this->fh_control, this->seek_buf, skip);
+    if (n != skip)
+      return -1;
+
+    this->cur_done = this->cur_size;
+
+    return -1;
+  }
+
+  return 0;
+}
+
+static void *vdr_rpc_thread_loop(void *arg)
+{
+  vdr_input_plugin_t *this = (vdr_input_plugin_t *)arg;
+  int frontend_lock_failures = 0;
+  int failed = 0;
+  
+  while (!failed
+    && !this->rpc_thread_shutdown)
+  {
+    struct timeval timeout;
+    fd_set rset;
+  
+    FD_ZERO(&rset);
+    FD_SET(this->fh_control, &rset);
+
+    timeout.tv_sec  = 0;
+    timeout.tv_usec = 50000;
+
+    if (select(this->fh_control + 1, &rset, NULL, NULL, &timeout) > 0)
+    {
+      if (!_x_lock_frontend(this->stream, 100))
+      {
+        if (++frontend_lock_failures > 50)
+        {
+          failed = 1;
+          xprintf(this->stream->xine, XINE_VERBOSITY_LOG,
+                  LOG_MODULE ": locking frontend for rpc command execution failed, exiting ...\n");
+        }
+      }
+      else
+      {
+        frontend_lock_failures = 0;
+        
+        if (vdr_execute_rpc_command(this) < 0)
+        {
+          failed = 1;
+          xprintf(this->stream->xine, XINE_VERBOSITY_LOG,
+                  LOG_MODULE ": execution of rpc command %d (%s) failed, exiting ...\n", this->cur_func, "");
+        }
+
+        _x_unlock_frontend(this->stream);
+      }
+    }
+  }
+
+  // close control and result channel here to have vdr-xine initiate a disconnect for the above error case ...
+  close(this->fh_control);
+  this->fh_control = -1;
+  
+  close(this->fh_result);
+  this->fh_result = -1;
+  
+  xprintf(this->stream->xine, XINE_VERBOSITY_LOG,
+          LOG_MODULE ": rpc thread done.\n");
+
+  pthread_mutex_lock(&this->rpc_thread_shutdown_lock);
+  this->rpc_thread_shutdown = -1;
+  pthread_cond_broadcast(&this->rpc_thread_shutdown_cond);
+  pthread_mutex_unlock(&this->rpc_thread_shutdown_lock);
+  
+  return 0;
+}
+
+static int internal_write_event_key(vdr_input_plugin_t *this, uint32_t key)
+{
+  event_key_t event;
+  event.header.func = func_key;
+  event.header.len = sizeof (event);
+
+  event.key = key;
+
+  if (sizeof (event) != vdr_write(this->fh_event, &event, sizeof (event)))
+    return -1;
+  
+  return 0;
+}
+
+static int internal_write_event_frame_size(vdr_input_plugin_t *this)
+{
+  event_frame_size_t event;
+  event.header.func = func_frame_size;
+  event.header.len = sizeof (event);
+
+  event.top    = this->frame_size.x;
+  event.left   = this->frame_size.y;
+  event.width  = this->frame_size.w,
+  event.height = this->frame_size.h;
+
+  if (sizeof (event) != vdr_write(this->fh_event, &event, sizeof (event)))
+    return -1;
+  
+  return 0;
+}
+
+static int internal_write_event_play_external(vdr_input_plugin_t *this, uint32_t key)
+{
+  event_play_external_t event;
+  event.header.func = func_play_external;
+  event.header.len = sizeof (event);
+
+  event.key = key;
+
+  if (sizeof (event) != vdr_write(this->fh_event, &event, sizeof (event)))
+    return -1;
+  
+  return 0;
+}
+
+static off_t vdr_plugin_read(input_plugin_t *this_gen, 
+                             char *buf, off_t len)
+{
+  vdr_input_plugin_t  *this = (vdr_input_plugin_t *) this_gen;
+  off_t n, total;
+#ifdef LOG_READ   
+  lprintf ("reading %lld bytes...\n", len);
+#endif   
+  total=0;
+  if (this->curpos < this->preview_size)
+  {
+    n = this->preview_size - this->curpos;
+    if (n > (len - total))
+      n = len - total;
+#ifdef LOG_READ
+    lprintf ("%lld bytes from preview (which has %lld bytes)\n",
+            n, this->preview_size);
+#endif
+    memcpy (&buf[total], &this->preview[this->curpos], n);
+    this->curpos += n;
+    total += n;
+  }
+   
+  if( (len-total) > 0 )
+  {
+    int retries = 0;
+    do
+    {
+      n = vdr_read_abort (this->stream, this->fh, &buf[total], len-total);
+      if (0 == n)
+        lprintf("read 0, retries: %d\n", retries);
+    }
+    while (0 == n
+           && !this->stream_external
+           && _x_continue_stream_processing(this->stream)
+           && 200 > retries++); /* 200 * 50ms */
+#ifdef LOG_READ      
+    lprintf ("got %lld bytes (%lld/%lld bytes read)\n",
+            n,total,len);
+#endif
+    if (n < 0)
+    {
+      _x_message(this->stream, XINE_MSG_READ_ERROR, NULL);
+      return 0;
+    }
+
+    this->curpos += n;
+    total += n;
+  }
+  return total;
+}
+
+static buf_element_t *vdr_plugin_read_block(input_plugin_t *this_gen, fifo_buffer_t *fifo, 
+                                            off_t todo)
+{
+  off_t          total_bytes;
+  buf_element_t *buf = fifo->buffer_pool_alloc(fifo);
+
+  buf->content = buf->mem;
+  buf->type = BUF_DEMUX_BLOCK;
+
+  total_bytes = vdr_plugin_read(this_gen, buf->content, todo);
+
+  if (total_bytes != todo)
+  {
+    buf->free_buffer(buf);
+    return NULL;
+  }
+
+  buf->size = total_bytes;
+
+  return buf;
+}
+
+/* forward reference */
+static off_t vdr_plugin_get_current_pos(input_plugin_t *this_gen);
+
+static off_t vdr_plugin_seek(input_plugin_t *this_gen, off_t offset, int origin)
+{
+  vdr_input_plugin_t *this = (vdr_input_plugin_t *)this_gen;
+
+  lprintf("seek %lld offset, %d origin...\n",
+          offset, origin);
+
+  if ((origin == SEEK_CUR) && (offset >= 0))
+  {
+    for ( ; ((int)offset) - BUF_SIZE > 0; offset -= BUF_SIZE)
+    {
+      if (!this_gen->read(this_gen, this->seek_buf, BUF_SIZE))
+        return this->curpos;
+    }
+
+    this_gen->read (this_gen, this->seek_buf, offset);
+  }
+
+  if (origin == SEEK_SET)
+  {
+    if (offset < this->curpos)
+    {
+      if (this->curpos <= this->preview_size) 
+        this->curpos = offset;
+      else
+        lprintf("cannot seek back! (%lld > %lld)\n", this->curpos, offset);
+    }
+    else
+    {
+      offset -= this->curpos;
+
+      for ( ; ((int)offset) - BUF_SIZE > 0; offset -= BUF_SIZE)
+      {
+        if (!this_gen->read(this_gen, this->seek_buf, BUF_SIZE))
+          return this->curpos;
+      }
+
+      this_gen->read(this_gen, this->seek_buf, offset);
+    }
+  }
+
+  return this->curpos;
+}
+
+static off_t vdr_plugin_get_length(input_plugin_t *this_gen)
+{
+  return 0;
+}
+
+static uint32_t vdr_plugin_get_capabilities(input_plugin_t *this_gen)
+{
+  /* return INPUT_CAP_PREVIEW; */
+  return INPUT_CAP_NOCAP;
+}
+
+static uint32_t vdr_plugin_get_blocksize(input_plugin_t *this_gen)
+{
+  return 0;
+}
+
+static off_t vdr_plugin_get_current_pos(input_plugin_t *this_gen)
+{
+  vdr_input_plugin_t *this = (vdr_input_plugin_t *)this_gen;
+
+  return this->curpos;
+}
+
+static char* vdr_plugin_get_mrl(input_plugin_t *this_gen)
+{
+  vdr_input_plugin_t *this = (vdr_input_plugin_t *)this_gen;
+
+  return this->mrl;
+}
+
+static void vdr_plugin_dispose(input_plugin_t *this_gen)
+{
+  vdr_input_plugin_t *this = (vdr_input_plugin_t *)this_gen;
+  int i;
+
+  external_stream_stop(this);
+
+  if (this->event_queue)
+    xine_event_dispose_queue(this->event_queue);
+
+  if (this->rpc_thread)
+  {
+    struct timespec abstime;
+    int ms_to_time_out = 10000;
+
+    xprintf(this->stream->xine, XINE_VERBOSITY_LOG, _(LOG_MODULE ": shutting down rpc thread (timeout: %d ms) ...\n"), ms_to_time_out);
+
+    pthread_mutex_lock(&this->rpc_thread_shutdown_lock);
+
+    if (this->rpc_thread_shutdown > -1)
+    {
+      this->rpc_thread_shutdown = 1;
+      
+      {
+        struct timeval now;
+        gettimeofday(&now, 0);
+        
+        abstime.tv_sec = now.tv_sec + ms_to_time_out / 1000;
+        abstime.tv_nsec = now.tv_usec * 1000 + (ms_to_time_out % 1000) * 1e6;
+        
+        if (abstime.tv_nsec > 1e9)
+        {
+          abstime.tv_nsec -= 1e9;
+          abstime.tv_sec++;
+        }
+      }
+      
+      if (0 != pthread_cond_timedwait(&this->rpc_thread_shutdown_cond, &this->rpc_thread_shutdown_lock, &abstime))
+      {
+        xprintf(this->stream->xine, XINE_VERBOSITY_LOG, _(LOG_MODULE ": cancelling rpc thread ...\n"));
+        pthread_cancel(this->rpc_thread);
+      }
+    }
+    
+    pthread_mutex_unlock(&this->rpc_thread_shutdown_lock);
+    
+    xprintf(this->stream->xine, XINE_VERBOSITY_LOG, _(LOG_MODULE ": joining rpc thread ...\n"));
+    pthread_join(this->rpc_thread, 0);
+    xprintf(this->stream->xine, XINE_VERBOSITY_LOG, _(LOG_MODULE ": rpc thread joined.\n"));
+  }
+
+  pthread_cond_destroy(&this->rpc_thread_shutdown_cond);
+  pthread_mutex_destroy(&this->rpc_thread_shutdown_lock);
+  
+  if (this->fh_result != -1)
+    close(this->fh_result);
+  
+  if (this->fh_control != -1)
+    close(this->fh_control);
+
+  if (this->fh_event != -1)
+    close(this->fh_event);
+  
+  for (i = 0; i < VDR_MAX_NUM_WINDOWS; i++)
+  {
+    if (0 == this->osd_window[ i ])
+      continue;
+
+    xine_osd_hide(this->osd_window[ i ], 0);
+    xine_osd_free(this->osd_window[ i ]);
+  }
+
+  if (this->osd_buffer)
+    free(this->osd_buffer);
+  
+  if ((this->fh != STDIN_FILENO) && (this->fh != -1))
+    close(this->fh);
+
+  free(this->mrl);
+  free(this);
+}
+
+static int vdr_plugin_get_optional_data(input_plugin_t *this_gen, 
+                                        void *data, int data_type)
+{
+/*
+  vdr_input_plugin_t *this = (vdr_input_plugin_t *)this_gen;
+  
+  switch (data_type)
+  {
+  case INPUT_OPTIONAL_DATA_PREVIEW:
+    memcpy (data, this->preview, this->preview_size);
+    return this->preview_size;
+  }
+*/  
+  return INPUT_OPTIONAL_UNSUPPORTED;
+}
+
+static int vdr_plugin_open(input_plugin_t *this_gen)
+{
+  vdr_input_plugin_t *this = (vdr_input_plugin_t *)this_gen;
+
+  lprintf("trying to open '%s'...\n", this->mrl);
+
+  if (this->fh == -1)
+  {
+    char *filename;
+    int err = 0;
+
+    filename = (char *)&this->mrl[ 4 ];
+    this->fh = open(filename, O_RDONLY | O_NONBLOCK);
+
+    lprintf("filename '%s'\n", filename);
+
+    if (this->fh == -1)
+    {
+      xprintf(this->stream->xine, XINE_VERBOSITY_LOG,
+              _(LOG_MODULE ": failed to open '%s' (%s)\n"),
+              filename,
+              strerror(errno));
+      
+      return 0;
+    }
+
+    {
+      struct pollfd poll_fh = { this->fh, POLLIN, 0 };
+      
+      int r = poll(&poll_fh, 1, 300);      
+      if (1 != r)
+      {
+        xprintf(this->stream->xine, XINE_VERBOSITY_LOG,
+                _(LOG_MODULE ": failed to open '%s' (%s)\n"),
+                filename,
+                _("timeout expired during setup phase"));
+        
+        return 0;
+      }
+    }
+    
+    fcntl(this->fh, F_SETFL, ~O_NONBLOCK & fcntl(this->fh, F_GETFL, 0));
+    
+    {
+      char *filename_control = 0;
+      asprintf(&filename_control, "%s.control", filename);
+
+      this->fh_control = open(filename_control, O_RDONLY);
+
+      if (this->fh_control == -1) {
+        xprintf(this->stream->xine, XINE_VERBOSITY_LOG,
+                _(LOG_MODULE ": failed to open '%s' (%s)\n"),
+                filename_control,
+                strerror(errno));
+
+        free(filename_control);
+        return 0;
+      }
+
+      free(filename_control);      
+    }
+
+    {
+      char *filename_result = 0;
+      asprintf(&filename_result, "%s.result", filename);
+
+      this->fh_result = open(filename_result, O_WRONLY);
+
+      if (this->fh_result == -1) {
+        perror("failed");
+        
+        xprintf(this->stream->xine, XINE_VERBOSITY_LOG,
+                _(LOG_MODULE ": failed to open '%s' (%s)\n"),
+                filename_result,
+                strerror(errno));
+        
+        free(filename_result);
+        return 0;
+      }
+
+      free(filename_result);
+    }
+
+    {
+      char *filename_event = 0;
+      asprintf(&filename_event, "%s.event", filename);
+
+      this->fh_event = open(filename_event, O_WRONLY);
+
+      if (this->fh_event == -1) {
+        perror("failed");
+
+        xprintf(this->stream->xine, XINE_VERBOSITY_LOG,
+                _(LOG_MODULE ": failed to open '%s' (%s)\n"),
+                filename_event,
+                strerror(errno));
+        
+        free(filename_event);
+        return 0;
+      }
+
+      free(filename_event);
+    }
+
+    this->rpc_thread_shutdown = 0;
+    if ((err = pthread_create(&this->rpc_thread, NULL,
+                              vdr_rpc_thread_loop, (void *)this)) != 0)
+    {
+      xprintf(this->stream->xine, XINE_VERBOSITY_LOG, 
+              _(LOG_MODULE ": can't create new thread (%s)\n"),
+              strerror(err));
+      
+      return 0;
+    }
+  }
+
+
+  /*
+   * mrl accepted and opened successfully at this point
+   *
+   * => create plugin instance
+   */
+
+  /*
+   * fill preview buffer
+   */
+
+  this->preview_size = 0; /* vdr_plugin_read (&this->input_plugin, this->preview,
+                             MAX_PREVIEW_SIZE) */ 
+  this->curpos       = 0;
+
+  return 1;
+}
+
+static void event_handler(void *user_data, const xine_event_t *event)
+{
+  vdr_input_plugin_t *this = (vdr_input_plugin_t *)user_data;
+  uint32_t key = key_none;
+
+  lprintf("eventHandler(): event->type: %d\n", event->type);
+
+  if (XINE_EVENT_VDR_FRAMESIZECHANGED == event->type)
+  {
+    memcpy(&this->frame_size, event->data, event->data_length);
+
+    if (0 != internal_write_event_frame_size(this))
+      xprintf(this->stream->xine, XINE_VERBOSITY_LOG, 
+              _(LOG_MODULE ": input event write: %s.\n"), strerror(errno));
+
+    return;
+  }
+  
+  switch (event->type)
+  {
+  case XINE_EVENT_INPUT_UP:            key = key_up;               break;
+  case XINE_EVENT_INPUT_DOWN:          key = key_down;             break;
+  case XINE_EVENT_INPUT_LEFT:          key = key_left;             break;
+  case XINE_EVENT_INPUT_RIGHT:         key = key_right;            break;
+  case XINE_EVENT_INPUT_SELECT:        key = key_ok;               break;
+  case XINE_EVENT_VDR_BACK:            key = key_back;             break;
+  case XINE_EVENT_VDR_CHANNELPLUS:     key = key_channel_plus;     break;
+  case XINE_EVENT_VDR_CHANNELMINUS:    key = key_channel_minus;    break;
+  case XINE_EVENT_VDR_RED:             key = key_red;              break;
+  case XINE_EVENT_VDR_GREEN:           key = key_green;            break;
+  case XINE_EVENT_VDR_YELLOW:          key = key_yellow;           break;
+  case XINE_EVENT_VDR_BLUE:            key = key_blue;             break;
+  case XINE_EVENT_VDR_PLAY:            key = key_play;             break;
+  case XINE_EVENT_VDR_PAUSE:           key = key_pause;            break;
+  case XINE_EVENT_VDR_STOP:            key = key_stop;             break;
+  case XINE_EVENT_VDR_RECORD:          key = key_record;           break;
+  case XINE_EVENT_VDR_FASTFWD:         key = key_fast_fwd;         break;
+  case XINE_EVENT_VDR_FASTREW:         key = key_fast_rew;         break;
+  case XINE_EVENT_VDR_POWER:           key = key_power;            break;
+  case XINE_EVENT_VDR_SCHEDULE:        key = key_schedule;         break;
+  case XINE_EVENT_VDR_CHANNELS:        key = key_channels;         break;
+  case XINE_EVENT_VDR_TIMERS:          key = key_timers;           break;
+  case XINE_EVENT_VDR_RECORDINGS:      key = key_recordings;       break;
+  case XINE_EVENT_INPUT_MENU1:         key = key_menu;             break;
+  case XINE_EVENT_VDR_SETUP:           key = key_setup;            break;
+  case XINE_EVENT_VDR_COMMANDS:        key = key_commands;         break;
+  case XINE_EVENT_INPUT_NUMBER_0:      key = key_0;                break;
+  case XINE_EVENT_INPUT_NUMBER_1:      key = key_1;                break;
+  case XINE_EVENT_INPUT_NUMBER_2:      key = key_2;                break;
+  case XINE_EVENT_INPUT_NUMBER_3:      key = key_3;                break;
+  case XINE_EVENT_INPUT_NUMBER_4:      key = key_4;                break;
+  case XINE_EVENT_INPUT_NUMBER_5:      key = key_5;                break;
+  case XINE_EVENT_INPUT_NUMBER_6:      key = key_6;                break;
+  case XINE_EVENT_INPUT_NUMBER_7:      key = key_7;                break;
+  case XINE_EVENT_INPUT_NUMBER_8:      key = key_8;                break;
+  case XINE_EVENT_INPUT_NUMBER_9:      key = key_9;                break;
+  case XINE_EVENT_VDR_USER1:           key = key_user1;            break;
+  case XINE_EVENT_VDR_USER2:           key = key_user2;            break;
+  case XINE_EVENT_VDR_USER3:           key = key_user3;            break;
+  case XINE_EVENT_VDR_USER4:           key = key_user4;            break;
+  case XINE_EVENT_VDR_USER5:           key = key_user5;            break;
+  case XINE_EVENT_VDR_USER6:           key = key_user6;            break;
+  case XINE_EVENT_VDR_USER7:           key = key_user7;            break;
+  case XINE_EVENT_VDR_USER8:           key = key_user8;            break;
+  case XINE_EVENT_VDR_USER9:           key = key_user9;            break;
+  case XINE_EVENT_VDR_VOLPLUS:         key = key_volume_plus;      break;
+  case XINE_EVENT_VDR_VOLMINUS:        key = key_volume_minus;     break;
+  case XINE_EVENT_VDR_MUTE:            key = key_mute;             break;
+  case XINE_EVENT_VDR_AUDIO:           key = key_audio;            break;
+  default:
+    return;
+  }
+
+  if (0 != internal_write_event_key(this, key))
+    xprintf(this->stream->xine, XINE_VERBOSITY_LOG, 
+            _(LOG_MODULE ": input event write: %s.\n"), strerror(errno));
+}
+
+static input_plugin_t *vdr_class_get_instance(input_class_t *cls_gen, xine_stream_t *stream,
+                                               const char *data)
+{
+  vdr_input_plugin_t *this;
+  char               *mrl = strdup(data);
+
+  if (!strncasecmp(mrl, "vdr:/", 5))
+  {
+    lprintf("filename '%s'\n", (char *)&mrl[ 4 ]);
+  }
+  else
+  {
+    free(mrl);
+    return NULL;
+  }
+
+  /*
+   * mrl accepted and opened successfully at this point
+   *
+   * => create plugin instance
+   */
+
+  this = (vdr_input_plugin_t *)xine_xmalloc(sizeof (vdr_input_plugin_t));
+
+  this->stream     = stream;
+  this->curpos     = 0;
+  this->mrl        = mrl;
+  this->fh         = -1;
+  this->fh_control = -1;
+  this->fh_result  = -1;
+  this->fh_event   = -1;
+
+  this->input_plugin.open              = vdr_plugin_open;
+  this->input_plugin.get_capabilities  = vdr_plugin_get_capabilities;
+  this->input_plugin.read              = vdr_plugin_read;
+  this->input_plugin.read_block        = vdr_plugin_read_block;
+  this->input_plugin.seek              = vdr_plugin_seek;
+  this->input_plugin.get_current_pos   = vdr_plugin_get_current_pos;
+  this->input_plugin.get_length        = vdr_plugin_get_length;
+  this->input_plugin.get_blocksize     = vdr_plugin_get_blocksize;
+  this->input_plugin.get_mrl           = vdr_plugin_get_mrl;
+  this->input_plugin.dispose           = vdr_plugin_dispose;
+  this->input_plugin.get_optional_data = vdr_plugin_get_optional_data;
+  this->input_plugin.input_class       = cls_gen;
+
+  this->cur_func = func_unknown;
+  this->cur_size = 0;
+  this->cur_done = 0;
+
+  memset(this->osd_window, 0, sizeof (this->osd_window));
+
+  this->osd_buffer              = 0;
+  this->osd_buffer_size         = 0;
+  this->osd_unscaled_blending   = 0;
+  this->mute_mode               = INPUT_VDR_MUTE_SIMULATE;
+  this->dont_change_xine_volume = 0;
+  this->last_volume             = 0;
+  this->frame_size.x            = 0;
+  this->frame_size.y            = 0;
+  this->frame_size.w            = 0;
+  this->frame_size.h            = 0;
+  
+  this->stream_external      = 0;
+  this->event_queue_external = 0;
+
+  pthread_mutex_init(&this->rpc_thread_shutdown_lock, 0);
+  pthread_cond_init(&this->rpc_thread_shutdown_cond, 0);  
+  
+  this->event_queue = xine_event_new_queue(this->stream);
+  if (this->event_queue)
+    xine_event_create_listener_thread(this->event_queue, event_handler, this);
+
+  return &this->input_plugin;
+}
+
+/*
+ * vdr input plugin class stuff
+ */
+
+static char *vdr_class_get_description(input_class_t *this_gen)
+{
+  return _("VDR display device plugin");
+}
+
+static const char *vdr_class_get_identifier (input_class_t *this_gen)
+{
+  return "VDR";
+}
+
+static void vdr_class_dispose (input_class_t *this_gen)
+{
+  vdr_input_class_t *this = (vdr_input_class_t *)this_gen;
+
+  free(this);
+}
+
+static char **vdr_class_get_autoplay_list(input_class_t *this_gen,
+                                          int *num_files)
+{
+  vdr_input_class_t *class = (vdr_input_class_t *)this_gen;
+
+  *num_files = 1;
+  return class->mrls;
+}
+
+static void *init_class(xine_t *xine, void *data)
+{
+  vdr_input_class_t *this;
+  
+  lprintf("init_class\n");
+  
+  this = (vdr_input_class_t *)xine_xmalloc(sizeof (vdr_input_class_t));
+  
+  this->xine = xine;
+
+  this->mrls[ 0 ] = "vdr:" VDR_ABS_FIFO_DIR "/stream#demux:mpeg_pes";
+  this->mrls[ 1 ] = 0;
+
+  this->input_class.get_instance      = vdr_class_get_instance;
+  this->input_class.get_identifier    = vdr_class_get_identifier;
+  this->input_class.get_description   = vdr_class_get_description;
+  this->input_class.get_dir           = NULL;
+  this->input_class.get_autoplay_list = vdr_class_get_autoplay_list;
+  this->input_class.dispose           = vdr_class_dispose;
+  this->input_class.eject_media       = NULL;
+
+  return this;
+}
+
+/*
+ * exported plugin catalog entry
+ */
+
+plugin_info_t xine_plugin_info[] =
+{
+  /* type, API, "name", version, special_info, init_function */
+  { PLUGIN_INPUT, 16, "VDR", XINE_VERSION_CODE, NULL, init_class },
+  { PLUGIN_NONE, 0, "", 0, NULL, NULL }
+};
diff -Nurp ../xine-cvs/xine-lib/src/vdr/input_vdr.h xine-lib/src/vdr/input_vdr.h
--- ../xine-cvs/xine-lib/src/vdr/input_vdr.h	1970-01-01 01:00:00.000000000 +0100
+++ xine-lib/src/vdr/input_vdr.h	2005-04-06 23:53:00.000000000 +0200
@@ -0,0 +1,525 @@
+
+#ifndef __INPUT_VDR_H
+#define __INPUT_VDR_H
+
+
+
+enum funcs
+{
+  func_unknown = -1
+  , func_nop
+  , func_osd_new
+  , func_osd_free
+  , func_osd_show
+  , func_osd_hide
+  , func_osd_set_position
+  , func_osd_draw_bitmap
+  , func_set_color
+  , func_clear
+  , func_mute
+  , func_set_volume
+  , func_set_speed
+  , func_set_prebuffer
+  , func_metronom
+  , func_start
+  , func_wait
+  , func_setup
+  , func_grab_image
+  , func_get_pts
+  , func_flush
+  , func_first_frame
+  , func_still_frame
+  , func_video_size
+  , func_set_video_window
+  , func_osd_flush
+  , func_play_external
+  , func_key
+  , func_frame_size
+  , func_reset_audio
+};
+
+enum keys
+{
+  key_none,
+  key_up,
+  key_down,
+  key_menu,
+  key_ok,
+  key_back,
+  key_left,
+  key_right,
+  key_red,
+  key_green,
+  key_yellow,
+  key_blue,
+  key_0,
+  key_1,
+  key_2,
+  key_3,
+  key_4,
+  key_5,
+  key_6,
+  key_7,
+  key_8,
+  key_9,
+  key_play,
+  key_pause,
+  key_stop,
+  key_record,
+  key_fast_fwd,
+  key_fast_rew,
+  key_power,
+  key_channel_plus,
+  key_channel_minus,
+  key_volume_plus,
+  key_volume_minus,
+  key_mute,
+  key_schedule,
+  key_channels,
+  key_timers,
+  key_recordings,
+  key_setup,
+  key_commands,
+  key_user1,
+  key_user2,
+  key_user3,
+  key_user4,
+  key_user5,
+  key_user6,
+  key_user7,
+  key_user8,
+  key_user9,
+  key_audio,
+};
+
+
+
+typedef struct __attribute__((packed)) data_header_s
+{
+  uint32_t func:8;
+  uint32_t len:24;
+} 
+data_header_t;
+
+
+
+typedef data_header_t result_header_t;
+typedef data_header_t event_header_t;
+
+
+
+typedef struct __attribute__((packed)) data_nop_s
+{
+  data_header_t header;
+}
+data_nop_t;
+
+
+
+typedef struct __attribute__((packed)) data_osd_new_s
+{
+  data_header_t header;
+  
+  uint8_t  window;
+  int16_t  x;
+  int16_t  y;
+  uint16_t width;
+  uint16_t height;
+}
+data_osd_new_t;
+
+
+
+typedef struct __attribute__((packed)) data_osd_free_s
+{
+  data_header_t header;
+  
+  uint8_t window;
+}
+data_osd_free_t;
+
+
+
+typedef struct __attribute__((packed)) data_osd_show_s
+{
+  data_header_t header;
+  
+  uint8_t window;
+}
+data_osd_show_t;
+
+
+
+typedef struct __attribute__((packed)) data_osd_hide_s
+{
+  data_header_t header;
+  
+  uint8_t window;
+}
+data_osd_hide_t;
+
+
+
+typedef struct __attribute__((packed)) data_osd_flush_s
+{
+  data_header_t header;
+}
+data_osd_flush_t;
+
+
+
+typedef struct __attribute__((packed)) data_play_external_s
+{
+  data_header_t header;
+}
+data_play_external_t;
+
+
+
+typedef struct __attribute__((packed)) data_osd_set_position_s
+{
+  data_header_t header;
+  
+  uint8_t window;
+  int16_t x;
+  int16_t y;
+}
+data_osd_set_position_t;
+
+
+
+typedef struct __attribute__((packed)) data_osd_draw_bitmap_s
+{
+  data_header_t header;
+  
+  uint8_t  window;
+  int16_t  x;
+  int16_t  y;
+  uint16_t width;
+  uint16_t height;
+}
+data_osd_draw_bitmap_t;
+
+
+
+typedef struct __attribute__((packed)) data_set_color_s
+{
+  data_header_t header;
+  
+  uint8_t window;
+  uint8_t index;
+  uint8_t num;
+}
+data_set_color_t;
+
+
+
+typedef struct __attribute__((packed)) data_flush_s
+{
+  data_header_t header;
+
+  int32_t ms_timeout;
+  uint8_t just_wait;
+}
+data_flush_t;
+
+
+
+typedef struct __attribute__((packed)) result_flush_s
+{
+  result_header_t header;
+  
+  uint8_t timed_out;
+}
+result_flush_t;
+
+
+
+typedef struct __attribute__((packed)) data_clear_s
+{
+  data_header_t header;
+
+  int32_t n;
+}
+data_clear_t;
+
+
+
+typedef struct __attribute__((packed)) data_mute_s
+{
+  data_header_t header;
+
+  uint8_t mute;
+}
+data_mute_t;
+
+
+
+typedef struct __attribute__((packed)) data_set_volume_s
+{
+  data_header_t header;
+
+  uint8_t volume;
+}
+data_set_volume_t;
+
+
+
+typedef struct __attribute__((packed)) data_set_speed_s
+{
+  data_header_t header;
+
+  int32_t speed;
+}
+data_set_speed_t;
+
+
+
+typedef struct __attribute__((packed)) data_set_prebuffer_s
+{
+  data_header_t header;
+
+  uint32_t prebuffer;
+}
+data_set_prebuffer_t;
+
+
+
+typedef struct __attribute__((packed)) data_metronom_s
+{
+  data_header_t header;
+
+  int64_t  pts;
+  uint32_t flags;
+}
+data_metronom_t;
+
+
+
+typedef struct __attribute__((packed)) data_start_s
+{
+  data_header_t header;
+}
+data_start_t;
+
+
+
+typedef struct __attribute__((packed)) data_wait_s
+{
+  data_header_t header;
+
+  uint8_t data[ 64 * 1024 - sizeof (data_header_t) ];
+}
+data_wait_t;
+
+
+
+#define INPUT_VDR_MUTE_IGNORE   0
+#define INPUT_VDR_MUTE_EXECUTE  1
+#define INPUT_VDR_MUTE_SIMULATE 2
+
+typedef struct __attribute__((packed)) data_setup_s
+{
+  data_header_t header;
+
+  uint8_t osd_unscaled_blending;
+  uint8_t dont_change_xine_volume;
+  uint8_t mute_mode;
+}
+data_setup_t;
+
+
+
+typedef struct __attribute__((packed)) data_first_frame_s
+{
+  data_header_t header;
+}
+data_first_frame_t;
+
+
+
+typedef struct __attribute__((packed)) data_still_frame_s
+{
+  data_header_t header;
+}
+data_still_frame_t;
+
+
+
+typedef struct __attribute__((packed)) data_set_video_window_s
+{
+  data_header_t header;
+
+  uint32_t x;
+  uint32_t y;
+  uint32_t w;
+  uint32_t h;
+  uint32_t w_ref;
+  uint32_t h_ref;
+}
+data_set_video_window_t;
+
+
+
+typedef struct __attribute__((packed)) data_grab_image_s
+{
+  data_header_t header;
+}
+data_grab_image_t;
+
+
+
+typedef struct __attribute__((packed)) result_grab_image_s
+{
+  result_header_t header;
+
+  int32_t width;
+  int32_t height;
+  int32_t ratio;
+  int32_t format;
+}
+result_grab_image_t;
+
+
+
+typedef struct __attribute__((packed)) data_get_pts_s
+{
+  data_header_t header;
+}
+data_get_pts_t;
+
+
+
+typedef struct __attribute__((packed)) result_get_pts_s
+{
+  result_header_t header;
+
+  int64_t pts;
+}
+result_get_pts_t;
+
+
+
+typedef struct __attribute__((packed)) data_video_size_s
+{
+  data_header_t header;
+}
+data_video_size_t;
+
+
+
+typedef struct __attribute__((packed)) result_video_size_s
+{
+  result_header_t header;
+
+  int32_t left;
+  int32_t top;
+  int32_t width;
+  int32_t height;
+  int32_t ratio;
+}
+result_video_size_t;
+
+
+
+typedef struct __attribute__((packed)) data_reset_audio_s
+{
+  data_header_t header;
+}
+data_reset_audio_t;
+
+
+
+typedef struct __attribute__((packed)) event_key_s
+{
+  event_header_t header;
+  
+  uint32_t key;
+}
+event_key_t;
+
+
+
+typedef struct __attribute__((packed)) event_frame_size_s
+{
+  event_header_t header;
+  
+  int32_t left;
+  int32_t top;
+  int32_t width;
+  int32_t height;
+}
+event_frame_size_t;
+
+
+
+typedef struct __attribute__((packed)) event_play_external_s
+{
+  event_header_t header;
+  
+  uint32_t key;
+}
+event_play_external_t;
+
+
+
+typedef union __attribute__((packed)) data_union_u
+{
+  data_header_t           header;
+  data_nop_t              nop;
+  data_osd_new_t          osd_new;
+  data_osd_free_t         osd_free;
+  data_osd_show_t         osd_show;
+  data_osd_hide_t         osd_hide;
+  data_osd_set_position_t osd_set_position;
+  data_osd_draw_bitmap_t  osd_draw_bitmap;
+  data_set_color_t        set_color;
+  data_flush_t            flush;
+  data_clear_t            clear;
+  data_mute_t             mute;
+  data_set_volume_t       set_volume;
+  data_set_speed_t        set_speed;
+  data_set_prebuffer_t    set_prebuffer;
+  data_metronom_t         metronom;
+  data_start_t            start;
+  data_wait_t             wait;
+  data_setup_t            setup;
+  data_grab_image_t       grab_image;
+  data_get_pts_t          get_pts;
+  data_first_frame_t      first_frame;
+  data_still_frame_t      still_frame;
+  data_video_size_t       video_size;
+  data_set_video_window_t set_video_window;
+  data_osd_flush_t        osd_flush;
+  data_play_external_t    play_external;
+  data_reset_audio_t      reset_audio;
+}
+data_union_t;
+
+
+
+typedef union __attribute__((packed)) result_union_u
+{
+  result_header_t         header;
+  result_grab_image_t     grab_image;
+  result_get_pts_t        get_pts;
+  result_flush_t          flush;
+  result_video_size_t     video_size;
+}
+result_union_t;
+
+
+
+typedef union __attribute__((packed)) event_union_u
+{
+  event_header_t          header;
+  event_key_t             key;
+  event_frame_size_t      frame_size;
+  event_play_external_t   play_external;
+}
+event_union_t;
+
+
+
+#endif /* __INPUT_VDR_H */
+
diff -Nurp ../xine-cvs/xine-lib/src/vdr/post_vdr.c xine-lib/src/vdr/post_vdr.c
--- ../xine-cvs/xine-lib/src/vdr/post_vdr.c	1970-01-01 01:00:00.000000000 +0100
+++ xine-lib/src/vdr/post_vdr.c	2005-04-10 00:14:14.000000000 +0200
@@ -0,0 +1,499 @@
+/*
+ * Copyright (C) 2000-2004 the xine project
+ * 
+ * This file is part of xine, a free video player.
+ * 
+ * xine is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * xine is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
+ *
+ * $Id: vdr.c,v 1.20 2004/04/17 19:54:32 mroi Exp $
+ */
+ 
+/*
+ * frame scaler plugin for VDR
+ */
+
+#include "xine_internal.h"
+#include "post.h"
+#include "post_vdr.h"
+
+
+
+typedef struct vdr_post_plugin_s
+{
+  post_plugin_t post_plugin;
+
+  xine_event_queue_t *event_queue;
+  xine_stream_t      *vdr_stream;
+  
+  int8_t enabled;
+  
+  int32_t x;
+  int32_t y;
+  int32_t w;
+  int32_t h;
+  int32_t w_ref;
+  int32_t h_ref;
+
+  int32_t old_frame_left;
+  int32_t old_frame_top;
+  int32_t old_frame_width;
+  int32_t old_frame_height;
+  
+}
+vdr_post_plugin_t;
+
+
+static void vdr_set_video_window(vdr_post_plugin_t *this, int32_t x, int32_t y, int32_t w, int32_t h, int32_t w_ref, int32_t h_ref)
+{
+  this->enabled = 0;
+  
+  this->x     = x;
+  this->y     = y;
+  this->w     = w;
+  this->h     = h;
+  this->w_ref = w_ref;
+  this->h_ref = h_ref;
+
+  if (w != w_ref || h != h_ref)
+    this->enabled = 1;
+}
+
+ 
+/* plugin class initialization function */
+static void *vdr_init_plugin(xine_t *xine, void *);
+
+/* plugin class functions */
+static post_plugin_t *vdr_open_plugin(post_class_t *class_gen, int inputs,
+				      xine_audio_port_t **audio_target,
+				      xine_video_port_t **video_target);
+static char          *vdr_get_identifier(post_class_t *class_gen);
+static char          *vdr_get_description(post_class_t *class_gen);
+static void           vdr_class_dispose(post_class_t *class_gen);
+
+/* plugin instance functions */
+static void           vdr_dispose(post_plugin_t *this_gen);
+
+/* frame intercept check */
+static int            vdr_intercept_frame(post_video_port_t *port, vo_frame_t *frame);
+
+/* replaced vo_frame functions */
+static int            vdr_draw(vo_frame_t *frame, xine_stream_t *stream);
+
+
+void *vdr_init_plugin(xine_t *xine, void *data)
+{
+  post_class_t *class = (post_class_t *)malloc(sizeof (post_class_t));
+  
+  if (!class)
+    return NULL;
+  
+  class->open_plugin     = vdr_open_plugin;
+  class->get_identifier  = vdr_get_identifier;
+  class->get_description = vdr_get_description;
+  class->dispose         = vdr_class_dispose;
+  
+  return class;
+}
+
+
+static vdr_post_plugin_t *vdr_singleton = 0;
+
+static post_plugin_t *vdr_open_plugin(post_class_t *class_gen, int inputs,
+				      xine_audio_port_t **audio_target,
+				      xine_video_port_t **video_target)
+{
+  vdr_post_plugin_t *this = (vdr_post_plugin_t *)xine_xmalloc(sizeof (vdr_post_plugin_t));
+  post_in_t         *input;
+  post_out_t        *output;
+  post_video_port_t *port;
+  
+  if (vdr_singleton || !this || !video_target || !video_target[ 0 ])
+  {
+    free(this);
+    return NULL;
+  }
+
+  _x_post_init(&this->post_plugin, 0, 1);
+
+  port = _x_post_intercept_video_port(&this->post_plugin, video_target[ 0 ], &input, &output);
+  port->intercept_frame = vdr_intercept_frame;
+  port->new_frame->draw = vdr_draw;
+  input->xine_in.name   = "video";
+  output->xine_out.name = "VDR enhanced video";
+  this->post_plugin.xine_post.video_input[ 0 ] = &port->new_port;
+  
+  this->post_plugin.dispose = vdr_dispose;
+  
+  
+  
+  vdr_singleton = this;
+
+  this->enabled          = 0;
+  this->vdr_stream       = 0;
+  this->event_queue      = 0;
+  this->old_frame_left   = 0;
+  this->old_frame_top    = 0;
+  this->old_frame_width  = 0;
+  this->old_frame_height = 0;
+  
+  return &this->post_plugin;
+}
+
+static char *vdr_get_identifier(post_class_t *class_gen)
+{
+  return "vdr";
+}
+
+static char *vdr_get_description(post_class_t *class_gen)
+{
+  return "modifies every video frame as requested by VDR";
+}
+
+static void vdr_class_dispose(post_class_t *class_gen)
+{
+  free(class_gen);
+}
+
+
+static void vdr_dispose(post_plugin_t *this_gen)
+{
+  if (_x_post_dispose(this_gen))
+  {
+    vdr_post_plugin_t *this = (vdr_post_plugin_t *)this_gen;
+    
+    vdr_singleton = 0;
+    
+    if (this->vdr_stream)
+    {
+      xine_event_t event;
+      vdr_frame_size_changed_data_t event_data;
+
+      event_data.x = 0;
+      event_data.y = 0;
+      event_data.w = 0;
+      event_data.h = 0;
+      
+      event.type        = XINE_EVENT_VDR_FRAMESIZECHANGED;
+      event.data        = &event_data;
+      event.data_length = sizeof (event_data);
+      
+      xine_event_send(this->vdr_stream, &event);
+
+      xine_event_dispose_queue(this->event_queue);
+    }
+    
+    free(this_gen);
+  }
+}
+
+
+static int vdr_intercept_frame(post_video_port_t *port, vo_frame_t *frame)
+{
+  return (frame->format == XINE_IMGFMT_YUY2
+          || frame->format == XINE_IMGFMT_YV12);
+}
+
+
+static inline void vdr_scale(uint8_t *src, uint8_t *dst, int y_inc, int x_inc, int w_dst, int h_dst, int x, int y, int w, int h, int w_ref, int h_ref, int init)
+{
+  int x0 = x * w_dst / w_ref;
+  int y0 = y * h_dst / h_ref;
+
+  int x1 = ((x + w) * w_dst - 1 + w_ref) / w_ref;
+  int y1 = ((y + h) * h_dst - 1 + h_ref) / h_ref;
+
+  int dx = x1 - x0;
+  int dy = y1 - y0;
+
+  int yy, xx;
+
+  int dy2    = dy + dy;
+  int h_dst2 = h_dst + h_dst;
+  int y_eps  = h_dst - dy2;
+
+  int dx2    = dx + dx;
+  int w_dst2 = w_dst + w_dst;
+  int x_eps0 = w_dst - dx2;
+    
+  for (yy = 0; yy < y0; yy++)
+  {
+    uint8_t *dst0 = dst;
+    
+    for (xx = 0; xx < w_dst; xx++)
+    {
+      *dst0 = init;
+      dst0 += x_inc;
+    }
+
+    dst += y_inc;
+  }
+
+  for (yy = y0; yy < y1; yy++)
+  {
+    uint8_t *dst0 = dst;
+    uint8_t *src0 = src;
+
+    int x_eps = x_eps0;
+    
+    for (xx = 0; xx < x0; xx++)
+    {
+      *dst0 = init;
+      dst0 += x_inc;
+    }
+    
+    for (xx = x0; xx < x1; xx++)
+    {
+      *dst0 = *src0;
+      dst0 += x_inc;
+      
+      x_eps += w_dst2;
+      while (x_eps >= 0)
+      {
+        src0  += x_inc;
+        x_eps -= dx2;
+      }
+    }
+    
+    for (xx = x1; xx < w_dst; xx++)
+    {
+      *dst0 = init;
+      dst0 += x_inc;
+    }
+
+    dst += y_inc;
+
+    y_eps += h_dst2;
+    while (y_eps >= 0)
+    {
+      src   += y_inc;
+      y_eps -= dy2;
+    }
+  }
+  
+  for (yy = y1; yy < h_dst; yy++)
+  {
+    uint8_t *dst0 = dst;
+    
+    for (xx = 0; xx < w_dst; xx++)
+    {
+      *dst0 = init;
+      dst0 += x_inc;
+    }
+
+    dst += y_inc;
+  }  
+}
+
+static void vdr_scale_YUY2(vdr_post_plugin_t *this, vo_frame_t *src, vo_frame_t *dst)
+{
+  int w = dst->width  - dst->crop_left - dst->crop_right;
+  int h = dst->height - dst->crop_top  - dst->crop_bottom;
+  int offset;
+  
+  if (w < 0)
+    w = 0;
+  
+  if (h < 0)
+    h = 0;
+
+  offset = dst->pitches[ 0 ] * dst->crop_top + 2 *   dst->crop_left;
+  vdr_scale(&src->base[ 0 ][ 0 ] + offset, &dst->base[ 0 ][ 0 ] + offset, dst->pitches[ 0 ], 2,  w         , h, this->x, this->y, this->w, this->h, this->w_ref, this->h_ref, 0x00);
+  offset = dst->pitches[ 0 ] * dst->crop_top + 4 * ((dst->crop_left + 1) / 2);
+  vdr_scale(&src->base[ 0 ][ 1 ] + offset, &dst->base[ 0 ][ 1 ] + offset, dst->pitches[ 0 ], 4, (w + 1) / 2, h, this->x, this->y, this->w, this->h, this->w_ref, this->h_ref, 0x80);
+  offset = dst->pitches[ 0 ] * dst->crop_top + 4 * ((dst->crop_left + 1) / 2);
+  vdr_scale(&src->base[ 0 ][ 3 ] + offset, &dst->base[ 0 ][ 3 ] + offset, dst->pitches[ 0 ], 4, (w + 1) / 2, h, this->x, this->y, this->w, this->h, this->w_ref, this->h_ref, 0x80);
+}
+
+static void vdr_scale_YV12(vdr_post_plugin_t *this, vo_frame_t *src, vo_frame_t *dst)
+{
+  int w = dst->width  - dst->crop_left - dst->crop_right;
+  int h = dst->height - dst->crop_top  - dst->crop_bottom;
+  int offset;
+  
+  if (w < 0)
+    w = 0;
+  
+  if (h < 0)
+    h = 0;
+
+  offset = dst->pitches[ 0 ] *   dst->crop_top           + 1 *   dst->crop_left;
+  vdr_scale(&src->base[ 0 ][ 0 ] + offset, &dst->base[ 0 ][ 0 ] + offset, dst->pitches[ 0 ], 1,  w         ,  h         , this->x, this->y, this->w, this->h, this->w_ref, this->h_ref, 0x00);
+  offset = dst->pitches[ 1 ] * ((dst->crop_top + 1) / 2) + 1 * ((dst->crop_left + 1) / 2);
+  vdr_scale(&src->base[ 1 ][ 0 ] + offset, &dst->base[ 1 ][ 0 ] + offset, dst->pitches[ 1 ], 1, (w + 1) / 2, (h + 1) / 2, this->x, this->y, this->w, this->h, this->w_ref, this->h_ref, 0x80);
+  offset = dst->pitches[ 2 ] * ((dst->crop_top + 1) / 2) + 1 * ((dst->crop_left + 1) / 2);
+  vdr_scale(&src->base[ 2 ][ 0 ] + offset, &dst->base[ 2 ][ 0 ] + offset, dst->pitches[ 2 ], 1, (w + 1) / 2, (h + 1) / 2, this->x, this->y, this->w, this->h, this->w_ref, this->h_ref, 0x80);
+}
+
+
+static int vdr_is_vdr_stream(xine_stream_t *stream)
+{
+  if (!stream
+      || !stream->input_plugin
+      || !stream->input_plugin->input_class)
+  {
+    return 0;
+  }
+
+  {
+    input_class_t *input_class = stream->input_plugin->input_class;
+
+    if (input_class->get_identifier)
+    {
+      const char *identifier = input_class->get_identifier(input_class);
+      if (identifier
+          && 0 == strcmp(identifier, "VDR"))
+      {
+        return 1;
+      }
+    }
+  }
+
+  return 0;
+}
+
+
+static int vdr_draw(vo_frame_t *frame, xine_stream_t *stream)
+{
+  post_video_port_t *port = (post_video_port_t *)frame->port;
+  vdr_post_plugin_t *this = (vdr_post_plugin_t *)port->post;
+  vo_frame_t *vdr_frame;
+  xine_event_t *event;
+  int skip;
+
+  if (this->vdr_stream
+      && !_x_continue_stream_processing(this->vdr_stream))
+  {
+    this->vdr_stream = 0;
+    
+    xine_event_dispose_queue(this->event_queue);
+    this->event_queue = 0;
+    
+    this->old_frame_left   = 0;
+    this->old_frame_top    = 0;
+    this->old_frame_width  = 0;
+    this->old_frame_height = 0;
+  }
+  
+  if (!this->vdr_stream
+      && vdr_is_vdr_stream(stream))
+  {
+    this->event_queue = xine_event_new_queue(stream);
+    if (this->event_queue)
+      this->vdr_stream = stream;
+  }
+  
+  if (this->event_queue)
+  {
+    while ((event = xine_event_get(this->event_queue)))
+    {
+      if (event->type == XINE_EVENT_VDR_SETVIDEOWINDOW)
+      {
+        vdr_set_video_window_data_t *data = (vdr_set_video_window_data_t *)event->data;
+        
+        vdr_set_video_window(this, data->x, data->y, data->w, data->h, data->w_ref, data->h_ref);
+      }
+
+      xine_event_free(event);
+    }
+  }
+
+  {
+    int frame_left   = frame->crop_left;
+    int frame_width  = frame->width - frame->crop_left - frame->crop_right;
+    int frame_top    = frame->crop_top;
+    int frame_height = frame->height - frame->crop_top - frame->crop_bottom;
+
+    if (frame_left < 0)
+      frame_left = 0;
+    if (frame_width > frame->width)
+      frame_width = frame->width;
+    if (frame_top < 0)
+      frame_top = 0;
+    if (frame_height > frame->height)
+      frame_height = frame->height;
+    
+    if (this->vdr_stream
+        && (this->old_frame_left != frame_left
+          || this->old_frame_top != frame_top
+          || this->old_frame_width != frame_width
+          || this->old_frame_height != frame_height))
+    {
+      xine_event_t event;
+      vdr_frame_size_changed_data_t event_data;
+
+      event_data.x = frame_left;
+      event_data.y = frame_top;
+      event_data.w = frame_width;
+      event_data.h = frame_height;
+      
+fprintf(stderr, "osd: (%d, %d)-(%d, %d)\n", frame_left, frame_top, frame_width, frame_height);
+      event.type        = XINE_EVENT_VDR_FRAMESIZECHANGED;
+      event.data        = &event_data;
+      event.data_length = sizeof (event_data);
+      
+      xine_event_send(this->vdr_stream, &event);
+    
+      this->old_frame_left   = frame_left;
+      this->old_frame_top    = frame_top;
+      this->old_frame_width  = frame_width;
+      this->old_frame_height = frame_height;
+    }
+  }
+  
+  if (!this->enabled 
+      || frame->bad_frame
+      || (frame->format != XINE_IMGFMT_YUY2
+          && frame->format != XINE_IMGFMT_YV12))
+  {
+    _x_post_frame_copy_down(frame, frame->next);
+    skip = frame->next->draw(frame->next, stream);
+    _x_post_frame_copy_up(frame, frame->next);
+    return skip;
+  }
+
+  vdr_frame = port->original_port->get_frame(port->original_port,
+    frame->width, frame->height, frame->ratio, frame->format, frame->flags | VO_BOTH_FIELDS);
+
+  _x_post_frame_copy_down(frame, vdr_frame);
+    
+  switch (vdr_frame->format)
+  {
+  case XINE_IMGFMT_YUY2:
+    vdr_scale_YUY2(this, frame, vdr_frame);
+    break;
+    
+  case XINE_IMGFMT_YV12:
+    vdr_scale_YV12(this, frame, vdr_frame);    
+    break;
+  }
+  
+  skip = vdr_frame->draw(vdr_frame, stream);
+  _x_post_frame_copy_up(frame, vdr_frame);
+  vdr_frame->free(vdr_frame);
+  
+  return skip;
+}
+
+
+
+static post_info_t vdr_special_info = { XINE_POST_TYPE_VIDEO_FILTER };
+
+plugin_info_t xine_plugin_info[] =
+{
+  /* type, API, "name", version, special_info, init_function */  
+  { PLUGIN_POST, 9, "vdr", XINE_VERSION_CODE, &vdr_special_info, &vdr_init_plugin },
+  { PLUGIN_NONE, 0, "", 0, NULL, NULL }
+};
+
diff -Nurp ../xine-cvs/xine-lib/src/vdr/post_vdr.h xine-lib/src/vdr/post_vdr.h
--- ../xine-cvs/xine-lib/src/vdr/post_vdr.h	1970-01-01 01:00:00.000000000 +0100
+++ xine-lib/src/vdr/post_vdr.h	2005-01-25 22:50:36.000000000 +0100
@@ -0,0 +1,30 @@
+
+#ifndef __POST_VDR_H
+#define __POST_VDR_H
+
+
+
+typedef struct vdr_set_video_window_data_s {
+  int32_t x;
+  int32_t y;
+  int32_t w;
+  int32_t h;
+  int32_t w_ref;
+  int32_t h_ref;
+
+} vdr_set_video_window_data_t;
+
+
+
+typedef struct vdr_frame_size_changed_data_s {
+  int32_t x;
+  int32_t y;
+  int32_t w;
+  int32_t h;
+
+} vdr_frame_size_changed_data_t;
+
+
+
+#endif /* __POST_VDR_H */
+
